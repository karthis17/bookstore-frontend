"use strict"; (self.webpackChunkbookstore_frontend = self.webpackChunkbookstore_frontend || []).push([[179], { 603: () => { function ne(t) { return "function" == typeof t } function ts(t) { const e = t(i => { Error.call(i), i.stack = (new Error).stack }); return e.prototype = Object.create(Error.prototype), e.prototype.constructor = e, e } const Ja = ts(t => function (e) { t(this), this.message = e ? `${e.length} errors occurred during unsubscription:\n${e.map((i, o) => `${o + 1}) ${i.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = e }); function Io(t, n) { if (t) { const e = t.indexOf(n); 0 <= e && t.splice(e, 1) } } class Fe { constructor(n) { this.initialTeardown = n, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let n; if (!this.closed) { this.closed = !0; const { _parentage: e } = this; if (e) if (this._parentage = null, Array.isArray(e)) for (const r of e) r.remove(this); else e.remove(this); const { initialTeardown: i } = this; if (ne(i)) try { i() } catch (r) { n = r instanceof Ja ? r.errors : [r] } const { _finalizers: o } = this; if (o) { this._finalizers = null; for (const r of o) try { Cg(r) } catch (s) { n = n ?? [], s instanceof Ja ? n = [...n, ...s.errors] : n.push(s) } } if (n) throw new Ja(n) } } add(n) { var e; if (n && n !== this) if (this.closed) Cg(n); else { if (n instanceof Fe) { if (n.closed || n._hasParent(this)) return; n._addParent(this) } (this._finalizers = null !== (e = this._finalizers) && void 0 !== e ? e : []).push(n) } } _hasParent(n) { const { _parentage: e } = this; return e === n || Array.isArray(e) && e.includes(n) } _addParent(n) { const { _parentage: e } = this; this._parentage = Array.isArray(e) ? (e.push(n), e) : e ? [e, n] : n } _removeParent(n) { const { _parentage: e } = this; e === n ? this._parentage = null : Array.isArray(e) && Io(e, n) } remove(n) { const { _finalizers: e } = this; e && Io(e, n), n instanceof Fe && n._removeParent(this) } } Fe.EMPTY = (() => { const t = new Fe; return t.closed = !0, t })(); const wg = Fe.EMPTY; function xg(t) { return t instanceof Fe || t && "closed" in t && ne(t.remove) && ne(t.add) && ne(t.unsubscribe) } function Cg(t) { ne(t) ? t() : t.unsubscribe() } const Ui = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, el = { setTimeout(t, n, ...e) { const { delegate: i } = el; return i?.setTimeout ? i.setTimeout(t, n, ...e) : setTimeout(t, n, ...e) }, clearTimeout(t) { const { delegate: n } = el; return (n?.clearTimeout || clearTimeout)(t) }, delegate: void 0 }; function Dg(t) { el.setTimeout(() => { const { onUnhandledError: n } = Ui; if (!n) throw t; n(t) }) } function tl() { } const hI = ou("C", void 0, void 0); function ou(t, n, e) { return { kind: t, value: n, error: e } } let zi = null; function nl(t) { if (Ui.useDeprecatedSynchronousErrorHandling) { const n = !zi; if (n && (zi = { errorThrown: !1, error: null }), t(), n) { const { errorThrown: e, error: i } = zi; if (zi = null, e) throw i } } else t() } class ru extends Fe { constructor(n) { super(), this.isStopped = !1, n ? (this.destination = n, xg(n) && n.add(this)) : this.destination = bI } static create(n, e, i) { return new ns(n, e, i) } next(n) { this.isStopped ? au(function pI(t) { return ou("N", t, void 0) }(n), this) : this._next(n) } error(n) { this.isStopped ? au(function fI(t) { return ou("E", void 0, t) }(n), this) : (this.isStopped = !0, this._error(n)) } complete() { this.isStopped ? au(hI, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(n) { this.destination.next(n) } _error(n) { try { this.destination.error(n) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const gI = Function.prototype.bind; function su(t, n) { return gI.call(t, n) } class _I { constructor(n) { this.partialObserver = n } next(n) { const { partialObserver: e } = this; if (e.next) try { e.next(n) } catch (i) { il(i) } } error(n) { const { partialObserver: e } = this; if (e.error) try { e.error(n) } catch (i) { il(i) } else il(n) } complete() { const { partialObserver: n } = this; if (n.complete) try { n.complete() } catch (e) { il(e) } } } class ns extends ru { constructor(n, e, i) { let o; if (super(), ne(n) || !n) o = { next: n ?? void 0, error: e ?? void 0, complete: i ?? void 0 }; else { let r; this && Ui.useDeprecatedNextContext ? (r = Object.create(n), r.unsubscribe = () => this.unsubscribe(), o = { next: n.next && su(n.next, r), error: n.error && su(n.error, r), complete: n.complete && su(n.complete, r) }) : o = n } this.destination = new _I(o) } } function il(t) { Ui.useDeprecatedSynchronousErrorHandling ? function mI(t) { Ui.useDeprecatedSynchronousErrorHandling && zi && (zi.errorThrown = !0, zi.error = t) }(t) : Dg(t) } function au(t, n) { const { onStoppedNotification: e } = Ui; e && el.setTimeout(() => e(t, n)) } const bI = { closed: !0, next: tl, error: function vI(t) { throw t }, complete: tl }, lu = "function" == typeof Symbol && Symbol.observable || "@@observable"; function pi(t) { return t } function Eg(t) { return 0 === t.length ? pi : 1 === t.length ? t[0] : function (e) { return t.reduce((i, o) => o(i), e) } } let xe = (() => { class t { constructor(e) { e && (this._subscribe = e) } lift(e) { const i = new t; return i.source = this, i.operator = e, i } subscribe(e, i, o) { const r = function xI(t) { return t && t instanceof ru || function wI(t) { return t && ne(t.next) && ne(t.error) && ne(t.complete) }(t) && xg(t) }(e) ? e : new ns(e, i, o); return nl(() => { const { operator: s, source: a } = this; r.add(s ? s.call(r, a) : a ? this._subscribe(r) : this._trySubscribe(r)) }), r } _trySubscribe(e) { try { return this._subscribe(e) } catch (i) { e.error(i) } } forEach(e, i) { return new (i = Sg(i))((o, r) => { const s = new ns({ next: a => { try { e(a) } catch (l) { r(l), s.unsubscribe() } }, error: r, complete: o }); this.subscribe(s) }) } _subscribe(e) { var i; return null === (i = this.source) || void 0 === i ? void 0 : i.subscribe(e) } [lu]() { return this } pipe(...e) { return Eg(e)(this) } toPromise(e) { return new (e = Sg(e))((i, o) => { let r; this.subscribe(s => r = s, s => o(s), () => i(r)) }) } } return t.create = n => new t(n), t })(); function Sg(t) { var n; return null !== (n = t ?? Ui.Promise) && void 0 !== n ? n : Promise } const CI = ts(t => function () { t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let ie = (() => { class t extends xe { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(e) { const i = new Mg(this, this); return i.operator = e, i } _throwIfClosed() { if (this.closed) throw new CI } next(e) { nl(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const i of this.currentObservers) i.next(e) } }) } error(e) { nl(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = e; const { observers: i } = this; for (; i.length;)i.shift().error(e) } }) } complete() { nl(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: e } = this; for (; e.length;)e.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var e; return (null === (e = this.observers) || void 0 === e ? void 0 : e.length) > 0 } _trySubscribe(e) { return this._throwIfClosed(), super._trySubscribe(e) } _subscribe(e) { return this._throwIfClosed(), this._checkFinalizedStatuses(e), this._innerSubscribe(e) } _innerSubscribe(e) { const { hasError: i, isStopped: o, observers: r } = this; return i || o ? wg : (this.currentObservers = null, r.push(e), new Fe(() => { this.currentObservers = null, Io(r, e) })) } _checkFinalizedStatuses(e) { const { hasError: i, thrownError: o, isStopped: r } = this; i ? e.error(o) : r && e.complete() } asObservable() { const e = new xe; return e.source = this, e } } return t.create = (n, e) => new Mg(n, e), t })(); class Mg extends ie { constructor(n, e) { super(), this.destination = n, this.source = e } next(n) { var e, i; null === (i = null === (e = this.destination) || void 0 === e ? void 0 : e.next) || void 0 === i || i.call(e, n) } error(n) { var e, i; null === (i = null === (e = this.destination) || void 0 === e ? void 0 : e.error) || void 0 === i || i.call(e, n) } complete() { var n, e; null === (e = null === (n = this.destination) || void 0 === n ? void 0 : n.complete) || void 0 === e || e.call(n) } _subscribe(n) { var e, i; return null !== (i = null === (e = this.source) || void 0 === e ? void 0 : e.subscribe(n)) && void 0 !== i ? i : wg } } function Ig(t) { return ne(t?.lift) } function Pe(t) { return n => { if (Ig(n)) return n.lift(function (e) { try { return t(e, this) } catch (i) { this.error(i) } }); throw new TypeError("Unable to lift unknown Observable type") } } function Ie(t, n, e, i, o) { return new DI(t, n, e, i, o) } class DI extends ru { constructor(n, e, i, o, r, s) { super(n), this.onFinalize = r, this.shouldUnsubscribe = s, this._next = e ? function (a) { try { e(a) } catch (l) { n.error(l) } } : super._next, this._error = o ? function (a) { try { o(a) } catch (l) { n.error(l) } finally { this.unsubscribe() } } : super._error, this._complete = i ? function () { try { i() } catch (a) { n.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var n; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: e } = this; super.unsubscribe(), !e && (null === (n = this.onFinalize) || void 0 === n || n.call(this)) } } } function X(t, n) { return Pe((e, i) => { let o = 0; e.subscribe(Ie(i, r => { i.next(t.call(n, r, o++)) })) }) } function mi(t) { return this instanceof mi ? (this.v = t, this) : new mi(t) } function Og(t) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var e, n = t[Symbol.asyncIterator]; return n ? n.call(t) : (t = function hu(t) { var n = "function" == typeof Symbol && Symbol.iterator, e = n && t[n], i = 0; if (e) return e.call(t); if (t && "number" == typeof t.length) return { next: function () { return t && i >= t.length && (t = void 0), { value: t && t[i++], done: !t } } }; throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.") }(t), e = {}, i("next"), i("throw"), i("return"), e[Symbol.asyncIterator] = function () { return this }, e); function i(r) { e[r] = t[r] && function (s) { return new Promise(function (a, l) { !function o(r, s, a, l) { Promise.resolve(l).then(function (c) { r({ value: c, done: a }) }, s) }(a, l, (s = t[r](s)).done, s.value) }) } } } "function" == typeof SuppressedError && SuppressedError; const fu = t => t && "number" == typeof t.length && "function" != typeof t; function kg(t) { return ne(t?.then) } function Fg(t) { return ne(t[lu]) } function Pg(t) { return Symbol.asyncIterator && ne(t?.[Symbol.asyncIterator]) } function Ng(t) { return new TypeError(`You provided ${null !== t && "object" == typeof t ? "an invalid object" : `'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const Lg = function qI() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function Vg(t) { return ne(t?.[Lg]) } function Bg(t) { return function Rg(t, n, e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var o, i = e.apply(t, n || []), r = []; return o = {}, s("next"), s("throw"), s("return"), o[Symbol.asyncIterator] = function () { return this }, o; function s(h) { i[h] && (o[h] = function (f) { return new Promise(function (p, m) { r.push([h, f, p, m]) > 1 || a(h, f) }) }) } function a(h, f) { try { !function l(h) { h.value instanceof mi ? Promise.resolve(h.value.v).then(c, d) : u(r[0][2], h) }(i[h](f)) } catch (p) { u(r[0][3], p) } } function c(h) { a("next", h) } function d(h) { a("throw", h) } function u(h, f) { h(f), r.shift(), r.length && a(r[0][0], r[0][1]) } }(this, arguments, function* () { const e = t.getReader(); try { for (; ;) { const { value: i, done: o } = yield mi(e.read()); if (o) return yield mi(void 0); yield yield mi(i) } } finally { e.releaseLock() } }) } function jg(t) { return ne(t?.getReader) } function dt(t) { if (t instanceof xe) return t; if (null != t) { if (Fg(t)) return function WI(t) { return new xe(n => { const e = t[lu](); if (ne(e.subscribe)) return e.subscribe(n); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(t); if (fu(t)) return function YI(t) { return new xe(n => { for (let e = 0; e < t.length && !n.closed; e++)n.next(t[e]); n.complete() }) }(t); if (kg(t)) return function ZI(t) { return new xe(n => { t.then(e => { n.closed || (n.next(e), n.complete()) }, e => n.error(e)).then(null, Dg) }) }(t); if (Pg(t)) return Hg(t); if (Vg(t)) return function XI(t) { return new xe(n => { for (const e of t) if (n.next(e), n.closed) return; n.complete() }) }(t); if (jg(t)) return function KI(t) { return Hg(Bg(t)) }(t) } throw Ng(t) } function Hg(t) { return new xe(n => { (function QI(t, n) { var e, i, o, r; return function Ag(t, n, e, i) { return new (e || (e = Promise))(function (r, s) { function a(d) { try { c(i.next(d)) } catch (u) { s(u) } } function l(d) { try { c(i.throw(d)) } catch (u) { s(u) } } function c(d) { d.done ? r(d.value) : function o(r) { return r instanceof e ? r : new e(function (s) { s(r) }) }(d.value).then(a, l) } c((i = i.apply(t, n || [])).next()) }) }(this, void 0, void 0, function* () { try { for (e = Og(t); !(i = yield e.next()).done;)if (n.next(i.value), n.closed) return } catch (s) { o = { error: s } } finally { try { i && !i.done && (r = e.return) && (yield r.call(e)) } finally { if (o) throw o.error } } n.complete() }) })(t, n).catch(e => n.error(e)) }) } function Zn(t, n, e, i = 0, o = !1) { const r = n.schedule(function () { e(), o ? t.add(this.schedule(null, i)) : this.unsubscribe() }, i); if (t.add(r), !o) return r } function We(t, n, e = 1 / 0) { return ne(n) ? We((i, o) => X((r, s) => n(i, r, o, s))(dt(t(i, o))), e) : ("number" == typeof n && (e = n), Pe((i, o) => function JI(t, n, e, i, o, r, s, a) { const l = []; let c = 0, d = 0, u = !1; const h = () => { u && !l.length && !c && n.complete() }, f = m => c < i ? p(m) : l.push(m), p = m => { r && n.next(m), c++; let _ = !1; dt(e(m, d++)).subscribe(Ie(n, C => { o?.(C), r ? f(C) : n.next(C) }, () => { _ = !0 }, void 0, () => { if (_) try { for (c--; l.length && c < i;) { const C = l.shift(); s ? Zn(n, s, () => p(C)) : p(C) } h() } catch (C) { n.error(C) } })) }; return t.subscribe(Ie(n, f, () => { u = !0, h() })), () => { a?.() } }(i, o, t, e))) } function Ao(t = 1 / 0) { return We(pi, t) } const vn = new xe(t => t.complete()); function Ug(t) { return t && ne(t.schedule) } function pu(t) { return t[t.length - 1] } function zg(t) { return ne(pu(t)) ? t.pop() : void 0 } function is(t) { return Ug(pu(t)) ? t.pop() : void 0 } function $g(t, n = 0) { return Pe((e, i) => { e.subscribe(Ie(i, o => Zn(i, t, () => i.next(o), n), () => Zn(i, t, () => i.complete(), n), o => Zn(i, t, () => i.error(o), n))) }) } function Gg(t, n = 0) { return Pe((e, i) => { i.add(t.schedule(() => e.subscribe(i), n)) }) } function qg(t, n) { if (!t) throw new Error("Iterable cannot be null"); return new xe(e => { Zn(e, n, () => { const i = t[Symbol.asyncIterator](); Zn(e, n, () => { i.next().then(o => { o.done ? e.complete() : e.next(o.value) }) }, 0, !0) }) }) } function Ye(t, n) { return n ? function aA(t, n) { if (null != t) { if (Fg(t)) return function nA(t, n) { return dt(t).pipe(Gg(n), $g(n)) }(t, n); if (fu(t)) return function oA(t, n) { return new xe(e => { let i = 0; return n.schedule(function () { i === t.length ? e.complete() : (e.next(t[i++]), e.closed || this.schedule()) }) }) }(t, n); if (kg(t)) return function iA(t, n) { return dt(t).pipe(Gg(n), $g(n)) }(t, n); if (Pg(t)) return qg(t, n); if (Vg(t)) return function rA(t, n) { return new xe(e => { let i; return Zn(e, n, () => { i = t[Lg](), Zn(e, n, () => { let o, r; try { ({ value: o, done: r } = i.next()) } catch (s) { return void e.error(s) } r ? e.complete() : e.next(o) }, 0, !0) }), () => ne(i?.return) && i.return() }) }(t, n); if (jg(t)) return function sA(t, n) { return qg(Bg(t), n) }(t, n) } throw Ng(t) }(t, n) : dt(t) } function $i(...t) { const n = is(t), e = function tA(t, n) { return "number" == typeof pu(t) ? t.pop() : n }(t, 1 / 0), i = t; return i.length ? 1 === i.length ? dt(i[0]) : Ao(e)(Ye(i, n)) : vn } class At extends ie { constructor(n) { super(), this._value = n } get value() { return this.getValue() } _subscribe(n) { const e = super._subscribe(n); return !e.closed && n.next(this._value), e } getValue() { const { hasError: n, thrownError: e, _value: i } = this; if (n) throw e; return this._throwIfClosed(), i } next(n) { super.next(this._value = n) } } function N(...t) { return Ye(t, is(t)) } function ol(t = {}) { const { connector: n = (() => new ie), resetOnError: e = !0, resetOnComplete: i = !0, resetOnRefCountZero: o = !0 } = t; return r => { let s, a, l, c = 0, d = !1, u = !1; const h = () => { a?.unsubscribe(), a = void 0 }, f = () => { h(), s = l = void 0, d = u = !1 }, p = () => { const m = s; f(), m?.unsubscribe() }; return Pe((m, _) => { c++, !u && !d && h(); const C = l = l ?? n(); _.add(() => { c--, 0 === c && !u && !d && (a = mu(p, o)) }), C.subscribe(_), !s && c > 0 && (s = new ns({ next: v => C.next(v), error: v => { u = !0, h(), a = mu(f, e, v), C.error(v) }, complete: () => { d = !0, h(), a = mu(f, i), C.complete() } }), dt(m).subscribe(s)) })(r) } } function mu(t, n, ...e) { if (!0 === n) return void t(); if (!1 === n) return; const i = new ns({ next: () => { i.unsubscribe(), t() } }); return dt(n(...e)).subscribe(i) } function Tt(t, n) { return Pe((e, i) => { let o = null, r = 0, s = !1; const a = () => s && !o && i.complete(); e.subscribe(Ie(i, l => { o?.unsubscribe(); let c = 0; const d = r++; dt(t(l, d)).subscribe(o = Ie(i, u => i.next(n ? n(l, u, d, c++) : u), () => { o = null, a() })) }, () => { s = !0, a() })) }) } function Wg(t, n = pi) { return t = t ?? lA, Pe((e, i) => { let o, r = !0; e.subscribe(Ie(i, s => { const a = n(s); (r || !t(o, a)) && (r = !1, o = a, i.next(s)) })) }) } function lA(t, n) { return t === n } function me(t) { for (let n in t) if (t[n] === me) return n; throw Error("Could not find renamed property on target object.") } function rl(t, n) { for (const e in n) n.hasOwnProperty(e) && !t.hasOwnProperty(e) && (t[e] = n[e]) } function Ze(t) { if ("string" == typeof t) return t; if (Array.isArray(t)) return "[" + t.map(Ze).join(", ") + "]"; if (null == t) return "" + t; if (t.overriddenName) return `${t.overriddenName}`; if (t.name) return `${t.name}`; const n = t.toString(); if (null == n) return "" + n; const e = n.indexOf("\n"); return -1 === e ? n : n.substring(0, e) } function gu(t, n) { return null == t || "" === t ? null === n ? "" : n : null == n || "" === n ? t : t + " " + n } const cA = me({ __forward_ref__: me }); function be(t) { return t.__forward_ref__ = be, t.toString = function () { return Ze(this()) }, t } function H(t) { return _u(t) ? t() : t } function _u(t) { return "function" == typeof t && t.hasOwnProperty(cA) && t.__forward_ref__ === be } function vu(t) { return t && !!t.\u0275providers } const Yg = "https://g.co/ng/security#xss"; class b extends Error { constructor(n, e) { super(function sl(t, n) { return `NG0${Math.abs(t)}${n ? ": " + n : ""}` }(n, e)), this.code = n } } function G(t) { return "string" == typeof t ? t : null == t ? "" : String(t) } function bu(t, n) { throw new b(-201, !1) } function tn(t, n) { null == t && function B(t, n, e, i) { throw new Error(`ASSERTION ERROR: ${t}` + (null == i ? "" : ` [Expected=> ${e} ${i} ${n} <=Actual]`)) }(n, t, null, "!=") } function I(t) { return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 } } function ae(t) { return { providers: t.providers || [], imports: t.imports || [] } } function al(t) { return Zg(t, cl) || Zg(t, Xg) } function Zg(t, n) { return t.hasOwnProperty(n) ? t[n] : null } function ll(t) { return t && (t.hasOwnProperty(yu) || t.hasOwnProperty(_A)) ? t[yu] : null } const cl = me({ \u0275prov: me }), yu = me({ \u0275inj: me }), Xg = me({ ngInjectableDef: me }), _A = me({ ngInjectorDef: me }); var J = function (t) { return t[t.Default = 0] = "Default", t[t.Host = 1] = "Host", t[t.Self = 2] = "Self", t[t.SkipSelf = 4] = "SkipSelf", t[t.Optional = 8] = "Optional", t }(J || {}); let wu; function Rt(t) { const n = wu; return wu = t, n } function Qg(t, n, e) { const i = al(t); return i && "root" == i.providedIn ? void 0 === i.value ? i.value = i.factory() : i.value : e & J.Optional ? null : void 0 !== n ? n : void bu(Ze(t)) } const Ce = globalThis; class E { constructor(n, e) { this._desc = n, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.\u0275prov = I({ token: this, providedIn: e.providedIn || "root", factory: e.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } const os = {}, Su = "__NG_DI_FLAG__", dl = "ngTempTokenPath", yA = /\n/gm, e_ = "__source"; let To; function gi(t) { const n = To; return To = t, n } function CA(t, n = J.Default) { if (void 0 === To) throw new b(-203, !1); return null === To ? Qg(t, void 0, n) : To.get(t, n & J.Optional ? null : void 0, n) } function w(t, n = J.Default) { return (function Kg() { return wu }() || CA)(H(t), n) } function T(t, n = J.Default) { return w(t, ul(n)) } function ul(t) { return typeof t > "u" || "number" == typeof t ? t : 0 | (t.optional && 8) | (t.host && 1) | (t.self && 2) | (t.skipSelf && 4) } function Mu(t) { const n = []; for (let e = 0; e < t.length; e++) { const i = H(t[e]); if (Array.isArray(i)) { if (0 === i.length) throw new b(900, !1); let o, r = J.Default; for (let s = 0; s < i.length; s++) { const a = i[s], l = DA(a); "number" == typeof l ? -1 === l ? o = a.token : r |= l : o = a } n.push(w(o, r)) } else n.push(w(i)) } return n } function rs(t, n) { return t[Su] = n, t.prototype[Su] = n, t } function DA(t) { return t[Su] } function Xn(t) { return { toString: t }.toString() } var hl = function (t) { return t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default", t }(hl || {}), nn = function (t) { return t[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom", t }(nn || {}); const An = {}, ce = [], fl = me({ \u0275cmp: me }), Iu = me({ \u0275dir: me }), Au = me({ \u0275pipe: me }), n_ = me({ \u0275mod: me }), Kn = me({ \u0275fac: me }), ss = me({ __NG_ELEMENT_ID__: me }), i_ = me({ __NG_ENV_ID__: me }); function o_(t, n, e) { let i = t.length; for (; ;) { const o = t.indexOf(n, e); if (-1 === o) return o; if (0 === o || t.charCodeAt(o - 1) <= 32) { const r = n.length; if (o + r === i || t.charCodeAt(o + r) <= 32) return o } e = o + 1 } } function Tu(t, n, e) { let i = 0; for (; i < e.length;) { const o = e[i]; if ("number" == typeof o) { if (0 !== o) break; i++; const r = e[i++], s = e[i++], a = e[i++]; t.setAttribute(n, s, a, r) } else { const r = o, s = e[++i]; s_(r) ? t.setProperty(n, r, s) : t.setAttribute(n, r, s), i++ } } return i } function r_(t) { return 3 === t || 4 === t || 6 === t } function s_(t) { return 64 === t.charCodeAt(0) } function as(t, n) { if (null !== n && 0 !== n.length) if (null === t || 0 === t.length) t = n.slice(); else { let e = -1; for (let i = 0; i < n.length; i++) { const o = n[i]; "number" == typeof o ? e = o : 0 === e || a_(t, e, o, null, -1 === e || 2 === e ? n[++i] : null) } } return t } function a_(t, n, e, i, o) { let r = 0, s = t.length; if (-1 === n) s = -1; else for (; r < t.length;) { const a = t[r++]; if ("number" == typeof a) { if (a === n) { s = -1; break } if (a > n) { s = r - 1; break } } } for (; r < t.length;) { const a = t[r]; if ("number" == typeof a) break; if (a === e) { if (null === i) return void (null !== o && (t[r + 1] = o)); if (i === t[r + 1]) return void (t[r + 2] = o) } r++, null !== i && r++, null !== o && r++ } -1 !== s && (t.splice(s, 0, n), r = s + 1), t.splice(r++, 0, e), null !== i && t.splice(r++, 0, i), null !== o && t.splice(r++, 0, o) } const l_ = "ng-template"; function MA(t, n, e) { let i = 0, o = !0; for (; i < t.length;) { let r = t[i++]; if ("string" == typeof r && o) { const s = t[i++]; if (e && "class" === r && -1 !== o_(s.toLowerCase(), n, 0)) return !0 } else { if (1 === r) { for (; i < t.length && "string" == typeof (r = t[i++]);)if (r.toLowerCase() === n) return !0; return !1 } "number" == typeof r && (o = !1) } } return !1 } function c_(t) { return 4 === t.type && t.value !== l_ } function IA(t, n, e) { return n === (4 !== t.type || e ? t.value : l_) } function AA(t, n, e) { let i = 4; const o = t.attrs || [], r = function OA(t) { for (let n = 0; n < t.length; n++)if (r_(t[n])) return n; return t.length }(o); let s = !1; for (let a = 0; a < n.length; a++) { const l = n[a]; if ("number" != typeof l) { if (!s) if (4 & i) { if (i = 2 | 1 & i, "" !== l && !IA(t, l, e) || "" === l && 1 === n.length) { if (bn(i)) return !1; s = !0 } } else { const c = 8 & i ? l : n[++a]; if (8 & i && null !== t.attrs) { if (!MA(t.attrs, c, e)) { if (bn(i)) return !1; s = !0 } continue } const u = TA(8 & i ? "class" : l, o, c_(t), e); if (-1 === u) { if (bn(i)) return !1; s = !0; continue } if ("" !== c) { let h; h = u > r ? "" : o[u + 1].toLowerCase(); const f = 8 & i ? h : null; if (f && -1 !== o_(f, c, 0) || 2 & i && c !== h) { if (bn(i)) return !1; s = !0 } } } } else { if (!s && !bn(i) && !bn(l)) return !1; if (s && bn(l)) continue; s = !1, i = l | 1 & i } } return bn(i) || s } function bn(t) { return 0 == (1 & t) } function TA(t, n, e, i) { if (null === n) return -1; let o = 0; if (i || !e) { let r = !1; for (; o < n.length;) { const s = n[o]; if (s === t) return o; if (3 === s || 6 === s) r = !0; else { if (1 === s || 2 === s) { let a = n[++o]; for (; "string" == typeof a;)a = n[++o]; continue } if (4 === s) break; if (0 === s) { o += 4; continue } } o += r ? 1 : 2 } return -1 } return function kA(t, n) { let e = t.indexOf(4); if (e > -1) for (e++; e < t.length;) { const i = t[e]; if ("number" == typeof i) return -1; if (i === n) return e; e++ } return -1 }(n, t) } function d_(t, n, e = !1) { for (let i = 0; i < n.length; i++)if (AA(t, n[i], e)) return !0; return !1 } function FA(t, n) { e: for (let e = 0; e < n.length; e++) { const i = n[e]; if (t.length === i.length) { for (let o = 0; o < t.length; o++)if (t[o] !== i[o]) continue e; return !0 } } return !1 } function u_(t, n) { return t ? ":not(" + n.trim() + ")" : n } function PA(t) { let n = t[0], e = 1, i = 2, o = "", r = !1; for (; e < t.length;) { let s = t[e]; if ("string" == typeof s) if (2 & i) { const a = t[++e]; o += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & i ? o += "." + s : 4 & i && (o += " " + s); else "" !== o && !bn(s) && (n += u_(r, o), o = ""), i = s, r = r || !bn(i); e++ } return "" !== o && (n += u_(r, o)), n } function tt(t) { return Xn(() => { const n = f_(t), e = { ...n, decls: t.decls, vars: t.vars, template: t.template, consts: t.consts || null, ngContentSelectors: t.ngContentSelectors, onPush: t.changeDetection === hl.OnPush, directiveDefs: null, pipeDefs: null, dependencies: n.standalone && t.dependencies || null, getStandaloneInjector: null, signals: t.signals ?? !1, data: t.data || {}, encapsulation: t.encapsulation || nn.Emulated, styles: t.styles || ce, _: null, schemas: t.schemas || null, tView: null, id: "" }; p_(e); const i = t.dependencies; return e.directiveDefs = pl(i, !1), e.pipeDefs = pl(i, !0), e.id = function zA(t) { let n = 0; const e = [t.selectors, t.ngContentSelectors, t.hostVars, t.hostAttrs, t.consts, t.vars, t.decls, t.encapsulation, t.standalone, t.signals, t.exportAs, JSON.stringify(t.inputs), JSON.stringify(t.outputs), Object.getOwnPropertyNames(t.type.prototype), !!t.contentQueries, !!t.viewQuery].join("|"); for (const o of e) n = Math.imul(31, n) + o.charCodeAt(0) << 0; return n += 2147483648, "c" + n }(e), e }) } function BA(t) { return oe(t) || nt(t) } function jA(t) { return null !== t } function de(t) { return Xn(() => ({ type: t.type, bootstrap: t.bootstrap || ce, declarations: t.declarations || ce, imports: t.imports || ce, exports: t.exports || ce, transitiveCompileScopes: null, schemas: t.schemas || null, id: t.id || null })) } function h_(t, n) { if (null == t) return An; const e = {}; for (const i in t) if (t.hasOwnProperty(i)) { let o = t[i], r = o; Array.isArray(o) && (r = o[1], o = o[0]), e[o] = i, n && (n[o] = r) } return e } function P(t) { return Xn(() => { const n = f_(t); return p_(n), n }) } function oe(t) { return t[fl] || null } function nt(t) { return t[Iu] || null } function vt(t) { return t[Au] || null } function zt(t, n) { const e = t[n_] || null; if (!e && !0 === n) throw new Error(`Type ${Ze(t)} does not have '\u0275mod' property.`); return e } function f_(t) { const n = {}; return { type: t.type, providersResolver: null, factory: null, hostBindings: t.hostBindings || null, hostVars: t.hostVars || 0, hostAttrs: t.hostAttrs || null, contentQueries: t.contentQueries || null, declaredInputs: n, inputTransforms: null, inputConfig: t.inputs || An, exportAs: t.exportAs || null, standalone: !0 === t.standalone, signals: !0 === t.signals, selectors: t.selectors || ce, viewQuery: t.viewQuery || null, features: t.features || null, setInput: null, findHostDirectiveDefs: null, hostDirectives: null, inputs: h_(t.inputs, n), outputs: h_(t.outputs) } } function p_(t) { t.features?.forEach(n => n(t)) } function pl(t, n) { if (!t) return null; const e = n ? vt : BA; return () => ("function" == typeof t ? t() : t).map(i => e(i)).filter(jA) } const Ne = 0, R = 1, Y = 2, Ae = 3, yn = 4, ls = 5, ut = 6, Oo = 7, Be = 8, _i = 9, ko = 10, q = 11, cs = 12, m_ = 13, Fo = 14, je = 15, ds = 16, Po = 17, Tn = 18, us = 19, g_ = 20, vi = 21, Qn = 22, hs = 23, fs = 24, ee = 25, Ru = 1, __ = 2, Rn = 7, No = 9, it = 11; function kt(t) { return Array.isArray(t) && "object" == typeof t[Ru] } function bt(t) { return Array.isArray(t) && !0 === t[Ru] } function Ou(t) { return 0 != (4 & t.flags) } function qi(t) { return t.componentOffset > -1 } function gl(t) { return 1 == (1 & t.flags) } function wn(t) { return !!t.template } function ku(t) { return 0 != (512 & t[Y]) } function Wi(t, n) { return t.hasOwnProperty(Kn) ? t[Kn] : null } let ot = null, _l = !1; function on(t) { const n = ot; return ot = t, n } const y_ = { version: 0, dirty: !1, producerNode: void 0, producerLastReadVersion: void 0, producerIndexOfThis: void 0, nextProducerIndex: 0, liveConsumerNode: void 0, liveConsumerIndexOfThis: void 0, consumerAllowSignalWrites: !1, consumerIsAlwaysLive: !1, producerMustRecompute: () => !1, producerRecomputeValue: () => { }, consumerMarkedDirty: () => { } }; function x_(t) { if (!ms(t) || t.dirty) { if (!t.producerMustRecompute(t) && !E_(t)) return void (t.dirty = !1); t.producerRecomputeValue(t), t.dirty = !1 } } function D_(t) { t.dirty = !0, function C_(t) { if (void 0 === t.liveConsumerNode) return; const n = _l; _l = !0; try { for (const e of t.liveConsumerNode) e.dirty || D_(e) } finally { _l = n } }(t), t.consumerMarkedDirty?.(t) } function Pu(t) { return t && (t.nextProducerIndex = 0), on(t) } function Nu(t, n) { if (on(n), t && void 0 !== t.producerNode && void 0 !== t.producerIndexOfThis && void 0 !== t.producerLastReadVersion) { if (ms(t)) for (let e = t.nextProducerIndex; e < t.producerNode.length; e++)vl(t.producerNode[e], t.producerIndexOfThis[e]); for (; t.producerNode.length > t.nextProducerIndex;)t.producerNode.pop(), t.producerLastReadVersion.pop(), t.producerIndexOfThis.pop() } } function E_(t) { Lo(t); for (let n = 0; n < t.producerNode.length; n++) { const e = t.producerNode[n], i = t.producerLastReadVersion[n]; if (i !== e.version || (x_(e), i !== e.version)) return !0 } return !1 } function S_(t) { if (Lo(t), ms(t)) for (let n = 0; n < t.producerNode.length; n++)vl(t.producerNode[n], t.producerIndexOfThis[n]); t.producerNode.length = t.producerLastReadVersion.length = t.producerIndexOfThis.length = 0, t.liveConsumerNode && (t.liveConsumerNode.length = t.liveConsumerIndexOfThis.length = 0) } function vl(t, n) { if (function I_(t) { t.liveConsumerNode ??= [], t.liveConsumerIndexOfThis ??= [] }(t), Lo(t), 1 === t.liveConsumerNode.length) for (let i = 0; i < t.producerNode.length; i++)vl(t.producerNode[i], t.producerIndexOfThis[i]); const e = t.liveConsumerNode.length - 1; if (t.liveConsumerNode[n] = t.liveConsumerNode[e], t.liveConsumerIndexOfThis[n] = t.liveConsumerIndexOfThis[e], t.liveConsumerNode.length--, t.liveConsumerIndexOfThis.length--, n < t.liveConsumerNode.length) { const i = t.liveConsumerIndexOfThis[n], o = t.liveConsumerNode[n]; Lo(o), o.producerIndexOfThis[i] = n } } function ms(t) { return t.consumerIsAlwaysLive || (t?.liveConsumerNode?.length ?? 0) > 0 } function Lo(t) { t.producerNode ??= [], t.producerIndexOfThis ??= [], t.producerLastReadVersion ??= [] } let A_ = null; const k_ = () => { }, nT = (() => ({ ...y_, consumerIsAlwaysLive: !0, consumerAllowSignalWrites: !1, consumerMarkedDirty: t => { t.schedule(t.ref) }, hasRun: !1, cleanupFn: k_ }))(); class iT { constructor(n, e, i) { this.previousValue = n, this.currentValue = e, this.firstChange = i } isFirstChange() { return this.firstChange } } function Ft() { return F_ } function F_(t) { return t.type.prototype.ngOnChanges && (t.setInput = rT), oT } function oT() { const t = N_(this), n = t?.current; if (n) { const e = t.previous; if (e === An) t.previous = n; else for (let i in n) e[i] = n[i]; t.current = null, this.ngOnChanges(n) } } function rT(t, n, e, i) { const o = this.declaredInputs[e], r = N_(t) || function sT(t, n) { return t[P_] = n }(t, { previous: An, current: null }), s = r.current || (r.current = {}), a = r.previous, l = a[o]; s[o] = new iT(l && l.currentValue, n, a === An), t[i] = n } Ft.ngInherit = !0; const P_ = "__ngSimpleChanges__"; function N_(t) { return t[P_] || null } const On = function (t, n, e) { }; function De(t) { for (; Array.isArray(t);)t = t[Ne]; return t } function bl(t, n) { return De(n[t]) } function Pt(t, n) { return De(n[t.index]) } function B_(t, n) { return t.data[n] } function $t(t, n) { const e = n[t]; return kt(e) ? e : e[Ne] } function yi(t, n) { return null == n ? null : t[n] } function j_(t) { t[Po] = 0 } function hT(t) { 1024 & t[Y] || (t[Y] |= 1024, U_(t, 1)) } function H_(t) { 1024 & t[Y] && (t[Y] &= -1025, U_(t, -1)) } function U_(t, n) { let e = t[Ae]; if (null === e) return; e[ls] += n; let i = e; for (e = e[Ae]; null !== e && (1 === n && 1 === i[ls] || -1 === n && 0 === i[ls]);)e[ls] += n, i = e, e = e[Ae] } const j = { lFrame: J_(null), bindingsEnabled: !0, skipHydrationRootTNode: null }; function G_() { return j.bindingsEnabled } function Bo() { return null !== j.skipHydrationRootTNode } function D() { return j.lFrame.lView } function re() { return j.lFrame.tView } function gs(t) { return j.lFrame.contextLView = t, t[Be] } function _s(t) { return j.lFrame.contextLView = null, t } function rt() { let t = q_(); for (; null !== t && 64 === t.type;)t = t.parent; return t } function q_() { return j.lFrame.currentTNode } function kn(t, n) { const e = j.lFrame; e.currentTNode = t, e.isParent = n } function Hu() { return j.lFrame.isParent } function Uu() { j.lFrame.isParent = !1 } function jo() { return j.lFrame.bindingIndex++ } function ei(t) { const n = j.lFrame, e = n.bindingIndex; return n.bindingIndex = n.bindingIndex + t, e } function DT(t, n) { const e = j.lFrame; e.bindingIndex = e.bindingRootIndex = t, zu(n) } function zu(t) { j.lFrame.currentDirectiveIndex = t } function X_() { return j.lFrame.currentQueryIndex } function Gu(t) { j.lFrame.currentQueryIndex = t } function ST(t) { const n = t[R]; return 2 === n.type ? n.declTNode : 1 === n.type ? t[ut] : null } function K_(t, n, e) { if (e & J.SkipSelf) { let o = n, r = t; for (; !(o = o.parent, null !== o || e & J.Host || (o = ST(r), null === o || (r = r[Fo], 10 & o.type)));); if (null === o) return !1; n = o, t = r } const i = j.lFrame = Q_(); return i.currentTNode = n, i.lView = t, !0 } function qu(t) { const n = Q_(), e = t[R]; j.lFrame = n, n.currentTNode = e.firstChild, n.lView = t, n.tView = e, n.contextLView = t, n.bindingIndex = e.bindingStartIndex, n.inI18n = !1 } function Q_() { const t = j.lFrame, n = null === t ? null : t.child; return null === n ? J_(t) : n } function J_(t) { const n = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: t, child: null, inI18n: !1 }; return null !== t && (t.child = n), n } function ev() { const t = j.lFrame; return j.lFrame = t.parent, t.currentTNode = null, t.lView = null, t } const tv = ev; function Wu() { const t = ev(); t.isParent = !0, t.tView = null, t.selectedIndex = -1, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0 } function wt() { return j.lFrame.selectedIndex } function Yi(t) { j.lFrame.selectedIndex = t } function Te() { const t = j.lFrame; return B_(t.tView, t.selectedIndex) } let iv = !0; function yl() { return iv } function wi(t) { iv = t } function wl(t, n) { for (let e = n.directiveStart, i = n.directiveEnd; e < i; e++) { const r = t.data[e].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: l, ngAfterViewChecked: c, ngOnDestroy: d } = r; s && (t.contentHooks ??= []).push(-e, s), a && ((t.contentHooks ??= []).push(e, a), (t.contentCheckHooks ??= []).push(e, a)), l && (t.viewHooks ??= []).push(-e, l), c && ((t.viewHooks ??= []).push(e, c), (t.viewCheckHooks ??= []).push(e, c)), null != d && (t.destroyHooks ??= []).push(e, d) } } function xl(t, n, e) { ov(t, n, 3, e) } function Cl(t, n, e, i) { (3 & t[Y]) === e && ov(t, n, e, i) } function Yu(t, n) { let e = t[Y]; (3 & e) === n && (e &= 8191, e += 1, t[Y] = e) } function ov(t, n, e, i) { const r = i ?? -1, s = n.length - 1; let a = 0; for (let l = void 0 !== i ? 65535 & t[Po] : 0; l < s; l++)if ("number" == typeof n[l + 1]) { if (a = n[l], null != i && a >= i) break } else n[l] < 0 && (t[Po] += 65536), (a < r || -1 == r) && (FT(t, e, n, l), t[Po] = (4294901760 & t[Po]) + l + 2), l++ } function rv(t, n) { On(4, t, n); const e = on(null); try { n.call(t) } finally { on(e), On(5, t, n) } } function FT(t, n, e, i) { const o = e[i] < 0, r = e[i + 1], a = t[o ? -e[i] : e[i]]; o ? t[Y] >> 13 < t[Po] >> 16 && (3 & t[Y]) === n && (t[Y] += 8192, rv(a, r)) : rv(a, r) } const Ho = -1; class bs { constructor(n, e, i) { this.factory = n, this.resolving = !1, this.canSeeViewProviders = e, this.injectImpl = i } } function Xu(t) { return t !== Ho } function ys(t) { return 32767 & t } function ws(t, n) { let e = function VT(t) { return t >> 16 }(t), i = n; for (; e > 0;)i = i[Fo], e--; return i } let Ku = !0; function Dl(t) { const n = Ku; return Ku = t, n } const sv = 255, av = 5; let BT = 0; const Fn = {}; function El(t, n) { const e = lv(t, n); if (-1 !== e) return e; const i = n[R]; i.firstCreatePass && (t.injectorIndex = n.length, Qu(i.data, t), Qu(n, null), Qu(i.blueprint, null)); const o = Sl(t, n), r = t.injectorIndex; if (Xu(o)) { const s = ys(o), a = ws(o, n), l = a[R].data; for (let c = 0; c < 8; c++)n[r + c] = a[s + c] | l[s + c] } return n[r + 8] = o, r } function Qu(t, n) { t.push(0, 0, 0, 0, 0, 0, 0, 0, n) } function lv(t, n) { return -1 === t.injectorIndex || t.parent && t.parent.injectorIndex === t.injectorIndex || null === n[t.injectorIndex + 8] ? -1 : t.injectorIndex } function Sl(t, n) { if (t.parent && -1 !== t.parent.injectorIndex) return t.parent.injectorIndex; let e = 0, i = null, o = n; for (; null !== o;) { if (i = mv(o), null === i) return Ho; if (e++, o = o[Fo], -1 !== i.injectorIndex) return i.injectorIndex | e << 16 } return Ho } function Ju(t, n, e) { !function jT(t, n, e) { let i; "string" == typeof e ? i = e.charCodeAt(0) || 0 : e.hasOwnProperty(ss) && (i = e[ss]), null == i && (i = e[ss] = BT++); const o = i & sv; n.data[t + (o >> av)] |= 1 << o }(t, n, e) } function cv(t, n, e) { if (e & J.Optional || void 0 !== t) return t; bu() } function dv(t, n, e, i) { if (e & J.Optional && void 0 === i && (i = null), !(e & (J.Self | J.Host))) { const o = t[_i], r = Rt(void 0); try { return o ? o.get(n, i, e & J.Optional) : Qg(n, i, e & J.Optional) } finally { Rt(r) } } return cv(i, 0, e) } function uv(t, n, e, i = J.Default, o) { if (null !== t) { if (2048 & n[Y] && !(i & J.Self)) { const s = function qT(t, n, e, i, o) { let r = t, s = n; for (; null !== r && null !== s && 2048 & s[Y] && !(512 & s[Y]);) { const a = hv(r, s, e, i | J.Self, Fn); if (a !== Fn) return a; let l = r.parent; if (!l) { const c = s[g_]; if (c) { const d = c.get(e, Fn, i); if (d !== Fn) return d } l = mv(s), s = s[Fo] } r = l } return o }(t, n, e, i, Fn); if (s !== Fn) return s } const r = hv(t, n, e, i, Fn); if (r !== Fn) return r } return dv(n, e, i, o) } function hv(t, n, e, i, o) { const r = function zT(t) { if ("string" == typeof t) return t.charCodeAt(0) || 0; const n = t.hasOwnProperty(ss) ? t[ss] : void 0; return "number" == typeof n ? n >= 0 ? n & sv : GT : n }(e); if ("function" == typeof r) { if (!K_(n, t, i)) return i & J.Host ? cv(o, 0, i) : dv(n, e, i, o); try { let s; if (s = r(i), null != s || i & J.Optional) return s; bu() } finally { tv() } } else if ("number" == typeof r) { let s = null, a = lv(t, n), l = Ho, c = i & J.Host ? n[je][ut] : null; for ((-1 === a || i & J.SkipSelf) && (l = -1 === a ? Sl(t, n) : n[a + 8], l !== Ho && pv(i, !1) ? (s = n[R], a = ys(l), n = ws(l, n)) : a = -1); -1 !== a;) { const d = n[R]; if (fv(r, a, d.data)) { const u = UT(a, n, e, s, i, c); if (u !== Fn) return u } l = n[a + 8], l !== Ho && pv(i, n[R].data[a + 8] === c) && fv(r, a, n) ? (s = d, a = ys(l), n = ws(l, n)) : a = -1 } } return o } function UT(t, n, e, i, o, r) { const s = n[R], a = s.data[t + 8], d = Ml(a, s, e, null == i ? qi(a) && Ku : i != s && 0 != (3 & a.type), o & J.Host && r === a); return null !== d ? Zi(n, s, d, a) : Fn } function Ml(t, n, e, i, o) { const r = t.providerIndexes, s = n.data, a = 1048575 & r, l = t.directiveStart, d = r >> 20, h = o ? a + d : t.directiveEnd; for (let f = i ? a : a + d; f < h; f++) { const p = s[f]; if (f < l && e === p || f >= l && p.type === e) return f } if (o) { const f = s[l]; if (f && wn(f) && f.type === e) return l } return null } function Zi(t, n, e, i) { let o = t[e]; const r = n.data; if (function PT(t) { return t instanceof bs }(o)) { const s = o; s.resolving && function dA(t, n) { const e = n ? `. Dependency path: ${n.join(" > ")} > ${t}` : ""; throw new b(-200, `Circular dependency in DI detected for ${t}${e}`) }(function pe(t) { return "function" == typeof t ? t.name || t.toString() : "object" == typeof t && null != t && "function" == typeof t.type ? t.type.name || t.type.toString() : G(t) }(r[e])); const a = Dl(s.canSeeViewProviders); s.resolving = !0; const c = s.injectImpl ? Rt(s.injectImpl) : null; K_(t, i, J.Default); try { o = t[e] = s.factory(void 0, r, t, i), n.firstCreatePass && e >= i.directiveStart && function kT(t, n, e) { const { ngOnChanges: i, ngOnInit: o, ngDoCheck: r } = n.type.prototype; if (i) { const s = F_(n); (e.preOrderHooks ??= []).push(t, s), (e.preOrderCheckHooks ??= []).push(t, s) } o && (e.preOrderHooks ??= []).push(0 - t, o), r && ((e.preOrderHooks ??= []).push(t, r), (e.preOrderCheckHooks ??= []).push(t, r)) }(e, r[e], n) } finally { null !== c && Rt(c), Dl(a), s.resolving = !1, tv() } } return o } function fv(t, n, e) { return !!(e[n + (t >> av)] & 1 << t) } function pv(t, n) { return !(t & J.Self || t & J.Host && n) } class xt { constructor(n, e) { this._tNode = n, this._lView = e } get(n, e, i) { return uv(this._tNode, this._lView, n, ul(i), e) } } function GT() { return new xt(rt(), D()) } function ze(t) { return Xn(() => { const n = t.prototype.constructor, e = n[Kn] || eh(n), i = Object.prototype; let o = Object.getPrototypeOf(t.prototype).constructor; for (; o && o !== i;) { const r = o[Kn] || eh(o); if (r && r !== e) return r; o = Object.getPrototypeOf(o) } return r => new r }) } function eh(t) { return _u(t) ? () => { const n = eh(H(t)); return n && n() } : Wi(t) } function mv(t) { const n = t[R], e = n.type; return 2 === e ? n.declTNode : 1 === e ? t[ut] : null } function Uo(t) { return function HT(t, n) { if ("class" === n) return t.classes; if ("style" === n) return t.styles; const e = t.attrs; if (e) { const i = e.length; let o = 0; for (; o < i;) { const r = e[o]; if (r_(r)) break; if (0 === r) o += 2; else if ("number" == typeof r) for (o++; o < i && "string" == typeof e[o];)o++; else { if (r === n) return e[o + 1]; o += 2 } } } return null }(rt(), t) } const $o = "__parameters__"; function qo(t, n, e) { return Xn(() => { const i = function th(t) { return function (...e) { if (t) { const i = t(...e); for (const o in i) this[o] = i[o] } } }(n); function o(...r) { if (this instanceof o) return i.apply(this, r), this; const s = new o(...r); return a.annotation = s, a; function a(l, c, d) { const u = l.hasOwnProperty($o) ? l[$o] : Object.defineProperty(l, $o, { value: [] })[$o]; for (; u.length <= d;)u.push(null); return (u[d] = u[d] || []).push(s), l } } return e && (o.prototype = Object.create(e.prototype)), o.prototype.ngMetadataName = t, o.annotationCls = o, o }) } function Yo(t, n) { t.forEach(e => Array.isArray(e) ? Yo(e, n) : n(e)) } function _v(t, n, e) { n >= t.length ? t.push(e) : t.splice(n, 0, e) } function Il(t, n) { return n >= t.length - 1 ? t.pop() : t.splice(n, 1)[0] } function Ds(t, n) { const e = []; for (let i = 0; i < t; i++)e.push(n); return e } function Gt(t, n, e) { let i = Zo(t, n); return i >= 0 ? t[1 | i] = e : (i = ~i, function JT(t, n, e, i) { let o = t.length; if (o == n) t.push(e, i); else if (1 === o) t.push(i, t[0]), t[0] = e; else { for (o--, t.push(t[o - 1], t[o]); o > n;)t[o] = t[o - 2], o--; t[n] = e, t[n + 1] = i } }(t, i, n, e)), i } function nh(t, n) { const e = Zo(t, n); if (e >= 0) return t[1 | e] } function Zo(t, n) { return function vv(t, n, e) { let i = 0, o = t.length >> e; for (; o !== i;) { const r = i + (o - i >> 1), s = t[r << e]; if (n === s) return r << e; s > n ? o = r : i = r + 1 } return ~(o << e) }(t, n, 1) } const Xi = rs(qo("Optional"), 8), Es = rs(qo("SkipSelf"), 4); function Fl(t) { return 128 == (128 & t.flags) } var xi = function (t) { return t[t.Important = 1] = "Important", t[t.DashCase = 2] = "DashCase", t }(xi || {}); const ah = new Map; let CR = 0; const ch = "__ngContext__"; function ht(t, n) { kt(n) ? (t[ch] = n[us], function ER(t) { ah.set(t[us], t) }(n)) : t[ch] = n } let dh; function uh(t, n) { return dh(t, n) } function Is(t) { const n = t[Ae]; return bt(n) ? n[Ae] : n } function Vv(t) { return jv(t[cs]) } function Bv(t) { return jv(t[yn]) } function jv(t) { for (; null !== t && !bt(t);)t = t[yn]; return t } function Qo(t, n, e, i, o) { if (null != i) { let r, s = !1; bt(i) ? r = i : kt(i) && (s = !0, i = i[Ne]); const a = De(i); 0 === t && null !== e ? null == o ? $v(n, e, a) : Ki(n, e, a, o || null, !0) : 1 === t && null !== e ? Ki(n, e, a, o || null, !0) : 2 === t ? function Hl(t, n, e) { const i = Bl(t, n); i && function $R(t, n, e, i) { t.removeChild(n, e, i) }(t, i, n, e) }(n, a, s) : 3 === t && n.destroyNode(a), null != r && function WR(t, n, e, i, o) { const r = e[Rn]; r !== De(e) && Qo(n, t, i, r, o); for (let a = it; a < e.length; a++) { const l = e[a]; Ts(l[R], l, t, n, i, r) } }(n, t, r, e, o) } } function Ll(t, n, e) { return t.createElement(n, e) } function Uv(t, n) { const e = t[No], i = e.indexOf(n); H_(n), e.splice(i, 1) } function Vl(t, n) { if (t.length <= it) return; const e = it + n, i = t[e]; if (i) { const o = i[ds]; null !== o && o !== t && Uv(o, i), n > 0 && (t[e - 1][yn] = i[yn]); const r = Il(t, it + n); !function NR(t, n) { Ts(t, n, n[q], 2, null, null), n[Ne] = null, n[ut] = null }(i[R], i); const s = r[Tn]; null !== s && s.detachView(r[R]), i[Ae] = null, i[yn] = null, i[Y] &= -129 } return i } function fh(t, n) { if (!(256 & n[Y])) { const e = n[q]; n[hs] && S_(n[hs]), n[fs] && S_(n[fs]), e.destroyNode && Ts(t, n, e, 3, null, null), function BR(t) { let n = t[cs]; if (!n) return ph(t[R], t); for (; n;) { let e = null; if (kt(n)) e = n[cs]; else { const i = n[it]; i && (e = i) } if (!e) { for (; n && !n[yn] && n !== t;)kt(n) && ph(n[R], n), n = n[Ae]; null === n && (n = t), kt(n) && ph(n[R], n), e = n && n[yn] } n = e } }(n) } } function ph(t, n) { if (!(256 & n[Y])) { n[Y] &= -129, n[Y] |= 256, function zR(t, n) { let e; if (null != t && null != (e = t.destroyHooks)) for (let i = 0; i < e.length; i += 2) { const o = n[e[i]]; if (!(o instanceof bs)) { const r = e[i + 1]; if (Array.isArray(r)) for (let s = 0; s < r.length; s += 2) { const a = o[r[s]], l = r[s + 1]; On(4, a, l); try { l.call(a) } finally { On(5, a, l) } } else { On(4, o, r); try { r.call(o) } finally { On(5, o, r) } } } } }(t, n), function UR(t, n) { const e = t.cleanup, i = n[Oo]; if (null !== e) for (let r = 0; r < e.length - 1; r += 2)if ("string" == typeof e[r]) { const s = e[r + 3]; s >= 0 ? i[s]() : i[-s].unsubscribe(), r += 2 } else e[r].call(i[e[r + 1]]); null !== i && (n[Oo] = null); const o = n[vi]; if (null !== o) { n[vi] = null; for (let r = 0; r < o.length; r++)(0, o[r])() } }(t, n), 1 === n[R].type && n[q].destroy(); const e = n[ds]; if (null !== e && bt(n[Ae])) { e !== n[Ae] && Uv(e, n); const i = n[Tn]; null !== i && i.detachView(t) } !function SR(t) { ah.delete(t[us]) }(n) } } function mh(t, n, e) { return function zv(t, n, e) { let i = n; for (; null !== i && 40 & i.type;)i = (n = i).parent; if (null === i) return e[Ne]; { const { componentOffset: o } = i; if (o > -1) { const { encapsulation: r } = t.data[i.directiveStart + o]; if (r === nn.None || r === nn.Emulated) return null } return Pt(i, e) } }(t, n.parent, e) } function Ki(t, n, e, i, o) { t.insertBefore(n, e, i, o) } function $v(t, n, e) { t.appendChild(n, e) } function Gv(t, n, e, i, o) { null !== i ? Ki(t, n, e, i, o) : $v(t, n, e) } function Bl(t, n) { return t.parentNode(n) } function qv(t, n, e) { return Yv(t, n, e) } let gh, Ul, yh, zl, Yv = function Wv(t, n, e) { return 40 & t.type ? Pt(t, e) : null }; function jl(t, n, e, i) { const o = mh(t, i, n), r = n[q], a = qv(i.parent || n[ut], i, n); if (null != o) if (Array.isArray(e)) for (let l = 0; l < e.length; l++)Gv(r, o, e[l], a, !1); else Gv(r, o, e, a, !1); void 0 !== gh && gh(r, i, n, e, o) } function As(t, n) { if (null !== n) { const e = n.type; if (3 & e) return Pt(n, t); if (4 & e) return _h(-1, t[n.index]); if (8 & e) { const i = n.child; if (null !== i) return As(t, i); { const o = t[n.index]; return bt(o) ? _h(-1, o) : De(o) } } if (32 & e) return uh(n, t)() || De(t[n.index]); { const i = Xv(t, n); return null !== i ? Array.isArray(i) ? i[0] : As(Is(t[je]), i) : As(t, n.next) } } return null } function Xv(t, n) { return null !== n ? t[je][ut].projection[n.projection] : null } function _h(t, n) { const e = it + t + 1; if (e < n.length) { const i = n[e], o = i[R].firstChild; if (null !== o) return As(i, o) } return n[Rn] } function vh(t, n, e, i, o, r, s) { for (; null != e;) { const a = i[e.index], l = e.type; if (s && 0 === n && (a && ht(De(a), i), e.flags |= 2), 32 != (32 & e.flags)) if (8 & l) vh(t, n, e.child, i, o, r, !1), Qo(n, t, o, a, r); else if (32 & l) { const c = uh(e, i); let d; for (; d = c();)Qo(n, t, o, d, r); Qo(n, t, o, a, r) } else 16 & l ? Qv(t, n, i, e, o, r) : Qo(n, t, o, a, r); e = s ? e.projectionNext : e.next } } function Ts(t, n, e, i, o, r) { vh(e, i, t.firstChild, n, o, r, !1) } function Qv(t, n, e, i, o, r) { const s = e[je], l = s[ut].projection[i.projection]; if (Array.isArray(l)) for (let c = 0; c < l.length; c++)Qo(n, t, o, l[c], r); else { let c = l; const d = s[Ae]; Fl(i) && (c.flags |= 128), vh(t, n, c, d, o, r, !0) } } function Jv(t, n, e) { "" === e ? t.removeAttribute(n, "class") : t.setAttribute(n, "class", e) } function eb(t, n, e) { const { mergedAttrs: i, classes: o, styles: r } = e; null !== i && Tu(t, n, i), null !== o && Jv(t, n, o), null !== r && function ZR(t, n, e) { t.setAttribute(n, "style", e) }(t, n, r) } function Jo(t) { return function bh() { if (void 0 === Ul && (Ul = null, Ce.trustedTypes)) try { Ul = Ce.trustedTypes.createPolicy("angular", { createHTML: t => t, createScript: t => t, createScriptURL: t => t }) } catch { } return Ul }()?.createHTML(t) || t } function ib(t) { return function wh() { if (void 0 === zl && (zl = null, Ce.trustedTypes)) try { zl = Ce.trustedTypes.createPolicy("angular#unsafe-bypass", { createHTML: t => t, createScript: t => t, createScriptURL: t => t }) } catch { } return zl }()?.createScriptURL(t) || t } class Qi { constructor(n) { this.changingThisBreaksApplicationSecurity = n } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Yg})` } } class eO extends Qi { getTypeName() { return "HTML" } } class tO extends Qi { getTypeName() { return "Style" } } class nO extends Qi { getTypeName() { return "Script" } } class iO extends Qi { getTypeName() { return "URL" } } class oO extends Qi { getTypeName() { return "ResourceURL" } } function qt(t) { return t instanceof Qi ? t.changingThisBreaksApplicationSecurity : t } function Pn(t, n) { const e = function rO(t) { return t instanceof Qi && t.getTypeName() || null }(t); if (null != e && e !== n) { if ("ResourceURL" === e && "URL" === n) return !0; throw new Error(`Required a safe ${n}, got a ${e} (see ${Yg})`) } return e === n } class uO { constructor(n) { this.inertDocumentHelper = n } getInertBodyElement(n) { n = "<body><remove></remove>" + n; try { const e = (new window.DOMParser).parseFromString(Jo(n), "text/html").body; return null === e ? this.inertDocumentHelper.getInertBodyElement(n) : (e.removeChild(e.firstChild), e) } catch { return null } } } class hO { constructor(n) { this.defaultDoc = n, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert") } getInertBodyElement(n) { const e = this.inertDocument.createElement("template"); return e.innerHTML = Jo(n), e } } const pO = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i; function $l(t) { return (t = String(t)).match(pO) ? t : "unsafe:" + t } function ti(t) { const n = {}; for (const e of t.split(",")) n[e] = !0; return n } function Rs(...t) { const n = {}; for (const e of t) for (const i in e) e.hasOwnProperty(i) && (n[i] = !0); return n } const rb = ti("area,br,col,hr,img,wbr"), sb = ti("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), ab = ti("rp,rt"), xh = Rs(rb, Rs(sb, ti("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), Rs(ab, ti("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), Rs(ab, sb)), Ch = ti("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), lb = Rs(Ch, ti("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), ti("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), mO = ti("script,style,template"); class gO { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(n) { let e = n.firstChild, i = !0; for (; e;)if (e.nodeType === Node.ELEMENT_NODE ? i = this.startElement(e) : e.nodeType === Node.TEXT_NODE ? this.chars(e.nodeValue) : this.sanitizedSomething = !0, i && e.firstChild) e = e.firstChild; else for (; e;) { e.nodeType === Node.ELEMENT_NODE && this.endElement(e); let o = this.checkClobberedElement(e, e.nextSibling); if (o) { e = o; break } e = this.checkClobberedElement(e, e.parentNode) } return this.buf.join("") } startElement(n) { const e = n.nodeName.toLowerCase(); if (!xh.hasOwnProperty(e)) return this.sanitizedSomething = !0, !mO.hasOwnProperty(e); this.buf.push("<"), this.buf.push(e); const i = n.attributes; for (let o = 0; o < i.length; o++) { const r = i.item(o), s = r.name, a = s.toLowerCase(); if (!lb.hasOwnProperty(a)) { this.sanitizedSomething = !0; continue } let l = r.value; Ch[a] && (l = $l(l)), this.buf.push(" ", s, '="', cb(l), '"') } return this.buf.push(">"), !0 } endElement(n) { const e = n.nodeName.toLowerCase(); xh.hasOwnProperty(e) && !rb.hasOwnProperty(e) && (this.buf.push("</"), this.buf.push(e), this.buf.push(">")) } chars(n) { this.buf.push(cb(n)) } checkClobberedElement(n, e) { if (e && (n.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${n.outerHTML}`); return e } } const _O = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, vO = /([^\#-~ |!])/g; function cb(t) { return t.replace(/&/g, "&amp;").replace(_O, function (n) { return "&#" + (1024 * (n.charCodeAt(0) - 55296) + (n.charCodeAt(1) - 56320) + 65536) + ";" }).replace(vO, function (n) { return "&#" + n.charCodeAt(0) + ";" }).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let Gl; function db(t, n) { let e = null; try { Gl = Gl || function ob(t) { const n = new hO(t); return function fO() { try { return !!(new window.DOMParser).parseFromString(Jo(""), "text/html") } catch { return !1 } }() ? new uO(n) : n }(t); let i = n ? String(n) : ""; e = Gl.getInertBodyElement(i); let o = 5, r = i; do { if (0 === o) throw new Error("Failed to sanitize html because the input is unstable"); o--, i = r, r = e.innerHTML, e = Gl.getInertBodyElement(i) } while (i !== r); return Jo((new gO).sanitizeChildren(Dh(e) || e)) } finally { if (e) { const i = Dh(e) || e; for (; i.firstChild;)i.removeChild(i.firstChild) } } } function Dh(t) { return "content" in t && function bO(t) { return t.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === t.nodeName }(t) ? t.content : null } var st = function (t) { return t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL", t }(st || {}); function tr(t) { const n = Os(); return n ? n.sanitize(st.URL, t) || "" : Pn(t, "URL") ? qt(t) : $l(G(t)) } function ub(t) { const n = Os(); if (n) return ib(n.sanitize(st.RESOURCE_URL, t) || ""); if (Pn(t, "ResourceURL")) return ib(qt(t)); throw new b(904, !1) } function Os() { const t = D(); return t && t[ko].sanitizer } const ks = new E("ENVIRONMENT_INITIALIZER"), fb = new E("INJECTOR", -1), pb = new E("INJECTOR_DEF_TYPES"); class Eh { get(n, e = os) { if (e === os) { const i = new Error(`NullInjectorError: No provider for ${Ze(n)}!`); throw i.name = "NullInjectorError", i } return e } } function SO(...t) { return { \u0275providers: mb(0, t), \u0275fromNgModule: !0 } } function mb(t, ...n) { const e = [], i = new Set; let o; const r = s => { e.push(s) }; return Yo(n, s => { const a = s; ql(a, r, [], i) && (o ||= [], o.push(a)) }), void 0 !== o && gb(o, r), e } function gb(t, n) { for (let e = 0; e < t.length; e++) { const { ngModule: i, providers: o } = t[e]; Mh(o, r => { n(r, i) }) } } function ql(t, n, e, i) { if (!(t = H(t))) return !1; let o = null, r = ll(t); const s = !r && oe(t); if (r || s) { if (s && !s.standalone) return !1; o = t } else { const l = t.ngModule; if (r = ll(l), !r) return !1; o = l } const a = i.has(o); if (s) { if (a) return !1; if (i.add(o), s.dependencies) { const l = "function" == typeof s.dependencies ? s.dependencies() : s.dependencies; for (const c of l) ql(c, n, e, i) } } else { if (!r) return !1; { if (null != r.imports && !a) { let c; i.add(o); try { Yo(r.imports, d => { ql(d, n, e, i) && (c ||= [], c.push(d)) }) } finally { } void 0 !== c && gb(c, n) } if (!a) { const c = Wi(o) || (() => new o); n({ provide: o, useFactory: c, deps: ce }, o), n({ provide: pb, useValue: o, multi: !0 }, o), n({ provide: ks, useValue: () => w(o), multi: !0 }, o) } const l = r.providers; if (null != l && !a) { const c = t; Mh(l, d => { n(d, c) }) } } } return o !== t && void 0 !== t.providers } function Mh(t, n) { for (let e of t) vu(e) && (e = e.\u0275providers), Array.isArray(e) ? Mh(e, n) : n(e) } const MO = me({ provide: String, useValue: me }); function Ih(t) { return null !== t && "object" == typeof t && MO in t } function Ji(t) { return "function" == typeof t } const Ah = new E("Set Injector scope."), Wl = {}, AO = {}; let Th; function Yl() { return void 0 === Th && (Th = new Eh), Th } class Wt { } class nr extends Wt { get destroyed() { return this._destroyed } constructor(n, e, i, o) { super(), this.parent = e, this.source = i, this.scopes = o, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, Oh(n, s => this.processProvider(s)), this.records.set(fb, ir(void 0, this)), o.has("environment") && this.records.set(Wt, ir(void 0, this)); const r = this.records.get(Ah); null != r && "string" == typeof r.value && this.scopes.add(r.value), this.injectorDefTypes = new Set(this.get(pb.multi, ce, J.Self)) } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const e of this._ngOnDestroyHooks) e.ngOnDestroy(); const n = this._onDestroyHooks; this._onDestroyHooks = []; for (const e of n) e() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear() } } onDestroy(n) { return this.assertNotDestroyed(), this._onDestroyHooks.push(n), () => this.removeOnDestroy(n) } runInContext(n) { this.assertNotDestroyed(); const e = gi(this), i = Rt(void 0); try { return n() } finally { gi(e), Rt(i) } } get(n, e = os, i = J.Default) { if (this.assertNotDestroyed(), n.hasOwnProperty(i_)) return n[i_](this); i = ul(i); const r = gi(this), s = Rt(void 0); try { if (!(i & J.SkipSelf)) { let l = this.records.get(n); if (void 0 === l) { const c = function FO(t) { return "function" == typeof t || "object" == typeof t && t instanceof E }(n) && al(n); l = c && this.injectableDefInScope(c) ? ir(Rh(n), Wl) : null, this.records.set(n, l) } if (null != l) return this.hydrate(n, l) } return (i & J.Self ? Yl() : this.parent).get(n, e = i & J.Optional && e === os ? null : e) } catch (a) { if ("NullInjectorError" === a.name) { if ((a[dl] = a[dl] || []).unshift(Ze(n)), r) throw a; return function EA(t, n, e, i) { const o = t[dl]; throw n[e_] && o.unshift(n[e_]), t.message = function SA(t, n, e, i = null) { t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.slice(2) : t; let o = Ze(n); if (Array.isArray(n)) o = n.map(Ze).join(" -> "); else if ("object" == typeof n) { let r = []; for (let s in n) if (n.hasOwnProperty(s)) { let a = n[s]; r.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : Ze(a))) } o = `{${r.join(", ")}}` } return `${e}${i ? "(" + i + ")" : ""}[${o}]: ${t.replace(yA, "\n  ")}` }("\n" + t.message, o, e, i), t.ngTokenPath = o, t[dl] = null, t }(a, n, "R3InjectorError", this.source) } throw a } finally { Rt(s), gi(r) } } resolveInjectorInitializers() { const n = gi(this), e = Rt(void 0); try { const o = this.get(ks.multi, ce, J.Self); for (const r of o) r() } finally { gi(n), Rt(e) } } toString() { const n = [], e = this.records; for (const i of e.keys()) n.push(Ze(i)); return `R3Injector[${n.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new b(205, !1) } processProvider(n) { let e = Ji(n = H(n)) ? n : H(n && n.provide); const i = function RO(t) { return Ih(t) ? ir(void 0, t.useValue) : ir(bb(t), Wl) }(n); if (Ji(n) || !0 !== n.multi) this.records.get(e); else { let o = this.records.get(e); o || (o = ir(void 0, Wl, !0), o.factory = () => Mu(o.multi), this.records.set(e, o)), e = n, o.multi.push(n) } this.records.set(e, i) } hydrate(n, e) { return e.value === Wl && (e.value = AO, e.value = e.factory()), "object" == typeof e.value && e.value && function kO(t) { return null !== t && "object" == typeof t && "function" == typeof t.ngOnDestroy }(e.value) && this._ngOnDestroyHooks.add(e.value), e.value } injectableDefInScope(n) { if (!n.providedIn) return !1; const e = H(n.providedIn); return "string" == typeof e ? "any" === e || this.scopes.has(e) : this.injectorDefTypes.has(e) } removeOnDestroy(n) { const e = this._onDestroyHooks.indexOf(n); -1 !== e && this._onDestroyHooks.splice(e, 1) } } function Rh(t) { const n = al(t), e = null !== n ? n.factory : Wi(t); if (null !== e) return e; if (t instanceof E) throw new b(204, !1); if (t instanceof Function) return function TO(t) { const n = t.length; if (n > 0) throw Ds(n, "?"), new b(204, !1); const e = function gA(t) { return t && (t[cl] || t[Xg]) || null }(t); return null !== e ? () => e.factory(t) : () => new t }(t); throw new b(204, !1) } function bb(t, n, e) { let i; if (Ji(t)) { const o = H(t); return Wi(o) || Rh(o) } if (Ih(t)) i = () => H(t.useValue); else if (function vb(t) { return !(!t || !t.useFactory) }(t)) i = () => t.useFactory(...Mu(t.deps || [])); else if (function _b(t) { return !(!t || !t.useExisting) }(t)) i = () => w(H(t.useExisting)); else { const o = H(t && (t.useClass || t.provide)); if (!function OO(t) { return !!t.deps }(t)) return Wi(o) || Rh(o); i = () => new o(...Mu(t.deps)) } return i } function ir(t, n, e = !1) { return { factory: t, value: n, multi: e ? [] : void 0 } } function Oh(t, n) { for (const e of t) Array.isArray(e) ? Oh(e, n) : e && vu(e) ? Oh(e.\u0275providers, n) : n(e) } const Zl = new E("AppId", { providedIn: "root", factory: () => PO }), PO = "ng", yb = new E("Platform Initializer"), Ci = new E("Platform ID", { providedIn: "platform", factory: () => "unknown" }), eo = new E("AnimationModuleType"), kh = new E("CSP nonce", { providedIn: "root", factory: () => function er() { if (void 0 !== yh) return yh; if (typeof document < "u") return document; throw new b(210, !1) }().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null }); let wb = (t, n, e) => null; function Hh(t, n, e = !1) { return wb(t, n, e) } class GO { } class Db { } class WO { resolveComponentFactory(n) { throw function qO(t) { const n = Error(`No component factory found for ${Ze(t)}.`); return n.ngComponent = t, n }(n) } } let Ns = (() => { class t { static #e = this.NULL = new WO } return t })(); function YO() { return sr(rt(), D()) } function sr(t, n) { return new ye(Pt(t, n)) } let ye = (() => { class t { constructor(e) { this.nativeElement = e } static #e = this.__NG_ELEMENT_ID__ = YO } return t })(); function ZO(t) { return t instanceof ye ? t.nativeElement : t } class Ls { } let ni = (() => { class t { constructor() { this.destroyNode = null } static #e = this.__NG_ELEMENT_ID__ = () => function XO() { const t = D(), e = $t(rt().index, t); return (kt(e) ? e : t)[q] }() } return t })(), KO = (() => { class t { static #e = this.\u0275prov = I({ token: t, providedIn: "root", factory: () => null }) } return t })(); class to { constructor(n) { this.full = n, this.major = n.split(".")[0], this.minor = n.split(".")[1], this.patch = n.split(".").slice(2).join(".") } } const QO = new to("16.2.12"), $h = {}; function Ab(t, n = null, e = null, i) { const o = Tb(t, n, e, i); return o.resolveInjectorInitializers(), o } function Tb(t, n = null, e = null, i, o = new Set) { const r = [e || ce, SO(t)]; return i = i || ("object" == typeof t ? void 0 : Ze(t)), new nr(r, n || Yl(), i || null, o) } let ft = (() => { class t { static #e = this.THROW_IF_NOT_FOUND = os; static #t = this.NULL = new Eh; static create(e, i) { if (Array.isArray(e)) return Ab({ name: "" }, i, e, ""); { const o = e.name ?? ""; return Ab({ name: o }, e.parent, e.providers, o) } } static #n = this.\u0275prov = I({ token: t, providedIn: "any", factory: () => w(fb) }); static #i = this.__NG_ELEMENT_ID__ = -1 } return t })(); function qh(t) { return t.ngOriginalError } class sn { constructor() { this._console = console } handleError(n) { const e = this._findOriginalError(n); this._console.error("ERROR", n), e && this._console.error("ORIGINAL ERROR", e) } _findOriginalError(n) { let e = n && qh(n); for (; e && qh(e);)e = qh(e); return e || null } } function Yh(t) { return n => { setTimeout(t, void 0, n) } } const ue = class s1 extends ie { constructor(n = !1) { super(), this.__isAsync = n } emit(n) { super.next(n) } subscribe(n, e, i) { let o = n, r = e || (() => null), s = i; if (n && "object" == typeof n) { const l = n; o = l.next?.bind(l), r = l.error?.bind(l), s = l.complete?.bind(l) } this.__isAsync && (r = Yh(r), o && (o = Yh(o)), s && (s = Yh(s))); const a = super.subscribe({ next: o, error: r, complete: s }); return n instanceof Fe && n.add(a), a } }; function Ob(...t) { } class z { constructor({ enableLongStackTrace: n = !1, shouldCoalesceEventChangeDetection: e = !1, shouldCoalesceRunChangeDetection: i = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new ue(!1), this.onMicrotaskEmpty = new ue(!1), this.onStable = new ue(!1), this.onError = new ue(!1), typeof Zone > "u") throw new b(908, !1); Zone.assertZonePatched(); const o = this; o._nesting = 0, o._outer = o._inner = Zone.current, Zone.TaskTrackingZoneSpec && (o._inner = o._inner.fork(new Zone.TaskTrackingZoneSpec)), n && Zone.longStackTraceZoneSpec && (o._inner = o._inner.fork(Zone.longStackTraceZoneSpec)), o.shouldCoalesceEventChangeDetection = !i && e, o.shouldCoalesceRunChangeDetection = i, o.lastRequestAnimationFrameId = -1, o.nativeRequestAnimationFrame = function a1() { const t = "function" == typeof Ce.requestAnimationFrame; let n = Ce[t ? "requestAnimationFrame" : "setTimeout"], e = Ce[t ? "cancelAnimationFrame" : "clearTimeout"]; if (typeof Zone < "u" && n && e) { const i = n[Zone.__symbol__("OriginalDelegate")]; i && (n = i); const o = e[Zone.__symbol__("OriginalDelegate")]; o && (e = o) } return { nativeRequestAnimationFrame: n, nativeCancelAnimationFrame: e } }().nativeRequestAnimationFrame, function d1(t) { const n = () => { !function c1(t) { t.isCheckStableRunning || -1 !== t.lastRequestAnimationFrameId || (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(Ce, () => { t.fakeTopEventTask || (t.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { t.lastRequestAnimationFrameId = -1, Xh(t), t.isCheckStableRunning = !0, Zh(t), t.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), t.fakeTopEventTask.invoke() }), Xh(t)) }(t) }; t._inner = t._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (e, i, o, r, s, a) => { if (function h1(t) { return !(!Array.isArray(t) || 1 !== t.length) && !0 === t[0].data?.__ignore_ng_zone__ }(a)) return e.invokeTask(o, r, s, a); try { return kb(t), e.invokeTask(o, r, s, a) } finally { (t.shouldCoalesceEventChangeDetection && "eventTask" === r.type || t.shouldCoalesceRunChangeDetection) && n(), Fb(t) } }, onInvoke: (e, i, o, r, s, a, l) => { try { return kb(t), e.invoke(o, r, s, a, l) } finally { t.shouldCoalesceRunChangeDetection && n(), Fb(t) } }, onHasTask: (e, i, o, r) => { e.hasTask(o, r), i === o && ("microTask" == r.change ? (t._hasPendingMicrotasks = r.microTask, Xh(t), Zh(t)) : "macroTask" == r.change && (t.hasPendingMacrotasks = r.macroTask)) }, onHandleError: (e, i, o, r) => (e.handleError(o, r), t.runOutsideAngular(() => t.onError.emit(r)), !1) }) }(o) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!z.isInAngularZone()) throw new b(909, !1) } static assertNotInAngularZone() { if (z.isInAngularZone()) throw new b(909, !1) } run(n, e, i) { return this._inner.run(n, e, i) } runTask(n, e, i, o) { const r = this._inner, s = r.scheduleEventTask("NgZoneEvent: " + o, n, l1, Ob, Ob); try { return r.runTask(s, e, i) } finally { r.cancelTask(s) } } runGuarded(n, e, i) { return this._inner.runGuarded(n, e, i) } runOutsideAngular(n) { return this._outer.run(n) } } const l1 = {}; function Zh(t) { if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try { t._nesting++, t.onMicrotaskEmpty.emit(null) } finally { if (t._nesting--, !t.hasPendingMicrotasks) try { t.runOutsideAngular(() => t.onStable.emit(null)) } finally { t.isStable = !0 } } } function Xh(t) { t.hasPendingMicrotasks = !!(t._hasPendingMicrotasks || (t.shouldCoalesceEventChangeDetection || t.shouldCoalesceRunChangeDetection) && -1 !== t.lastRequestAnimationFrameId) } function kb(t) { t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null)) } function Fb(t) { t._nesting--, Zh(t) } class u1 { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new ue, this.onMicrotaskEmpty = new ue, this.onStable = new ue, this.onError = new ue } run(n, e, i) { return n.apply(e, i) } runGuarded(n, e, i) { return n.apply(e, i) } runOutsideAngular(n) { return n() } runTask(n, e, i, o) { return n.apply(e, i) } } const Pb = new E("", { providedIn: "root", factory: Nb }); function Nb() { const t = T(z); let n = !0; return $i(new xe(o => { n = t.isStable && !t.hasPendingMacrotasks && !t.hasPendingMicrotasks, t.runOutsideAngular(() => { o.next(n), o.complete() }) }), new xe(o => { let r; t.runOutsideAngular(() => { r = t.onStable.subscribe(() => { z.assertNotInAngularZone(), queueMicrotask(() => { !n && !t.hasPendingMacrotasks && !t.hasPendingMicrotasks && (n = !0, o.next(!0)) }) }) }); const s = t.onUnstable.subscribe(() => { z.assertInAngularZone(), n && (n = !1, t.runOutsideAngular(() => { o.next(!1) })) }); return () => { r.unsubscribe(), s.unsubscribe() } }).pipe(ol())) } function ii(t) { return t instanceof Function ? t() : t } let Kh = (() => { class t { constructor() { this.renderDepth = 0, this.handler = null } begin() { this.handler?.validateBegin(), this.renderDepth++ } end() { this.renderDepth--, 0 === this.renderDepth && this.handler?.execute() } ngOnDestroy() { this.handler?.destroy(), this.handler = null } static #e = this.\u0275prov = I({ token: t, providedIn: "root", factory: () => new t }) } return t })(); function Vs(t) { for (; t;) { t[Y] |= 64; const n = Is(t); if (ku(t) && !n) return t; t = n } return null } const Hb = new E("", { providedIn: "root", factory: () => !1 }); let nc = null; function Gb(t, n) { return t[n] ?? Yb() } function qb(t, n) { const e = Yb(); e.producerNode?.length && (t[n] = nc, e.lView = t, nc = Wb()) } const x1 = { ...y_, consumerIsAlwaysLive: !0, consumerMarkedDirty: t => { Vs(t.lView) }, lView: null }; function Wb() { return Object.create(x1) } function Yb() { return nc ??= Wb(), nc } const W = {}; function S(t) { Zb(re(), D(), wt() + t, !1) } function Zb(t, n, e, i) { if (!i) if (3 == (3 & n[Y])) { const r = t.preOrderCheckHooks; null !== r && xl(n, r, e) } else { const r = t.preOrderHooks; null !== r && Cl(n, r, 0, e) } Yi(e) } function g(t, n = J.Default) { const e = D(); return null === e ? w(t, n) : uv(rt(), e, H(t), n) } function ic() { throw new Error("invalid") } function oc(t, n, e, i, o, r, s, a, l, c, d) { const u = n.blueprint.slice(); return u[Ne] = o, u[Y] = 140 | i, (null !== c || t && 2048 & t[Y]) && (u[Y] |= 2048), j_(u), u[Ae] = u[Fo] = t, u[Be] = e, u[ko] = s || t && t[ko], u[q] = a || t && t[q], u[_i] = l || t && t[_i] || null, u[ut] = r, u[us] = function DR() { return CR++ }(), u[Qn] = d, u[g_] = c, u[je] = 2 == n.type ? t[je] : u, u } function cr(t, n, e, i, o) { let r = t.data[n]; if (null === r) r = function Qh(t, n, e, i, o) { const r = q_(), s = Hu(), l = t.data[n] = function T1(t, n, e, i, o, r) { let s = n ? n.injectorIndex : -1, a = 0; return Bo() && (a |= 128), { type: e, index: i, insertBeforeIndex: null, injectorIndex: s, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: a, providerIndexes: 0, value: o, attrs: r, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tView: null, next: null, prev: null, projectionNext: null, child: null, parent: n, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? r : r && r.parent, e, n, i, o); return null === t.firstChild && (t.firstChild = l), null !== r && (s ? null == r.child && null !== l.parent && (r.child = l) : null === r.next && (r.next = l, l.prev = r)), l }(t, n, e, i, o), function CT() { return j.lFrame.inI18n }() && (r.flags |= 32); else if (64 & r.type) { r.type = e, r.value = i, r.attrs = o; const s = function vs() { const t = j.lFrame, n = t.currentTNode; return t.isParent ? n : n.parent }(); r.injectorIndex = null === s ? -1 : s.injectorIndex } return kn(r, !0), r } function Bs(t, n, e, i) { if (0 === e) return -1; const o = n.length; for (let r = 0; r < e; r++)n.push(i), t.blueprint.push(i), t.data.push(null); return o } function Xb(t, n, e, i, o) { const r = Gb(n, hs), s = wt(), a = 2 & i; try { Yi(-1), a && n.length > ee && Zb(t, n, ee, !1), On(a ? 2 : 0, o); const c = a ? r : null, d = Pu(c); try { null !== c && (c.dirty = !1), e(i, o) } finally { Nu(c, d) } } finally { a && null === n[hs] && qb(n, hs), Yi(s), On(a ? 3 : 1, o) } } function Jh(t, n, e) { if (Ou(n)) { const i = on(null); try { const r = n.directiveEnd; for (let s = n.directiveStart; s < r; s++) { const a = t.data[s]; a.contentQueries && a.contentQueries(1, e[s], s) } } finally { on(i) } } } function ef(t, n, e) { G_() && (function L1(t, n, e, i) { const o = e.directiveStart, r = e.directiveEnd; qi(e) && function $1(t, n, e) { const i = Pt(n, t), o = Kb(e); let s = 16; e.signals ? s = 4096 : e.onPush && (s = 64); const a = rc(t, oc(t, o, null, s, i, n, null, t[ko].rendererFactory.createRenderer(i, e), null, null, null)); t[n.index] = a }(n, e, t.data[o + e.componentOffset]), t.firstCreatePass || El(e, n), ht(i, n); const s = e.initialInputs; for (let a = o; a < r; a++) { const l = t.data[a], c = Zi(n, t, a, e); ht(c, n), null !== s && G1(0, a - o, c, l, 0, s), wn(l) && ($t(e.index, n)[Be] = Zi(n, t, a, e)) } }(t, n, e, Pt(e, n)), 64 == (64 & e.flags) && ny(t, n, e)) } function tf(t, n, e = Pt) { const i = n.localNames; if (null !== i) { let o = n.index + 1; for (let r = 0; r < i.length; r += 2) { const s = i[r + 1], a = -1 === s ? e(n, t) : t[s]; t[o++] = a } } } function Kb(t) { const n = t.tView; return null === n || n.incompleteFirstPass ? t.tView = nf(1, null, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts, t.id) : n } function nf(t, n, e, i, o, r, s, a, l, c, d) { const u = ee + i, h = u + o, f = function D1(t, n) { const e = []; for (let i = 0; i < n; i++)e.push(i < t ? null : W); return e }(u, h), p = "function" == typeof c ? c() : c; return f[R] = { type: t, blueprint: f, template: e, queries: null, viewQuery: a, declTNode: n, data: f.slice().fill(null, u), bindingStartIndex: u, expandoStartIndex: h, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof r ? r() : r, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: l, consts: p, incompleteFirstPass: !1, ssrId: d } } let Qb = t => null; function Jb(t, n, e, i) { for (let o in t) if (t.hasOwnProperty(o)) { e = null === e ? {} : e; const r = t[o]; null === i ? ey(e, n, o, r) : i.hasOwnProperty(o) && ey(e, n, i[o], r) } return e } function ey(t, n, e, i) { t.hasOwnProperty(e) ? t[e].push(n, i) : t[e] = [n, i] } function Yt(t, n, e, i, o, r, s, a) { const l = Pt(n, e); let d, c = n.inputs; !a && null != c && (d = c[i]) ? (cf(t, e, d, i, o), qi(n) && function k1(t, n) { const e = $t(n, t); 16 & e[Y] || (e[Y] |= 64) }(e, n.index)) : 3 & n.type && (i = function O1(t) { return "class" === t ? "className" : "for" === t ? "htmlFor" : "formaction" === t ? "formAction" : "innerHtml" === t ? "innerHTML" : "readonly" === t ? "readOnly" : "tabindex" === t ? "tabIndex" : t }(i), o = null != s ? s(o, n.value || "", i) : o, r.setProperty(l, i, o)) } function rf(t, n, e, i) { if (G_()) { const o = null === i ? null : { "": -1 }, r = function B1(t, n) { const e = t.directiveRegistry; let i = null, o = null; if (e) for (let r = 0; r < e.length; r++) { const s = e[r]; if (d_(n, s.selectors, !1)) if (i || (i = []), wn(s)) if (null !== s.findHostDirectiveDefs) { const a = []; o = o || new Map, s.findHostDirectiveDefs(s, a, o), i.unshift(...a, s), sf(t, n, a.length) } else i.unshift(s), sf(t, n, 0); else o = o || new Map, s.findHostDirectiveDefs?.(s, i, o), i.push(s) } return null === i ? null : [i, o] }(t, e); let s, a; null === r ? s = a = null : [s, a] = r, null !== s && ty(t, n, e, s, o, a), o && function j1(t, n, e) { if (n) { const i = t.localNames = []; for (let o = 0; o < n.length; o += 2) { const r = e[n[o + 1]]; if (null == r) throw new b(-301, !1); i.push(n[o], r) } } }(e, i, o) } e.mergedAttrs = as(e.mergedAttrs, e.attrs) } function ty(t, n, e, i, o, r) { for (let c = 0; c < i.length; c++)Ju(El(e, n), t, i[c].type); !function U1(t, n, e) { t.flags |= 1, t.directiveStart = n, t.directiveEnd = n + e, t.providerIndexes = n }(e, t.data.length, i.length); for (let c = 0; c < i.length; c++) { const d = i[c]; d.providersResolver && d.providersResolver(d) } let s = !1, a = !1, l = Bs(t, n, i.length, null); for (let c = 0; c < i.length; c++) { const d = i[c]; e.mergedAttrs = as(e.mergedAttrs, d.hostAttrs), z1(t, e, n, l, d), H1(l, d, o), null !== d.contentQueries && (e.flags |= 4), (null !== d.hostBindings || null !== d.hostAttrs || 0 !== d.hostVars) && (e.flags |= 64); const u = d.type.prototype; !s && (u.ngOnChanges || u.ngOnInit || u.ngDoCheck) && ((t.preOrderHooks ??= []).push(e.index), s = !0), !a && (u.ngOnChanges || u.ngDoCheck) && ((t.preOrderCheckHooks ??= []).push(e.index), a = !0), l++ } !function R1(t, n, e) { const o = n.directiveEnd, r = t.data, s = n.attrs, a = []; let l = null, c = null; for (let d = n.directiveStart; d < o; d++) { const u = r[d], h = e ? e.get(u) : null, p = h ? h.outputs : null; l = Jb(u.inputs, d, l, h ? h.inputs : null), c = Jb(u.outputs, d, c, p); const m = null === l || null === s || c_(n) ? null : q1(l, d, s); a.push(m) } null !== l && (l.hasOwnProperty("class") && (n.flags |= 8), l.hasOwnProperty("style") && (n.flags |= 16)), n.initialInputs = a, n.inputs = l, n.outputs = c }(t, e, r) } function ny(t, n, e) { const i = e.directiveStart, o = e.directiveEnd, r = e.index, s = function ET() { return j.lFrame.currentDirectiveIndex }(); try { Yi(r); for (let a = i; a < o; a++) { const l = t.data[a], c = n[a]; zu(a), (null !== l.hostBindings || 0 !== l.hostVars || null !== l.hostAttrs) && V1(l, c) } } finally { Yi(-1), zu(s) } } function V1(t, n) { null !== t.hostBindings && t.hostBindings(1, n) } function sf(t, n, e) { n.componentOffset = e, (t.components ??= []).push(n.index) } function H1(t, n, e) { if (e) { if (n.exportAs) for (let i = 0; i < n.exportAs.length; i++)e[n.exportAs[i]] = t; wn(n) && (e[""] = t) } } function z1(t, n, e, i, o) { t.data[i] = o; const r = o.factory || (o.factory = Wi(o.type)), s = new bs(r, wn(o), g); t.blueprint[i] = s, e[i] = s, function P1(t, n, e, i, o) { const r = o.hostBindings; if (r) { let s = t.hostBindingOpCodes; null === s && (s = t.hostBindingOpCodes = []); const a = ~n.index; (function N1(t) { let n = t.length; for (; n > 0;) { const e = t[--n]; if ("number" == typeof e && e < 0) return e } return 0 })(s) != a && s.push(a), s.push(e, i, r) } }(t, n, i, Bs(t, e, o.hostVars, W), o) } function Nn(t, n, e, i, o, r) { const s = Pt(t, n); !function af(t, n, e, i, o, r, s) { if (null == r) t.removeAttribute(n, o, e); else { const a = null == s ? G(r) : s(r, i || "", o); t.setAttribute(n, o, a, e) } }(n[q], s, r, t.value, e, i, o) } function G1(t, n, e, i, o, r) { const s = r[n]; if (null !== s) for (let a = 0; a < s.length;)iy(i, e, s[a++], s[a++], s[a++]) } function iy(t, n, e, i, o) { const r = on(null); try { const s = t.inputTransforms; null !== s && s.hasOwnProperty(i) && (o = s[i].call(n, o)), null !== t.setInput ? t.setInput(n, o, e, i) : n[i] = o } finally { on(r) } } function q1(t, n, e) { let i = null, o = 0; for (; o < e.length;) { const r = e[o]; if (0 !== r) if (5 !== r) { if ("number" == typeof r) break; if (t.hasOwnProperty(r)) { null === i && (i = []); const s = t[r]; for (let a = 0; a < s.length; a += 2)if (s[a] === n) { i.push(r, s[a + 1], e[o + 1]); break } } o += 2 } else o += 2; else o += 4 } return i } function oy(t, n, e, i) { return [t, !0, !1, n, null, 0, i, e, null, null, null] } function ry(t, n) { const e = t.contentQueries; if (null !== e) for (let i = 0; i < e.length; i += 2) { const r = e[i + 1]; if (-1 !== r) { const s = t.data[r]; Gu(e[i]), s.contentQueries(2, n[r], r) } } } function rc(t, n) { return t[cs] ? t[m_][yn] = n : t[cs] = n, t[m_] = n, n } function lf(t, n, e) { Gu(0); const i = on(null); try { n(t, e) } finally { on(i) } } function sy(t) { return t[Oo] || (t[Oo] = []) } function ay(t) { return t.cleanup || (t.cleanup = []) } function cy(t, n) { const e = t[_i], i = e ? e.get(sn, null) : null; i && i.handleError(n) } function cf(t, n, e, i, o) { for (let r = 0; r < e.length;) { const s = e[r++], a = e[r++]; iy(t.data[s], n[s], i, a, o) } } function oi(t, n, e) { const i = bl(n, t); !function Hv(t, n, e) { t.setValue(n, e) }(t[q], i, e) } function W1(t, n) { const e = $t(n, t), i = e[R]; !function Y1(t, n) { for (let e = n.length; e < t.blueprint.length; e++)n.push(t.blueprint[e]) }(i, e); const o = e[Ne]; null !== o && null === e[Qn] && (e[Qn] = Hh(o, e[_i])), df(i, e, e[Be]) } function df(t, n, e) { qu(n); try { const i = t.viewQuery; null !== i && lf(1, i, e); const o = t.template; null !== o && Xb(t, n, o, 1, e), t.firstCreatePass && (t.firstCreatePass = !1), t.staticContentQueries && ry(t, n), t.staticViewQueries && lf(2, t.viewQuery, e); const r = t.components; null !== r && function Z1(t, n) { for (let e = 0; e < n.length; e++)W1(t, n[e]) }(n, r) } catch (i) { throw t.firstCreatePass && (t.incompleteFirstPass = !0, t.firstCreatePass = !1), i } finally { n[Y] &= -5, Wu() } } let dy = (() => { class t { constructor() { this.all = new Set, this.queue = new Map } create(e, i, o) { const r = typeof Zone > "u" ? null : Zone.current, s = function tT(t, n, e) { const i = Object.create(nT); e && (i.consumerAllowSignalWrites = !0), i.fn = t, i.schedule = n; const o = s => { i.cleanupFn = s }; return i.ref = { notify: () => D_(i), run: () => { if (i.dirty = !1, i.hasRun && !E_(i)) return; i.hasRun = !0; const s = Pu(i); try { i.cleanupFn(), i.cleanupFn = k_, i.fn(o) } finally { Nu(i, s) } }, cleanup: () => i.cleanupFn() }, i.ref }(e, c => { this.all.has(c) && this.queue.set(c, r) }, o); let a; this.all.add(s), s.notify(); const l = () => { s.cleanup(), a?.(), this.all.delete(s), this.queue.delete(s) }; return a = i?.onDestroy(l), { destroy: l } } flush() { if (0 !== this.queue.size) for (const [e, i] of this.queue) this.queue.delete(e), i ? i.run(() => e.run()) : e.run() } get isQueueEmpty() { return 0 === this.queue.size } static #e = this.\u0275prov = I({ token: t, providedIn: "root", factory: () => new t }) } return t })(); function sc(t, n, e) { let i = e ? t.styles : null, o = e ? t.classes : null, r = 0; if (null !== n) for (let s = 0; s < n.length; s++) { const a = n[s]; "number" == typeof a ? r = a : 1 == r ? o = gu(o, a) : 2 == r && (i = gu(i, a + ": " + n[++s] + ";")) } e ? t.styles = i : t.stylesWithoutHost = i, e ? t.classes = o : t.classesWithoutHost = o } function js(t, n, e, i, o = !1) { for (; null !== e;) { const r = n[e.index]; null !== r && i.push(De(r)), bt(r) && uy(r, i); const s = e.type; if (8 & s) js(t, n, e.child, i); else if (32 & s) { const a = uh(e, n); let l; for (; l = a();)i.push(l) } else if (16 & s) { const a = Xv(n, e); if (Array.isArray(a)) i.push(...a); else { const l = Is(n[je]); js(l[R], l, a, i, !0) } } e = o ? e.projectionNext : e.next } return i } function uy(t, n) { for (let e = it; e < t.length; e++) { const i = t[e], o = i[R].firstChild; null !== o && js(i[R], i, o, n) } t[Rn] !== t[Ne] && n.push(t[Rn]) } function ac(t, n, e, i = !0) { const o = n[ko], r = o.rendererFactory, s = o.afterRenderEventManager; r.begin?.(), s?.begin(); try { hy(t, n, t.template, e) } catch (l) { throw i && cy(n, l), l } finally { r.end?.(), o.effectManager?.flush(), s?.end() } } function hy(t, n, e, i) { const o = n[Y]; if (256 != (256 & o)) { n[ko].effectManager?.flush(), qu(n); try { j_(n), function Y_(t) { return j.lFrame.bindingIndex = t }(t.bindingStartIndex), null !== e && Xb(t, n, e, 2, i); const s = 3 == (3 & o); if (s) { const c = t.preOrderCheckHooks; null !== c && xl(n, c, null) } else { const c = t.preOrderHooks; null !== c && Cl(n, c, 0, null), Yu(n, 0) } if (function Q1(t) { for (let n = Vv(t); null !== n; n = Bv(n)) { if (!n[__]) continue; const e = n[No]; for (let i = 0; i < e.length; i++) { hT(e[i]) } } }(n), fy(n, 2), null !== t.contentQueries && ry(t, n), s) { const c = t.contentCheckHooks; null !== c && xl(n, c) } else { const c = t.contentHooks; null !== c && Cl(n, c, 1), Yu(n, 1) } !function C1(t, n) { const e = t.hostBindingOpCodes; if (null === e) return; const i = Gb(n, fs); try { for (let o = 0; o < e.length; o++) { const r = e[o]; if (r < 0) Yi(~r); else { const s = r, a = e[++o], l = e[++o]; DT(a, s), i.dirty = !1; const c = Pu(i); try { l(2, n[s]) } finally { Nu(i, c) } } } } finally { null === n[fs] && qb(n, fs), Yi(-1) } }(t, n); const a = t.components; null !== a && my(n, a, 0); const l = t.viewQuery; if (null !== l && lf(2, l, i), s) { const c = t.viewCheckHooks; null !== c && xl(n, c) } else { const c = t.viewHooks; null !== c && Cl(n, c, 2), Yu(n, 2) } !0 === t.firstUpdatePass && (t.firstUpdatePass = !1), n[Y] &= -73, H_(n) } finally { Wu() } } } function fy(t, n) { for (let e = Vv(t); null !== e; e = Bv(e))for (let i = it; i < e.length; i++)py(e[i], n) } function J1(t, n, e) { py($t(n, t), e) } function py(t, n) { if (!function dT(t) { return 128 == (128 & t[Y]) }(t)) return; const e = t[R], i = t[Y]; if (80 & i && 0 === n || 1024 & i || 2 === n) hy(e, t, e.template, t[Be]); else if (t[ls] > 0) { fy(t, 1); const o = e.components; null !== o && my(t, o, 1) } } function my(t, n, e) { for (let i = 0; i < n.length; i++)J1(t, n[i], e) } class Hs { get rootNodes() { const n = this._lView, e = n[R]; return js(e, n, e.firstChild, []) } constructor(n, e) { this._lView = n, this._cdRefInjectingView = e, this._appRef = null, this._attachedToViewContainer = !1 } get context() { return this._lView[Be] } set context(n) { this._lView[Be] = n } get destroyed() { return 256 == (256 & this._lView[Y]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const n = this._lView[Ae]; if (bt(n)) { const e = n[8], i = e ? e.indexOf(this) : -1; i > -1 && (Vl(n, i), Il(e, i)) } this._attachedToViewContainer = !1 } fh(this._lView[R], this._lView) } onDestroy(n) { !function z_(t, n) { if (256 == (256 & t[Y])) throw new b(911, !1); null === t[vi] && (t[vi] = []), t[vi].push(n) }(this._lView, n) } markForCheck() { Vs(this._cdRefInjectingView || this._lView) } detach() { this._lView[Y] &= -129 } reattach() { this._lView[Y] |= 128 } detectChanges() { ac(this._lView[R], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new b(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function VR(t, n) { Ts(t, n, n[q], 2, null, null) }(this._lView[R], this._lView) } attachToAppRef(n) { if (this._attachedToViewContainer) throw new b(902, !1); this._appRef = n } } class ek extends Hs { constructor(n) { super(n), this._view = n } detectChanges() { const n = this._view; ac(n[R], n, n[Be], !1) } checkNoChanges() { } get context() { return null } } class gy extends Ns { constructor(n) { super(), this.ngModule = n } resolveComponentFactory(n) { const e = oe(n); return new Us(e, this.ngModule) } } function _y(t) { const n = []; for (let e in t) t.hasOwnProperty(e) && n.push({ propName: t[e], templateName: e }); return n } class nk { constructor(n, e) { this.injector = n, this.parentInjector = e } get(n, e, i) { i = ul(i); const o = this.injector.get(n, $h, i); return o !== $h || e === $h ? o : this.parentInjector.get(n, e, i) } } class Us extends Db { get inputs() { const n = this.componentDef, e = n.inputTransforms, i = _y(n.inputs); if (null !== e) for (const o of i) e.hasOwnProperty(o.propName) && (o.transform = e[o.propName]); return i } get outputs() { return _y(this.componentDef.outputs) } constructor(n, e) { super(), this.componentDef = n, this.ngModule = e, this.componentType = n.type, this.selector = function NA(t) { return t.map(PA).join(",") }(n.selectors), this.ngContentSelectors = n.ngContentSelectors ? n.ngContentSelectors : [], this.isBoundToModule = !!e } create(n, e, i, o) { let r = (o = o || this.ngModule) instanceof Wt ? o : o?.injector; r && null !== this.componentDef.getStandaloneInjector && (r = this.componentDef.getStandaloneInjector(r) || r); const s = r ? new nk(n, r) : n, a = s.get(Ls, null); if (null === a) throw new b(407, !1); const u = { rendererFactory: a, sanitizer: s.get(KO, null), effectManager: s.get(dy, null), afterRenderEventManager: s.get(Kh, null) }, h = a.createRenderer(null, this.componentDef), f = this.componentDef.selectors[0][0] || "div", p = i ? function E1(t, n, e, i) { const r = i.get(Hb, !1) || e === nn.ShadowDom, s = t.selectRootElement(n, r); return function S1(t) { Qb(t) }(s), s }(h, i, this.componentDef.encapsulation, s) : Ll(h, f, function tk(t) { const n = t.toLowerCase(); return "svg" === n ? "svg" : "math" === n ? "math" : null }(f)), C = this.componentDef.signals ? 4608 : this.componentDef.onPush ? 576 : 528; let v = null; null !== p && (v = Hh(p, s, !0)); const M = nf(0, null, null, 1, 0, null, null, null, null, null, null), O = oc(null, M, null, C, null, null, u, h, s, null, v); let $, ve; qu(O); try { const Me = this.componentDef; let ct, Jt = null; Me.findHostDirectiveDefs ? (ct = [], Jt = new Map, Me.findHostDirectiveDefs(Me, ct, Jt), ct.push(Me)) : ct = [Me]; const In = function ok(t, n) { const e = t[R], i = ee; return t[i] = n, cr(e, i, 2, "#host", null) }(O, p), nu = function rk(t, n, e, i, o, r, s) { const a = o[R]; !function sk(t, n, e, i) { for (const o of t) n.mergedAttrs = as(n.mergedAttrs, o.hostAttrs); null !== n.mergedAttrs && (sc(n, n.mergedAttrs, !0), null !== e && eb(i, e, n)) }(i, t, n, s); let l = null; null !== n && (l = Hh(n, o[_i])); const c = r.rendererFactory.createRenderer(n, e); let d = 16; e.signals ? d = 4096 : e.onPush && (d = 64); const u = oc(o, Kb(e), null, d, o[t.index], t, r, c, null, null, l); return a.firstCreatePass && sf(a, t, i.length - 1), rc(o, u), o[t.index] = u }(In, p, Me, ct, O, u, h); ve = B_(M, ee), p && function lk(t, n, e, i) { if (i) Tu(t, e, ["ng-version", QO.full]); else { const { attrs: o, classes: r } = function LA(t) { const n = [], e = []; let i = 1, o = 2; for (; i < t.length;) { let r = t[i]; if ("string" == typeof r) 2 === o ? "" !== r && n.push(r, t[++i]) : 8 === o && e.push(r); else { if (!bn(o)) break; o = r } i++ } return { attrs: n, classes: e } }(n.selectors[0]); o && Tu(t, e, o), r && r.length > 0 && Jv(t, e, r.join(" ")) } }(h, Me, p, i), void 0 !== e && function ck(t, n, e) { const i = t.projection = []; for (let o = 0; o < n.length; o++) { const r = e[o]; i.push(null != r ? Array.from(r) : null) } }(ve, this.ngContentSelectors, e), $ = function ak(t, n, e, i, o, r) { const s = rt(), a = o[R], l = Pt(s, o); ty(a, o, s, e, null, i); for (let d = 0; d < e.length; d++)ht(Zi(o, a, s.directiveStart + d, s), o); ny(a, o, s), l && ht(l, o); const c = Zi(o, a, s.directiveStart + s.componentOffset, s); if (t[Be] = o[Be] = c, null !== r) for (const d of r) d(c, n); return Jh(a, s, t), c }(nu, Me, ct, Jt, O, [dk]), df(M, O, null) } finally { Wu() } return new ik(this.componentType, $, sr(ve, O), O, ve) } } class ik extends GO { constructor(n, e, i, o, r) { super(), this.location = i, this._rootLView = o, this._tNode = r, this.previousInputValues = null, this.instance = e, this.hostView = this.changeDetectorRef = new ek(o), this.componentType = n } setInput(n, e) { const i = this._tNode.inputs; let o; if (null !== i && (o = i[n])) { if (this.previousInputValues ??= new Map, this.previousInputValues.has(n) && Object.is(this.previousInputValues.get(n), e)) return; const r = this._rootLView; cf(r[R], r, o, n, e), this.previousInputValues.set(n, e), Vs($t(this._tNode.index, r)) } } get injector() { return new xt(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(n) { this.hostView.onDestroy(n) } } function dk() { const t = rt(); wl(D()[R], t) } function K(t) { let n = function vy(t) { return Object.getPrototypeOf(t.prototype).constructor }(t.type), e = !0; const i = [t]; for (; n;) { let o; if (wn(t)) o = n.\u0275cmp || n.\u0275dir; else { if (n.\u0275cmp) throw new b(903, !1); o = n.\u0275dir } if (o) { if (e) { i.push(o); const s = t; s.inputs = lc(t.inputs), s.inputTransforms = lc(t.inputTransforms), s.declaredInputs = lc(t.declaredInputs), s.outputs = lc(t.outputs); const a = o.hostBindings; a && pk(t, a); const l = o.viewQuery, c = o.contentQueries; if (l && hk(t, l), c && fk(t, c), rl(t.inputs, o.inputs), rl(t.declaredInputs, o.declaredInputs), rl(t.outputs, o.outputs), null !== o.inputTransforms && (null === s.inputTransforms && (s.inputTransforms = {}), rl(s.inputTransforms, o.inputTransforms)), wn(o) && o.data.animation) { const d = t.data; d.animation = (d.animation || []).concat(o.data.animation) } } const r = o.features; if (r) for (let s = 0; s < r.length; s++) { const a = r[s]; a && a.ngInherit && a(t), a === K && (e = !1) } } n = Object.getPrototypeOf(n) } !function uk(t) { let n = 0, e = null; for (let i = t.length - 1; i >= 0; i--) { const o = t[i]; o.hostVars = n += o.hostVars, o.hostAttrs = as(o.hostAttrs, e = as(e, o.hostAttrs)) } }(i) } function lc(t) { return t === An ? {} : t === ce ? [] : t } function hk(t, n) { const e = t.viewQuery; t.viewQuery = e ? (i, o) => { n(i, o), e(i, o) } : n } function fk(t, n) { const e = t.contentQueries; t.contentQueries = e ? (i, o, r) => { n(i, o, r), e(i, o, r) } : n } function pk(t, n) { const e = t.hostBindings; t.hostBindings = e ? (i, o) => { n(i, o), e(i, o) } : n } function xy(t) { const n = t.inputConfig, e = {}; for (const i in n) if (n.hasOwnProperty(i)) { const o = n[i]; Array.isArray(o) && o[2] && (e[i] = o[2]) } t.inputTransforms = e } function cc(t) { return !!uf(t) && (Array.isArray(t) || !(t instanceof Map) && Symbol.iterator in t) } function uf(t) { return null !== t && ("function" == typeof t || "object" == typeof t) } function pt(t, n, e) { return !Object.is(t[n], e) && (t[n] = e, !0) } function Ke(t, n, e, i) { const o = D(); return pt(o, jo(), n) && (re(), Nn(Te(), o, t, n, e, i)), Ke } function ur(t, n, e, i) { return pt(t, jo(), e) ? n + G(e) + i : W } function hr(t, n, e, i, o, r) { const a = function no(t, n, e, i) { const o = pt(t, n, e); return pt(t, n + 1, i) || o }(t, function Jn() { return j.lFrame.bindingIndex }(), e, o); return ei(2), a ? n + G(e) + i + G(o) + r : W } function Q(t, n, e, i, o, r, s, a) { const l = D(), c = re(), d = t + ee, u = c.firstCreatePass ? function Bk(t, n, e, i, o, r, s, a, l) { const c = n.consts, d = cr(n, t, 4, s || null, yi(c, a)); rf(n, e, d, yi(c, l)), wl(n, d); const u = d.tView = nf(2, d, i, o, r, n.directiveRegistry, n.pipeRegistry, null, n.schemas, c, null); return null !== n.queries && (n.queries.template(n, d), u.queries = n.queries.embeddedTView(d)), d }(d, c, l, n, e, i, o, r, s) : c.data[d]; kn(u, !1); const h = Py(c, l, u, t); yl() && jl(c, l, h, u), ht(h, l), rc(l, l[d] = oy(h, l, h, u)), gl(u) && ef(c, l, u), null != s && tf(l, u, a) } let Py = function Ny(t, n, e, i) { return wi(!0), n[q].createComment("") }; function Ws(t) { return function Vo(t, n) { return t[n] }(function xT() { return j.lFrame.contextLView }(), ee + t) } function k(t, n, e) { const i = D(); return pt(i, jo(), n) && Yt(re(), Te(), i, t, n, i[q], e, !1), k } function _f(t, n, e, i, o) { const s = o ? "class" : "style"; cf(t, e, n.inputs[s], s, i) } function x(t, n, e, i) { const o = D(), r = re(), s = ee + t, a = o[q], l = r.firstCreatePass ? function zk(t, n, e, i, o, r) { const s = n.consts, l = cr(n, t, 2, i, yi(s, o)); return rf(n, e, l, yi(s, r)), null !== l.attrs && sc(l, l.attrs, !1), null !== l.mergedAttrs && sc(l, l.mergedAttrs, !0), null !== n.queries && n.queries.elementStart(n, l), l }(s, r, o, n, e, i) : r.data[s], c = Ly(r, o, l, a, n, t); o[s] = c; const d = gl(l); return kn(l, !0), eb(a, c, l), 32 != (32 & l.flags) && yl() && jl(r, o, c, l), 0 === function pT() { return j.lFrame.elementDepthCount }() && ht(c, o), function mT() { j.lFrame.elementDepthCount++ }(), d && (ef(r, o, l), Jh(r, l, o)), null !== i && tf(o, l), x } function y() { let t = rt(); Hu() ? Uu() : (t = t.parent, kn(t, !1)); const n = t; (function _T(t) { return j.skipHydrationRootTNode === t })(n) && function wT() { j.skipHydrationRootTNode = null }(), function gT() { j.lFrame.elementDepthCount-- }(); const e = re(); return e.firstCreatePass && (wl(e, t), Ou(t) && e.queries.elementEnd(t)), null != n.classesWithoutHost && function NT(t) { return 0 != (8 & t.flags) }(n) && _f(e, n, D(), n.classesWithoutHost, !0), null != n.stylesWithoutHost && function LT(t) { return 0 != (16 & t.flags) }(n) && _f(e, n, D(), n.stylesWithoutHost, !1), y } function U(t, n, e, i) { return x(t, n, e, i), y(), U } let Ly = (t, n, e, i, o, r) => (wi(!0), Ll(i, o, function nv() { return j.lFrame.currentNamespace }())); function Ys() { return D() } function Zs(t) { return !!t && "function" == typeof t.then } function jy(t) { return !!t && "function" == typeof t.subscribe } function se(t, n, e, i) { const o = D(), r = re(), s = rt(); return function Uy(t, n, e, i, o, r, s) { const a = gl(i), c = t.firstCreatePass && ay(t), d = n[Be], u = sy(n); let h = !0; if (3 & i.type || s) { const m = Pt(i, n), _ = s ? s(m) : m, C = u.length, v = s ? O => s(De(O[i.index])) : i.index; let M = null; if (!s && a && (M = function Zk(t, n, e, i) { const o = t.cleanup; if (null != o) for (let r = 0; r < o.length - 1; r += 2) { const s = o[r]; if (s === e && o[r + 1] === i) { const a = n[Oo], l = o[r + 2]; return a.length > l ? a[l] : null } "string" == typeof s && (r += 2) } return null }(t, n, o, i.index)), null !== M) (M.__ngLastListenerFn__ || M).__ngNextListenerFn__ = r, M.__ngLastListenerFn__ = r, h = !1; else { r = $y(i, n, d, r, !1); const O = e.listen(_, o, r); u.push(r, O), c && c.push(o, v, C, C + 1) } } else r = $y(i, n, d, r, !1); const f = i.outputs; let p; if (h && null !== f && (p = f[o])) { const m = p.length; if (m) for (let _ = 0; _ < m; _ += 2) { const $ = n[p[_]][p[_ + 1]].subscribe(r), ve = u.length; u.push(r, $), c && c.push(o, i.index, ve, -(ve + 1)) } } }(r, o, o[q], s, t, n, i), se } function zy(t, n, e, i) { try { return On(6, n, e), !1 !== e(i) } catch (o) { return cy(t, o), !1 } finally { On(7, n, e) } } function $y(t, n, e, i, o) { return function r(s) { if (s === Function) return i; Vs(t.componentOffset > -1 ? $t(t.index, n) : n); let l = zy(n, e, i, s), c = r.__ngNextListenerFn__; for (; c;)l = zy(n, e, c, s) && l, c = c.__ngNextListenerFn__; return o && !1 === l && s.preventDefault(), l } } function Le(t = 1) { return function MT(t) { return (j.lFrame.contextLView = function IT(t, n) { for (; t > 0;)n = n[Fo], t--; return n }(t, j.lFrame.contextLView))[Be] }(t) } function Xk(t, n) { let e = null; const i = function RA(t) { const n = t.attrs; if (null != n) { const e = n.indexOf(5); if (!(1 & e)) return n[e + 1] } return null }(t); for (let o = 0; o < n.length; o++) { const r = n[o]; if ("*" !== r) { if (null === i ? d_(t, r, !0) : FA(i, r)) return o } else e = o } return e } function io(t) { const n = D()[je][ut]; if (!n.projection) { const i = n.projection = Ds(t ? t.length : 1, null), o = i.slice(); let r = n.child; for (; null !== r;) { const s = t ? Xk(r, t) : 0; null !== s && (o[s] ? o[s].projectionNext = r : i[s] = r, o[s] = r), r = r.next } } } function mt(t, n = 0, e) { const i = D(), o = re(), r = cr(o, ee + t, 16, null, e || null); null === r.projection && (r.projection = n), Uu(), (!i[Qn] || Bo()) && 32 != (32 & r.flags) && function qR(t, n, e) { Qv(n[q], 0, n, e, mh(t, e, n), qv(e.parent || n[ut], e, n)) }(o, i, r) } function br(t, n, e) { return yr(t, "", n, "", e), br } function yr(t, n, e, i, o) { const r = D(), s = ur(r, n, e, i); return s !== W && Yt(re(), Te(), r, t, s, r[q], o, !1), yr } function pc(t, n) { return t << 17 | n << 2 } function Di(t) { return t >> 17 & 32767 } function yf(t) { return 2 | t } function oo(t) { return (131068 & t) >> 2 } function wf(t, n) { return -131069 & t | n << 2 } function xf(t) { return 1 | t } function Jy(t, n, e, i, o) { const r = t[e + 1], s = null === n; let a = i ? Di(r) : oo(r), l = !1; for (; 0 !== a && (!1 === l || s);) { const d = t[a + 1]; nF(t[a], n) && (l = !0, t[a + 1] = i ? xf(d) : yf(d)), a = i ? Di(d) : oo(d) } l && (t[e + 1] = i ? yf(r) : xf(r)) } function nF(t, n) { return null === t || null == n || (Array.isArray(t) ? t[1] : t) === n || !(!Array.isArray(t) || "string" != typeof n) && Zo(t, n) >= 0 } const Qe = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }; function e0(t) { return t.substring(Qe.key, Qe.keyEnd) } function t0(t, n) { const e = Qe.textEnd; return e === n ? -1 : (n = Qe.keyEnd = function sF(t, n, e) { for (; n < e && t.charCodeAt(n) > 32;)n++; return n }(t, Qe.key = n, e), wr(t, n, e)) } function wr(t, n, e) { for (; n < e && t.charCodeAt(n) <= 32;)n++; return n } function Je(t, n) { return function xn(t, n, e, i) { const o = D(), r = re(), s = ei(2); r.firstUpdatePass && c0(r, t, s, i), n !== W && pt(o, s, n) && u0(r, r.data[wt()], o, o[q], t, o[s + 1] = function vF(t, n) { return null == t || "" === t || ("string" == typeof n ? t += n : "object" == typeof t && (t = Ze(qt(t)))), t }(n, e), i, s) }(t, n, null, !0), Je } function Bn(t, n) { for (let e = function oF(t) { return function o0(t) { Qe.key = 0, Qe.keyEnd = 0, Qe.value = 0, Qe.valueEnd = 0, Qe.textEnd = t.length }(t), t0(t, wr(t, 0, Qe.textEnd)) }(n); e >= 0; e = t0(n, e))Gt(t, e0(n), !0) } function l0(t, n) { return n >= t.expandoStartIndex } function c0(t, n, e, i) { const o = t.data; if (null === o[e + 1]) { const r = o[wt()], s = l0(t, e); f0(r, i) && null === n && !s && (n = !1), n = function uF(t, n, e, i) { const o = function $u(t) { const n = j.lFrame.currentDirectiveIndex; return -1 === n ? null : t[n] }(t); let r = i ? n.residualClasses : n.residualStyles; if (null === o) 0 === (i ? n.classBindings : n.styleBindings) && (e = Xs(e = Cf(null, t, n, e, i), n.attrs, i), r = null); else { const s = n.directiveStylingLast; if (-1 === s || t[s] !== o) if (e = Cf(o, t, n, e, i), null === r) { let l = function hF(t, n, e) { const i = e ? n.classBindings : n.styleBindings; if (0 !== oo(i)) return t[Di(i)] }(t, n, i); void 0 !== l && Array.isArray(l) && (l = Cf(null, t, n, l[1], i), l = Xs(l, n.attrs, i), function fF(t, n, e, i) { t[Di(e ? n.classBindings : n.styleBindings)] = i }(t, n, i, l)) } else r = function pF(t, n, e) { let i; const o = n.directiveEnd; for (let r = 1 + n.directiveStylingLast; r < o; r++)i = Xs(i, t[r].hostAttrs, e); return Xs(i, n.attrs, e) }(t, n, i) } return void 0 !== r && (i ? n.residualClasses = r : n.residualStyles = r), e }(o, r, n, i), function eF(t, n, e, i, o, r) { let s = r ? n.classBindings : n.styleBindings, a = Di(s), l = oo(s); t[i] = e; let d, c = !1; if (Array.isArray(e) ? (d = e[1], (null === d || Zo(e, d) > 0) && (c = !0)) : d = e, o) if (0 !== l) { const h = Di(t[a + 1]); t[i + 1] = pc(h, a), 0 !== h && (t[h + 1] = wf(t[h + 1], i)), t[a + 1] = function Qk(t, n) { return 131071 & t | n << 17 }(t[a + 1], i) } else t[i + 1] = pc(a, 0), 0 !== a && (t[a + 1] = wf(t[a + 1], i)), a = i; else t[i + 1] = pc(l, 0), 0 === a ? a = i : t[l + 1] = wf(t[l + 1], i), l = i; c && (t[i + 1] = yf(t[i + 1])), Jy(t, d, i, !0), Jy(t, d, i, !1), function tF(t, n, e, i, o) { const r = o ? t.residualClasses : t.residualStyles; null != r && "string" == typeof n && Zo(r, n) >= 0 && (e[i + 1] = xf(e[i + 1])) }(n, d, t, i, r), s = pc(a, l), r ? n.classBindings = s : n.styleBindings = s }(o, r, n, e, s, i) } } function Cf(t, n, e, i, o) { let r = null; const s = e.directiveEnd; let a = e.directiveStylingLast; for (-1 === a ? a = e.directiveStart : a++; a < s && (r = n[a], i = Xs(i, r.hostAttrs, o), r !== t);)a++; return null !== t && (e.directiveStylingLast = a), i } function Xs(t, n, e) { const i = e ? 1 : 2; let o = -1; if (null !== n) for (let r = 0; r < n.length; r++) { const s = n[r]; "number" == typeof s ? o = s : o === i && (Array.isArray(t) || (t = void 0 === t ? [] : ["", t]), Gt(t, s, !!e || n[++r])) } return void 0 === t ? null : t } function u0(t, n, e, i, o, r, s, a) { if (!(3 & n.type)) return; const l = t.data, c = l[a + 1], d = function Jk(t) { return 1 == (1 & t) }(c) ? h0(l, n, e, o, oo(c), s) : void 0; mc(d) || (mc(r) || function Kk(t) { return 2 == (2 & t) }(c) && (r = h0(l, null, e, o, a, s)), function YR(t, n, e, i, o) { if (n) o ? t.addClass(e, i) : t.removeClass(e, i); else { let r = -1 === i.indexOf("-") ? void 0 : xi.DashCase; null == o ? t.removeStyle(e, i, r) : ("string" == typeof o && o.endsWith("!important") && (o = o.slice(0, -10), r |= xi.Important), t.setStyle(e, i, o, r)) } }(i, s, bl(wt(), e), o, r)) } function h0(t, n, e, i, o, r) { const s = null === n; let a; for (; o > 0;) { const l = t[o], c = Array.isArray(l), d = c ? l[1] : l, u = null === d; let h = e[o + 1]; h === W && (h = u ? ce : void 0); let f = u ? nh(h, i) : d === i ? h : void 0; if (c && !mc(f) && (f = nh(l, i)), mc(f) && (a = f, s)) return a; const p = t[o + 1]; o = s ? Di(p) : oo(p) } if (null !== n) { let l = r ? n.residualClasses : n.residualStyles; null != l && (a = nh(l, i)) } return a } function mc(t) { return void 0 !== t } function f0(t, n) { return 0 != (t.flags & (n ? 8 : 16)) } function A(t, n = "") { const e = D(), i = re(), o = t + ee, r = i.firstCreatePass ? cr(i, o, 1, n, null) : i.data[o], s = p0(i, e, r, n, t); e[o] = s, yl() && jl(i, e, s, r), kn(r, !1) } let p0 = (t, n, e, i, o) => (wi(!0), function Nl(t, n) { return t.createText(n) }(n[q], i)); function Zt(t) { return ln("", t, ""), Zt } function ln(t, n, e) { const i = D(), o = ur(i, t, n, e); return o !== W && oi(i, wt(), o), ln } function Df(t, n, e, i, o) { const r = D(), s = hr(r, t, n, e, i, o); return s !== W && oi(r, wt(), s), Df } function Ef(t, n, e) { !function Cn(t, n, e, i) { const o = re(), r = ei(2); o.firstUpdatePass && c0(o, null, r, i); const s = D(); if (e !== W && pt(s, r, e)) { const a = o.data[wt()]; if (f0(a, i) && !l0(o, r)) { let l = i ? a.classesWithoutHost : a.stylesWithoutHost; null !== l && (e = gu(l, e || "")), _f(o, a, s, e, i) } else !function _F(t, n, e, i, o, r, s, a) { o === W && (o = ce); let l = 0, c = 0, d = 0 < o.length ? o[0] : null, u = 0 < r.length ? r[0] : null; for (; null !== d || null !== u;) { const h = l < o.length ? o[l + 1] : void 0, f = c < r.length ? r[c + 1] : void 0; let m, p = null; d === u ? (l += 2, c += 2, h !== f && (p = u, m = f)) : null === u || null !== d && d < u ? (l += 2, p = d) : (c += 2, p = u, m = f), null !== p && u0(t, n, e, i, p, m, s, a), d = l < o.length ? o[l] : null, u = c < r.length ? r[c] : null } }(o, a, s, s[q], s[r + 1], s[r + 1] = function mF(t, n, e) { if (null == e || "" === e) return ce; const i = [], o = qt(e); if (Array.isArray(o)) for (let r = 0; r < o.length; r++)t(i, o[r], !0); else if ("object" == typeof o) for (const r in o) o.hasOwnProperty(r) && t(i, r, o[r]); else "string" == typeof o && n(i, o); return i }(t, n, e), i, r) } }(Gt, Bn, ur(D(), t, n, e), !0) } function Ks(t, n, e) { const i = D(); return pt(i, jo(), n) && Yt(re(), Te(), i, t, n, i[q], e, !0), Ks } const Cr = "en-US"; let F0 = Cr; function If(t, n, e, i, o) { if (t = H(t), Array.isArray(t)) for (let r = 0; r < t.length; r++)If(t[r], n, e, i, o); else { const r = re(), s = D(), a = rt(); let l = Ji(t) ? t : H(t.provide); const c = bb(t), d = 1048575 & a.providerIndexes, u = a.directiveStart, h = a.providerIndexes >> 20; if (Ji(t) || !t.multi) { const f = new bs(c, o, g), p = Tf(l, n, o ? d : d + h, u); -1 === p ? (Ju(El(a, s), r, l), Af(r, t, n.length), n.push(l), a.directiveStart++, a.directiveEnd++, o && (a.providerIndexes += 1048576), e.push(f), s.push(f)) : (e[p] = f, s[p] = f) } else { const f = Tf(l, n, d + h, u), p = Tf(l, n, d, d + h), _ = p >= 0 && e[p]; if (o && !_ || !o && !(f >= 0 && e[f])) { Ju(El(a, s), r, l); const C = function VP(t, n, e, i, o) { const r = new bs(t, e, g); return r.multi = [], r.index = n, r.componentProviders = 0, rw(r, o, i && !e), r }(o ? LP : NP, e.length, o, i, c); !o && _ && (e[p].providerFactory = C), Af(r, t, n.length, 0), n.push(l), a.directiveStart++, a.directiveEnd++, o && (a.providerIndexes += 1048576), e.push(C), s.push(C) } else Af(r, t, f > -1 ? f : p, rw(e[o ? p : f], c, !o && i)); !o && i && _ && e[p].componentProviders++ } } } function Af(t, n, e, i) { const o = Ji(n), r = function IO(t) { return !!t.useClass }(n); if (o || r) { const l = (r ? H(n.useClass) : n).prototype.ngOnDestroy; if (l) { const c = t.destroyHooks || (t.destroyHooks = []); if (!o && n.multi) { const d = c.indexOf(e); -1 === d ? c.push(e, [i, l]) : c[d + 1].push(i, l) } else c.push(e, l) } } } function rw(t, n, e) { return e && t.componentProviders++, t.multi.push(n) - 1 } function Tf(t, n, e, i) { for (let o = e; o < i; o++)if (n[o] === t) return o; return -1 } function NP(t, n, e, i) { return Rf(this.multi, []) } function LP(t, n, e, i) { const o = this.multi; let r; if (this.providerFactory) { const s = this.providerFactory.componentProviders, a = Zi(e, e[R], this.providerFactory.index, i); r = a.slice(0, s), Rf(o, r); for (let l = s; l < a.length; l++)r.push(a[l]) } else r = [], Rf(o, r); return r } function Rf(t, n) { for (let e = 0; e < t.length; e++)n.push((0, t[e])()); return n } function ge(t, n = []) { return e => { e.providersResolver = (i, o) => function PP(t, n, e) { const i = re(); if (i.firstCreatePass) { const o = wn(t); If(e, i.data, i.blueprint, o, !0), If(n, i.data, i.blueprint, o, !1) } }(i, o ? o(t) : t, n) } } class so { } class sw { } class Of extends so { constructor(n, e, i) { super(), this._parent = e, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new gy(this); const o = zt(n); this._bootstrapComponents = ii(o.bootstrap), this._r3Injector = Tb(n, e, [{ provide: so, useValue: this }, { provide: Ns, useValue: this.componentFactoryResolver }, ...i], Ze(n), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(n) } get injector() { return this._r3Injector } destroy() { const n = this._r3Injector; !n.destroyed && n.destroy(), this.destroyCbs.forEach(e => e()), this.destroyCbs = null } onDestroy(n) { this.destroyCbs.push(n) } } class kf extends sw { constructor(n) { super(), this.moduleType = n } create(n) { return new Of(this.moduleType, n, []) } } class aw extends so { constructor(n) { super(), this.componentFactoryResolver = new gy(this), this.instance = null; const e = new nr([...n.providers, { provide: so, useValue: this }, { provide: Ns, useValue: this.componentFactoryResolver }], n.parent || Yl(), n.debugName, new Set(["environment"])); this.injector = e, n.runEnvironmentInitializers && e.resolveInjectorInitializers() } destroy() { this.injector.destroy() } onDestroy(n) { this.injector.onDestroy(n) } } function Ff(t, n, e = null) { return new aw({ providers: t, parent: n, debugName: e, runEnvironmentInitializers: !0 }).injector } let HP = (() => { class t { constructor(e) { this._injector = e, this.cachedInjectors = new Map } getOrCreateStandaloneInjector(e) { if (!e.standalone) return null; if (!this.cachedInjectors.has(e)) { const i = mb(0, e.type), o = i.length > 0 ? Ff([i], this._injector, `Standalone[${e.type.name}]`) : null; this.cachedInjectors.set(e, o) } return this.cachedInjectors.get(e) } ngOnDestroy() { try { for (const e of this.cachedInjectors.values()) null !== e && e.destroy() } finally { this.cachedInjectors.clear() } } static #e = this.\u0275prov = I({ token: t, providedIn: "environment", factory: () => new t(w(Wt)) }) } return t })(); function lw(t) { t.getStandaloneInjector = n => n.get(HP).getOrCreateStandaloneInjector(t) } function fN() { return this._results[Symbol.iterator]() } class ra { static #e = Symbol.iterator; get changes() { return this._changes || (this._changes = new ue) } constructor(n = !1) { this._emitDistinctChangesOnly = n, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const e = ra.prototype; e[Symbol.iterator] || (e[Symbol.iterator] = fN) } get(n) { return this._results[n] } map(n) { return this._results.map(n) } filter(n) { return this._results.filter(n) } find(n) { return this._results.find(n) } reduce(n, e) { return this._results.reduce(n, e) } forEach(n) { this._results.forEach(n) } some(n) { return this._results.some(n) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(n, e) { const i = this; i.dirty = !1; const o = function rn(t) { return t.flat(Number.POSITIVE_INFINITY) }(n); (this._changesDetected = !function KT(t, n, e) { if (t.length !== n.length) return !1; for (let i = 0; i < t.length; i++) { let o = t[i], r = n[i]; if (e && (o = e(o), r = e(r)), r !== o) return !1 } return !0 }(i._results, o, e)) && (i._results = o, i.length = o.length, i.last = o[this.length - 1], i.first = o[0]) } notifyOnChanges() { this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } function mN(t, n, e, i = !0) { const o = n[R]; if (function jR(t, n, e, i) { const o = it + i, r = e.length; i > 0 && (e[o - 1][yn] = n), i < r - it ? (n[yn] = e[o], _v(e, it + i, n)) : (e.push(n), n[yn] = null), n[Ae] = e; const s = n[ds]; null !== s && e !== s && function HR(t, n) { const e = t[No]; n[je] !== n[Ae][Ae][je] && (t[__] = !0), null === e ? t[No] = [n] : e.push(n) }(s, n); const a = n[Tn]; null !== a && a.insertView(t), n[Y] |= 128 }(o, n, t, e), i) { const r = _h(e, t), s = n[q], a = Bl(s, t[Rn]); null !== a && function LR(t, n, e, i, o, r) { i[Ne] = o, i[ut] = n, Ts(t, i, e, 1, o, r) }(o, t[ut], s, n, a, r) } } let jn = (() => { class t { static #e = this.__NG_ELEMENT_ID__ = vN } return t })(); const gN = jn, _N = class extends gN { constructor(n, e, i) { super(), this._declarationLView = n, this._declarationTContainer = e, this.elementRef = i } get ssrId() { return this._declarationTContainer.tView?.ssrId || null } createEmbeddedView(n, e) { return this.createEmbeddedViewImpl(n, e) } createEmbeddedViewImpl(n, e, i) { const o = function pN(t, n, e, i) { const o = n.tView, a = oc(t, o, e, 4096 & t[Y] ? 4096 : 16, null, n, null, null, null, i?.injector ?? null, i?.hydrationInfo ?? null); a[ds] = t[n.index]; const c = t[Tn]; return null !== c && (a[Tn] = c.createEmbeddedView(o)), df(o, a, e), a }(this._declarationLView, this._declarationTContainer, n, { injector: e, hydrationInfo: i }); return new Hs(o) } }; function vN() { return yc(rt(), D()) } function yc(t, n) { return 4 & t.type ? new _N(n, t, sr(t, n)) : null } let cn = (() => { class t { static #e = this.__NG_ELEMENT_ID__ = DN } return t })(); function DN() { return Sw(rt(), D()) } const EN = cn, Dw = class extends EN { constructor(n, e, i) { super(), this._lContainer = n, this._hostTNode = e, this._hostLView = i } get element() { return sr(this._hostTNode, this._hostLView) } get injector() { return new xt(this._hostTNode, this._hostLView) } get parentInjector() { const n = Sl(this._hostTNode, this._hostLView); if (Xu(n)) { const e = ws(n, this._hostLView), i = ys(n); return new xt(e[R].data[i + 8], e) } return new xt(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(n) { const e = Ew(this._lContainer); return null !== e && e[n] || null } get length() { return this._lContainer.length - it } createEmbeddedView(n, e, i) { let o, r; "number" == typeof i ? o = i : null != i && (o = i.index, r = i.injector); const a = n.createEmbeddedViewImpl(e || {}, r, null); return this.insertImpl(a, o, false), a } createComponent(n, e, i, o, r) { const s = n && !function Cs(t) { return "function" == typeof t }(n); let a; if (s) a = e; else { const m = e || {}; a = m.index, i = m.injector, o = m.projectableNodes, r = m.environmentInjector || m.ngModuleRef } const l = s ? n : new Us(oe(n)), c = i || this.parentInjector; if (!r && null == l.ngModule) { const _ = (s ? c : this.parentInjector).get(Wt, null); _ && (r = _) } oe(l.componentType ?? {}); const f = l.create(c, o, null, r); return this.insertImpl(f.hostView, a, false), f } insert(n, e) { return this.insertImpl(n, e, !1) } insertImpl(n, e, i) { const o = n._lView; if (function uT(t) { return bt(t[Ae]) }(o)) { const l = this.indexOf(n); if (-1 !== l) this.detach(l); else { const c = o[Ae], d = new Dw(c, c[ut], c[Ae]); d.detach(d.indexOf(n)) } } const s = this._adjustIndex(e), a = this._lContainer; return mN(a, o, s, !i), n.attachToViewContainerRef(), _v(Nf(a), s, n), n } move(n, e) { return this.insert(n, e) } indexOf(n) { const e = Ew(this._lContainer); return null !== e ? e.indexOf(n) : -1 } remove(n) { const e = this._adjustIndex(n, -1), i = Vl(this._lContainer, e); i && (Il(Nf(this._lContainer), e), fh(i[R], i)) } detach(n) { const e = this._adjustIndex(n, -1), i = Vl(this._lContainer, e); return i && null != Il(Nf(this._lContainer), e) ? new Hs(i) : null } _adjustIndex(n, e = 0) { return n ?? this.length + e } }; function Ew(t) { return t[8] } function Nf(t) { return t[8] || (t[8] = []) } function Sw(t, n) { let e; const i = n[t.index]; return bt(i) ? e = i : (e = oy(i, n, null, t), n[t.index] = e, rc(n, e)), Mw(e, n, t, i), new Dw(e, t, n) } let Mw = function Iw(t, n, e, i) { if (t[Rn]) return; let o; o = 8 & e.type ? De(i) : function SN(t, n) { const e = t[q], i = e.createComment(""), o = Pt(n, t); return Ki(e, Bl(e, o), i, function GR(t, n) { return t.nextSibling(n) }(e, o), !1), i }(n, e), t[Rn] = o }; class Lf { constructor(n) { this.queryList = n, this.matches = null } clone() { return new Lf(this.queryList) } setDirty() { this.queryList.setDirty() } } class Vf { constructor(n = []) { this.queries = n } createEmbeddedView(n) { const e = n.queries; if (null !== e) { const i = null !== n.contentQueries ? n.contentQueries[0] : e.length, o = []; for (let r = 0; r < i; r++) { const s = e.getByIndex(r); o.push(this.queries[s.indexInDeclarationView].clone()) } return new Vf(o) } return null } insertView(n) { this.dirtyQueriesWithMatches(n) } detachView(n) { this.dirtyQueriesWithMatches(n) } dirtyQueriesWithMatches(n) { for (let e = 0; e < this.queries.length; e++)null !== kw(n, e).matches && this.queries[e].setDirty() } } class Aw { constructor(n, e, i = null) { this.predicate = n, this.flags = e, this.read = i } } class Bf { constructor(n = []) { this.queries = n } elementStart(n, e) { for (let i = 0; i < this.queries.length; i++)this.queries[i].elementStart(n, e) } elementEnd(n) { for (let e = 0; e < this.queries.length; e++)this.queries[e].elementEnd(n) } embeddedTView(n) { let e = null; for (let i = 0; i < this.length; i++) { const o = null !== e ? e.length : 0, r = this.getByIndex(i).embeddedTView(n, o); r && (r.indexInDeclarationView = i, null !== e ? e.push(r) : e = [r]) } return null !== e ? new Bf(e) : null } template(n, e) { for (let i = 0; i < this.queries.length; i++)this.queries[i].template(n, e) } getByIndex(n) { return this.queries[n] } get length() { return this.queries.length } track(n) { this.queries.push(n) } } class jf { constructor(n, e = -1) { this.metadata = n, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = e } elementStart(n, e) { this.isApplyingToNode(e) && this.matchTNode(n, e) } elementEnd(n) { this._declarationNodeIndex === n.index && (this._appliesToNextNode = !1) } template(n, e) { this.elementStart(n, e) } embeddedTView(n, e) { return this.isApplyingToNode(n) ? (this.crossesNgTemplate = !0, this.addMatch(-n.index, e), new jf(this.metadata)) : null } isApplyingToNode(n) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const e = this._declarationNodeIndex; let i = n.parent; for (; null !== i && 8 & i.type && i.index !== e;)i = i.parent; return e === (null !== i ? i.index : -1) } return this._appliesToNextNode } matchTNode(n, e) { const i = this.metadata.predicate; if (Array.isArray(i)) for (let o = 0; o < i.length; o++) { const r = i[o]; this.matchTNodeWithReadOption(n, e, AN(e, r)), this.matchTNodeWithReadOption(n, e, Ml(e, n, r, !1, !1)) } else i === jn ? 4 & e.type && this.matchTNodeWithReadOption(n, e, -1) : this.matchTNodeWithReadOption(n, e, Ml(e, n, i, !1, !1)) } matchTNodeWithReadOption(n, e, i) { if (null !== i) { const o = this.metadata.read; if (null !== o) if (o === ye || o === cn || o === jn && 4 & e.type) this.addMatch(e.index, -2); else { const r = Ml(e, n, o, !1, !1); null !== r && this.addMatch(e.index, r) } else this.addMatch(e.index, i) } } addMatch(n, e) { null === this.matches ? this.matches = [n, e] : this.matches.push(n, e) } } function AN(t, n) { const e = t.localNames; if (null !== e) for (let i = 0; i < e.length; i += 2)if (e[i] === n) return e[i + 1]; return null } function RN(t, n, e, i) { return -1 === e ? function TN(t, n) { return 11 & t.type ? sr(t, n) : 4 & t.type ? yc(t, n) : null }(n, t) : -2 === e ? function ON(t, n, e) { return e === ye ? sr(n, t) : e === jn ? yc(n, t) : e === cn ? Sw(n, t) : void 0 }(t, n, i) : Zi(t, t[R], e, n) } function Tw(t, n, e, i) { const o = n[Tn].queries[i]; if (null === o.matches) { const r = t.data, s = e.matches, a = []; for (let l = 0; l < s.length; l += 2) { const c = s[l]; a.push(c < 0 ? null : RN(n, r[c], s[l + 1], e.metadata.read)) } o.matches = a } return o.matches } function Hf(t, n, e, i) { const o = t.queries.getByIndex(e), r = o.matches; if (null !== r) { const s = Tw(t, n, o, e); for (let a = 0; a < r.length; a += 2) { const l = r[a]; if (l > 0) i.push(s[a / 2]); else { const c = r[a + 1], d = n[-l]; for (let u = it; u < d.length; u++) { const h = d[u]; h[ds] === h[Ae] && Hf(h[R], h, c, i) } if (null !== d[No]) { const u = d[No]; for (let h = 0; h < u.length; h++) { const f = u[h]; Hf(f[R], f, c, i) } } } } } return i } function Re(t) { const n = D(), e = re(), i = X_(); Gu(i + 1); const o = kw(e, i); if (t.dirty && function cT(t) { return 4 == (4 & t[Y]) }(n) === (2 == (2 & o.metadata.flags))) { if (null === o.matches) t.reset([]); else { const r = o.crossesNgTemplate ? Hf(e, n, i, []) : Tw(e, n, o, i); t.reset(r, ZO), t.notifyOnChanges() } return !0 } return !1 } function dn(t, n, e) { const i = re(); i.firstCreatePass && (Ow(i, new Aw(t, n, e), -1), 2 == (2 & n) && (i.staticViewQueries = !0)), Rw(i, D(), n) } function un(t, n, e, i) { const o = re(); if (o.firstCreatePass) { const r = rt(); Ow(o, new Aw(n, e, i), r.index), function FN(t, n) { const e = t.contentQueries || (t.contentQueries = []); n !== (e.length ? e[e.length - 1] : -1) && e.push(t.queries.length - 1, n) }(o, t), 2 == (2 & e) && (o.staticContentQueries = !0) } Rw(o, D(), e) } function Oe() { return function kN(t, n) { return t[Tn].queries[n].queryList }(D(), X_()) } function Rw(t, n, e) { const i = new ra(4 == (4 & e)); (function A1(t, n, e, i) { const o = sy(n); o.push(e), t.firstCreatePass && ay(t).push(i, o.length - 1) })(t, n, i, i.destroy), null === n[Tn] && (n[Tn] = new Vf), n[Tn].queries.push(new Lf(i)) } function Ow(t, n, e) { null === t.queries && (t.queries = new Bf), t.queries.track(new jf(n, e)) } function kw(t, n) { return t.queries.getByIndex(n) } function Fw(t, n) { return yc(t, n) } const Wf = new E("Application Initializer"); let Yf = (() => { class t { constructor() { this.initialized = !1, this.done = !1, this.donePromise = new Promise((e, i) => { this.resolve = e, this.reject = i }), this.appInits = T(Wf, { optional: !0 }) ?? [] } runInitializers() { if (this.initialized) return; const e = []; for (const o of this.appInits) { const r = o(); if (Zs(r)) e.push(r); else if (jy(r)) { const s = new Promise((a, l) => { r.subscribe({ complete: a, error: l }) }); e.push(s) } } const i = () => { this.done = !0, this.resolve() }; Promise.all(e).then(() => { i() }).catch(o => { this.reject(o) }), 0 === e.length && i(), this.initialized = !0 } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), Kw = (() => { class t { log(e) { console.log(e) } warn(e) { console.warn(e) } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "platform" }) } return t })(); const Hn = new E("LocaleId", { providedIn: "root", factory: () => T(Hn, J.Optional | J.SkipSelf) || function tL() { return typeof $localize < "u" && $localize.locale || Cr }() }); let Cc = (() => { class t { constructor() { this.taskId = 0, this.pendingTasks = new Set, this.hasPendingTasks = new At(!1) } add() { this.hasPendingTasks.next(!0); const e = this.taskId++; return this.pendingTasks.add(e), e } remove(e) { this.pendingTasks.delete(e), 0 === this.pendingTasks.size && this.hasPendingTasks.next(!1) } ngOnDestroy() { this.pendingTasks.clear(), this.hasPendingTasks.next(!1) } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); class oL { constructor(n, e) { this.ngModuleFactory = n, this.componentFactories = e } } let Qw = (() => { class t { compileModuleSync(e) { return new kf(e) } compileModuleAsync(e) { return Promise.resolve(this.compileModuleSync(e)) } compileModuleAndAllComponentsSync(e) { const i = this.compileModuleSync(e), r = ii(zt(e).declarations).reduce((s, a) => { const l = oe(a); return l && s.push(new Us(l)), s }, []); return new oL(i, r) } compileModuleAndAllComponentsAsync(e) { return Promise.resolve(this.compileModuleAndAllComponentsSync(e)) } clearCache() { } clearCacheFor(e) { } getModuleId(e) { } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); const nx = new E(""), Ec = new E(""); let Jf, Kf = (() => { class t { constructor(e, i, o) { this._ngZone = e, this.registry = i, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, Jf || (function SL(t) { Jf = t }(o), o.addToWindow(i)), this._watchAngularEvents(), e.run(() => { this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { z.assertNotInAngularZone(), queueMicrotask(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) queueMicrotask(() => { for (; 0 !== this._callbacks.length;) { let e = this._callbacks.pop(); clearTimeout(e.timeoutId), e.doneCb(this._didWork) } this._didWork = !1 }); else { let e = this.getPendingTasks(); this._callbacks = this._callbacks.filter(i => !i.updateCb || !i.updateCb(e) || (clearTimeout(i.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(e => ({ source: e.source, creationLocation: e.creationLocation, data: e.data })) : [] } addCallback(e, i, o) { let r = -1; i && i > 0 && (r = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== r), e(this._didWork, this.getPendingTasks()) }, i)), this._callbacks.push({ doneCb: e, timeoutId: r, updateCb: o }) } whenStable(e, i, o) { if (o && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(e, i, o), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } registerApplication(e) { this.registry.registerApplication(e, this) } unregisterApplication(e) { this.registry.unregisterApplication(e) } findProviders(e, i, o) { return [] } static #e = this.\u0275fac = function (i) { return new (i || t)(w(z), w(Qf), w(Ec)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })(), Qf = (() => { class t { constructor() { this._applications = new Map } registerApplication(e, i) { this._applications.set(e, i) } unregisterApplication(e) { this._applications.delete(e) } unregisterAllApplications() { this._applications.clear() } getTestability(e) { return this._applications.get(e) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(e, i = !0) { return Jf?.findTestabilityInTree(this, e, i) ?? null } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "platform" }) } return t })(), Ei = null; const ix = new E("AllowMultipleToken"), ep = new E("PlatformDestroyListeners"), tp = new E("appBootstrapListener"); class rx { constructor(n, e) { this.name = n, this.token = e } } function ax(t, n, e = []) { const i = `Platform: ${n}`, o = new E(i); return (r = []) => { let s = np(); if (!s || s.injector.get(ix, !1)) { const a = [...e, ...r, { provide: o, useValue: !0 }]; t ? t(a) : function AL(t) { if (Ei && !Ei.get(ix, !1)) throw new b(400, !1); (function ox() { !function XA(t) { A_ = t }(() => { throw new b(600, !1) }) })(), Ei = t; const n = t.get(cx); (function sx(t) { t.get(yb, null)?.forEach(e => e()) })(t) }(function lx(t = [], n) { return ft.create({ name: n, providers: [{ provide: Ah, useValue: "platform" }, { provide: ep, useValue: new Set([() => Ei = null]) }, ...t] }) }(a, i)) } return function RL(t) { const n = np(); if (!n) throw new b(401, !1); return n }() } } function np() { return Ei?.get(cx) ?? null } let cx = (() => { class t { constructor(e) { this._injector = e, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(e, i) { const o = function OL(t = "zone.js", n) { return "noop" === t ? new u1 : "zone.js" === t ? new z(n) : t }(i?.ngZone, function dx(t) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: t?.eventCoalescing ?? !1, shouldCoalesceRunChangeDetection: t?.runCoalescing ?? !1 } }({ eventCoalescing: i?.ngZoneEventCoalescing, runCoalescing: i?.ngZoneRunCoalescing })); return o.run(() => { const r = function jP(t, n, e) { return new Of(t, n, e) }(e.moduleType, this.injector, function mx(t) { return [{ provide: z, useFactory: t }, { provide: ks, multi: !0, useFactory: () => { const n = T(FL, { optional: !0 }); return () => n.initialize() } }, { provide: px, useFactory: kL }, { provide: Pb, useFactory: Nb }] }(() => o)), s = r.injector.get(sn, null); return o.runOutsideAngular(() => { const a = o.onError.subscribe({ next: l => { s.handleError(l) } }); r.onDestroy(() => { Sc(this._modules, r), a.unsubscribe() }) }), function ux(t, n, e) { try { const i = e(); return Zs(i) ? i.catch(o => { throw n.runOutsideAngular(() => t.handleError(o)), o }) : i } catch (i) { throw n.runOutsideAngular(() => t.handleError(i)), i } }(s, o, () => { const a = r.injector.get(Yf); return a.runInitializers(), a.donePromise.then(() => (function P0(t) { tn(t, "Expected localeId to be defined"), "string" == typeof t && (F0 = t.toLowerCase().replace(/_/g, "-")) }(r.injector.get(Hn, Cr) || Cr), this._moduleDoBootstrap(r), r)) }) }) } bootstrapModule(e, i = []) { const o = hx({}, i); return function ML(t, n, e) { const i = new kf(e); return Promise.resolve(i) }(0, 0, e).then(r => this.bootstrapModuleFactory(r, o)) } _moduleDoBootstrap(e) { const i = e.injector.get(Si); if (e._bootstrapComponents.length > 0) e._bootstrapComponents.forEach(o => i.bootstrap(o)); else { if (!e.instance.ngDoBootstrap) throw new b(-403, !1); e.instance.ngDoBootstrap(i) } this._modules.push(e) } onDestroy(e) { this._destroyListeners.push(e) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new b(404, !1); this._modules.slice().forEach(i => i.destroy()), this._destroyListeners.forEach(i => i()); const e = this._injector.get(ep, null); e && (e.forEach(i => i()), e.clear()), this._destroyed = !0 } get destroyed() { return this._destroyed } static #e = this.\u0275fac = function (i) { return new (i || t)(w(ft)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "platform" }) } return t })(); function hx(t, n) { return Array.isArray(n) ? n.reduce(hx, t) : { ...t, ...n } } let Si = (() => { class t { constructor() { this._bootstrapListeners = [], this._runningTick = !1, this._destroyed = !1, this._destroyListeners = [], this._views = [], this.internalErrorHandler = T(px), this.zoneIsStable = T(Pb), this.componentTypes = [], this.components = [], this.isStable = T(Cc).hasPendingTasks.pipe(Tt(e => e ? N(!1) : this.zoneIsStable), Wg(), ol()), this._injector = T(Wt) } get destroyed() { return this._destroyed } get injector() { return this._injector } bootstrap(e, i) { const o = e instanceof Db; if (!this._injector.get(Yf).done) throw !o && function Ro(t) { const n = oe(t) || nt(t) || vt(t); return null !== n && n.standalone }(e), new b(405, !1); let s; s = o ? e : this._injector.get(Ns).resolveComponentFactory(e), this.componentTypes.push(s.componentType); const a = function IL(t) { return t.isBoundToModule }(s) ? void 0 : this._injector.get(so), c = s.create(ft.NULL, [], i || s.selector, a), d = c.location.nativeElement, u = c.injector.get(nx, null); return u?.registerApplication(d), c.onDestroy(() => { this.detachView(c.hostView), Sc(this.components, c), u?.unregisterApplication(d) }), this._loadComponent(c), c } tick() { if (this._runningTick) throw new b(101, !1); try { this._runningTick = !0; for (let e of this._views) e.detectChanges() } catch (e) { this.internalErrorHandler(e) } finally { this._runningTick = !1 } } attachView(e) { const i = e; this._views.push(i), i.attachToAppRef(this) } detachView(e) { const i = e; Sc(this._views, i), i.detachFromAppRef() } _loadComponent(e) { this.attachView(e.hostView), this.tick(), this.components.push(e); const i = this._injector.get(tp, []); i.push(...this._bootstrapListeners), i.forEach(o => o(e)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(e => e()), this._views.slice().forEach(e => e.destroy()) } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(e) { return this._destroyListeners.push(e), () => Sc(this._destroyListeners, e) } destroy() { if (this._destroyed) throw new b(406, !1); const e = this._injector; e.destroy && !e.destroyed && e.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); function Sc(t, n) { const e = t.indexOf(n); e > -1 && t.splice(e, 1) } const px = new E("", { providedIn: "root", factory: () => T(sn).handleError.bind(void 0) }); function kL() { const t = T(z), n = T(sn); return e => t.runOutsideAngular(() => n.handleError(e)) } let FL = (() => { class t { constructor() { this.zone = T(z), this.applicationRef = T(Si) } initialize() { this._onMicrotaskEmptySubscription || (this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({ next: () => { this.zone.run(() => { this.applicationRef.tick() }) } })) } ngOnDestroy() { this._onMicrotaskEmptySubscription?.unsubscribe() } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); let Un = (() => { class t { static #e = this.__NG_ELEMENT_ID__ = NL } return t })(); function NL(t) { return function LL(t, n, e) { if (qi(t) && !e) { const i = $t(t.index, n); return new Hs(i, i) } return 47 & t.type ? new Hs(n[je], n) : null }(rt(), D(), 16 == (16 & t)) } class bx { constructor() { } supports(n) { return cc(n) } create(n) { return new zL(n) } } const UL = (t, n) => n; class zL { constructor(n) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = n || UL } forEachItem(n) { let e; for (e = this._itHead; null !== e; e = e._next)n(e) } forEachOperation(n) { let e = this._itHead, i = this._removalsHead, o = 0, r = null; for (; e || i;) { const s = !i || e && e.currentIndex < wx(i, o, r) ? e : i, a = wx(s, o, r), l = s.currentIndex; if (s === i) o--, i = i._nextRemoved; else if (e = e._next, null == s.previousIndex) o++; else { r || (r = []); const c = a - o, d = l - o; if (c != d) { for (let h = 0; h < c; h++) { const f = h < r.length ? r[h] : r[h] = 0, p = f + h; d <= p && p < c && (r[h] = f + 1) } r[s.previousIndex] = d - c } } a !== l && n(s, a, l) } } forEachPreviousItem(n) { let e; for (e = this._previousItHead; null !== e; e = e._nextPrevious)n(e) } forEachAddedItem(n) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)n(e) } forEachMovedItem(n) { let e; for (e = this._movesHead; null !== e; e = e._nextMoved)n(e) } forEachRemovedItem(n) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)n(e) } forEachIdentityChange(n) { let e; for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange)n(e) } diff(n) { if (null == n && (n = []), !cc(n)) throw new b(900, !1); return this.check(n) ? this : null } onDestroy() { } check(n) { this._reset(); let o, r, s, e = this._itHead, i = !1; if (Array.isArray(n)) { this.length = n.length; for (let a = 0; a < this.length; a++)r = n[a], s = this._trackByFn(a, r), null !== e && Object.is(e.trackById, s) ? (i && (e = this._verifyReinsertion(e, r, s, a)), Object.is(e.item, r) || this._addIdentityChange(e, r)) : (e = this._mismatch(e, r, s, a), i = !0), e = e._next } else o = 0, function wk(t, n) { if (Array.isArray(t)) for (let e = 0; e < t.length; e++)n(t[e]); else { const e = t[Symbol.iterator](); let i; for (; !(i = e.next()).done;)n(i.value) } }(n, a => { s = this._trackByFn(o, a), null !== e && Object.is(e.trackById, s) ? (i && (e = this._verifyReinsertion(e, a, s, o)), Object.is(e.item, a) || this._addIdentityChange(e, a)) : (e = this._mismatch(e, a, s, o), i = !0), e = e._next, o++ }), this.length = o; return this._truncate(e), this.collection = n, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let n; for (n = this._previousItHead = this._itHead; null !== n; n = n._next)n._nextPrevious = n._next; for (n = this._additionsHead; null !== n; n = n._nextAdded)n.previousIndex = n.currentIndex; for (this._additionsHead = this._additionsTail = null, n = this._movesHead; null !== n; n = n._nextMoved)n.previousIndex = n.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(n, e, i, o) { let r; return null === n ? r = this._itTail : (r = n._prev, this._remove(n)), null !== (n = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null)) ? (Object.is(n.item, e) || this._addIdentityChange(n, e), this._reinsertAfter(n, r, o)) : null !== (n = null === this._linkedRecords ? null : this._linkedRecords.get(i, o)) ? (Object.is(n.item, e) || this._addIdentityChange(n, e), this._moveAfter(n, r, o)) : n = this._addAfter(new $L(e, i), r, o), n } _verifyReinsertion(n, e, i, o) { let r = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null); return null !== r ? n = this._reinsertAfter(r, n._prev, o) : n.currentIndex != o && (n.currentIndex = o, this._addToMoves(n, o)), n } _truncate(n) { for (; null !== n;) { const e = n._next; this._addToRemovals(this._unlink(n)), n = e } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(n, e, i) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(n); const o = n._prevRemoved, r = n._nextRemoved; return null === o ? this._removalsHead = r : o._nextRemoved = r, null === r ? this._removalsTail = o : r._prevRemoved = o, this._insertAfter(n, e, i), this._addToMoves(n, i), n } _moveAfter(n, e, i) { return this._unlink(n), this._insertAfter(n, e, i), this._addToMoves(n, i), n } _addAfter(n, e, i) { return this._insertAfter(n, e, i), this._additionsTail = null === this._additionsTail ? this._additionsHead = n : this._additionsTail._nextAdded = n, n } _insertAfter(n, e, i) { const o = null === e ? this._itHead : e._next; return n._next = o, n._prev = e, null === o ? this._itTail = n : o._prev = n, null === e ? this._itHead = n : e._next = n, null === this._linkedRecords && (this._linkedRecords = new yx), this._linkedRecords.put(n), n.currentIndex = i, n } _remove(n) { return this._addToRemovals(this._unlink(n)) } _unlink(n) { null !== this._linkedRecords && this._linkedRecords.remove(n); const e = n._prev, i = n._next; return null === e ? this._itHead = i : e._next = i, null === i ? this._itTail = e : i._prev = e, n } _addToMoves(n, e) { return n.previousIndex === e || (this._movesTail = null === this._movesTail ? this._movesHead = n : this._movesTail._nextMoved = n), n } _addToRemovals(n) { return null === this._unlinkedRecords && (this._unlinkedRecords = new yx), this._unlinkedRecords.put(n), n.currentIndex = null, n._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = n, n._prevRemoved = null) : (n._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = n), n } _addIdentityChange(n, e) { return n.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = n : this._identityChangesTail._nextIdentityChange = n, n } } class $L { constructor(n, e) { this.item = n, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class GL { constructor() { this._head = null, this._tail = null } add(n) { null === this._head ? (this._head = this._tail = n, n._nextDup = null, n._prevDup = null) : (this._tail._nextDup = n, n._prevDup = this._tail, n._nextDup = null, this._tail = n) } get(n, e) { let i; for (i = this._head; null !== i; i = i._nextDup)if ((null === e || e <= i.currentIndex) && Object.is(i.trackById, n)) return i; return null } remove(n) { const e = n._prevDup, i = n._nextDup; return null === e ? this._head = i : e._nextDup = i, null === i ? this._tail = e : i._prevDup = e, null === this._head } } class yx { constructor() { this.map = new Map } put(n) { const e = n.trackById; let i = this.map.get(e); i || (i = new GL, this.map.set(e, i)), i.add(n) } get(n, e) { const o = this.map.get(n); return o ? o.get(n, e) : null } remove(n) { const e = n.trackById; return this.map.get(e).remove(n) && this.map.delete(e), n } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function wx(t, n, e) { const i = t.previousIndex; if (null === i) return i; let o = 0; return e && i < e.length && (o = e[i]), i + n + o } class xx { constructor() { } supports(n) { return n instanceof Map || uf(n) } create() { return new qL } } class qL { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(n) { let e; for (e = this._mapHead; null !== e; e = e._next)n(e) } forEachPreviousItem(n) { let e; for (e = this._previousMapHead; null !== e; e = e._nextPrevious)n(e) } forEachChangedItem(n) { let e; for (e = this._changesHead; null !== e; e = e._nextChanged)n(e) } forEachAddedItem(n) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)n(e) } forEachRemovedItem(n) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)n(e) } diff(n) { if (n) { if (!(n instanceof Map || uf(n))) throw new b(900, !1) } else n = new Map; return this.check(n) ? this : null } onDestroy() { } check(n) { this._reset(); let e = this._mapHead; if (this._appendAfter = null, this._forEach(n, (i, o) => { if (e && e.key === o) this._maybeAddToChanges(e, i), this._appendAfter = e, e = e._next; else { const r = this._getOrCreateRecordForKey(o, i); e = this._insertBeforeOrAppend(e, r) } }), e) { e._prev && (e._prev._next = null), this._removalsHead = e; for (let i = e; null !== i; i = i._nextRemoved)i === this._mapHead && (this._mapHead = null), this._records.delete(i.key), i._nextRemoved = i._next, i.previousValue = i.currentValue, i.currentValue = null, i._prev = null, i._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(n, e) { if (n) { const i = n._prev; return e._next = n, e._prev = i, n._prev = e, i && (i._next = e), n === this._mapHead && (this._mapHead = e), this._appendAfter = n, n } return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null } _getOrCreateRecordForKey(n, e) { if (this._records.has(n)) { const o = this._records.get(n); this._maybeAddToChanges(o, e); const r = o._prev, s = o._next; return r && (r._next = s), s && (s._prev = r), o._next = null, o._prev = null, o } const i = new WL(n); return this._records.set(n, i), i.currentValue = e, this._addToAdditions(i), i } _reset() { if (this.isDirty) { let n; for (this._previousMapHead = this._mapHead, n = this._previousMapHead; null !== n; n = n._next)n._nextPrevious = n._next; for (n = this._changesHead; null !== n; n = n._nextChanged)n.previousValue = n.currentValue; for (n = this._additionsHead; null != n; n = n._nextAdded)n.previousValue = n.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(n, e) { Object.is(e, n.currentValue) || (n.previousValue = n.currentValue, n.currentValue = e, this._addToChanges(n)) } _addToAdditions(n) { null === this._additionsHead ? this._additionsHead = this._additionsTail = n : (this._additionsTail._nextAdded = n, this._additionsTail = n) } _addToChanges(n) { null === this._changesHead ? this._changesHead = this._changesTail = n : (this._changesTail._nextChanged = n, this._changesTail = n) } _forEach(n, e) { n instanceof Map ? n.forEach(e) : Object.keys(n).forEach(i => e(n[i], i)) } } class WL { constructor(n) { this.key = n, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function Cx() { return new Ac([new bx]) } let Ac = (() => { class t { static #e = this.\u0275prov = I({ token: t, providedIn: "root", factory: Cx }); constructor(e) { this.factories = e } static create(e, i) { if (null != i) { const o = i.factories.slice(); e = e.concat(o) } return new t(e) } static extend(e) { return { provide: t, useFactory: i => t.create(e, i || Cx()), deps: [[t, new Es, new Xi]] } } find(e) { const i = this.factories.find(o => o.supports(e)); if (null != i) return i; throw new b(901, !1) } } return t })(); function Dx() { return new la([new xx]) } let la = (() => { class t { static #e = this.\u0275prov = I({ token: t, providedIn: "root", factory: Dx }); constructor(e) { this.factories = e } static create(e, i) { if (i) { const o = i.factories.slice(); e = e.concat(o) } return new t(e) } static extend(e) { return { provide: t, useFactory: i => t.create(e, i || Dx()), deps: [[t, new Es, new Xi]] } } find(e) { const i = this.factories.find(o => o.supports(e)); if (i) return i; throw new b(901, !1) } } return t })(); const XL = ax(null, "core", []); let KL = (() => { class t { constructor(e) { } static #e = this.\u0275fac = function (i) { return new (i || t)(w(Si)) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({}) } return t })(); function Sr(t) { return "boolean" == typeof t ? t : null != t && "false" !== t } let lp = null; function Mi() { return lp } class h2 { } const te = new E("DocumentToken"); let cp = (() => { class t { historyGo(e) { throw new Error("Not implemented") } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: function () { return T(p2) }, providedIn: "platform" }) } return t })(); const f2 = new E("Location Initialized"); let p2 = (() => { class t extends cp { constructor() { super(), this._doc = T(te), this._location = window.location, this._history = window.history } getBaseHrefFromDOM() { return Mi().getBaseHref(this._doc) } onPopState(e) { const i = Mi().getGlobalEventTarget(this._doc, "window"); return i.addEventListener("popstate", e, !1), () => i.removeEventListener("popstate", e) } onHashChange(e) { const i = Mi().getGlobalEventTarget(this._doc, "window"); return i.addEventListener("hashchange", e, !1), () => i.removeEventListener("hashchange", e) } get href() { return this._location.href } get protocol() { return this._location.protocol } get hostname() { return this._location.hostname } get port() { return this._location.port } get pathname() { return this._location.pathname } get search() { return this._location.search } get hash() { return this._location.hash } set pathname(e) { this._location.pathname = e } pushState(e, i, o) { this._history.pushState(e, i, o) } replaceState(e, i, o) { this._history.replaceState(e, i, o) } forward() { this._history.forward() } back() { this._history.back() } historyGo(e = 0) { this._history.go(e) } getState() { return this._history.state } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: function () { return new t }, providedIn: "platform" }) } return t })(); function dp(t, n) { if (0 == t.length) return n; if (0 == n.length) return t; let e = 0; return t.endsWith("/") && e++, n.startsWith("/") && e++, 2 == e ? t + n.substring(1) : 1 == e ? t + n : t + "/" + n } function kx(t) { const n = t.match(/#|\?|$/), e = n && n.index || t.length; return t.slice(0, e - ("/" === t[e - 1] ? 1 : 0)) + t.slice(e) } function ri(t) { return t && "?" !== t[0] ? "?" + t : t } let lo = (() => { class t { historyGo(e) { throw new Error("Not implemented") } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: function () { return T(Px) }, providedIn: "root" }) } return t })(); const Fx = new E("appBaseHref"); let Px = (() => { class t extends lo { constructor(e, i) { super(), this._platformLocation = e, this._removeListenerFns = [], this._baseHref = i ?? this._platformLocation.getBaseHrefFromDOM() ?? T(te).location?.origin ?? "" } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(e) { this._removeListenerFns.push(this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e)) } getBaseHref() { return this._baseHref } prepareExternalUrl(e) { return dp(this._baseHref, e) } path(e = !1) { const i = this._platformLocation.pathname + ri(this._platformLocation.search), o = this._platformLocation.hash; return o && e ? `${i}${o}` : i } pushState(e, i, o, r) { const s = this.prepareExternalUrl(o + ri(r)); this._platformLocation.pushState(e, i, s) } replaceState(e, i, o, r) { const s = this.prepareExternalUrl(o + ri(r)); this._platformLocation.replaceState(e, i, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(e = 0) { this._platformLocation.historyGo?.(e) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(cp), w(Fx, 8)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), m2 = (() => { class t extends lo { constructor(e, i) { super(), this._platformLocation = e, this._baseHref = "", this._removeListenerFns = [], null != i && (this._baseHref = i) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(e) { this._removeListenerFns.push(this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e)) } getBaseHref() { return this._baseHref } path(e = !1) { let i = this._platformLocation.hash; return null == i && (i = "#"), i.length > 0 ? i.substring(1) : i } prepareExternalUrl(e) { const i = dp(this._baseHref, e); return i.length > 0 ? "#" + i : i } pushState(e, i, o, r) { let s = this.prepareExternalUrl(o + ri(r)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(e, i, s) } replaceState(e, i, o, r) { let s = this.prepareExternalUrl(o + ri(r)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(e, i, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(e = 0) { this._platformLocation.historyGo?.(e) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(cp), w(Fx, 8)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })(), Rc = (() => { class t { constructor(e) { this._subject = new ue, this._urlChangeListeners = [], this._urlChangeSubscription = null, this._locationStrategy = e; const i = this._locationStrategy.getBaseHref(); this._basePath = function v2(t) { if (new RegExp("^(https?:)?//").test(t)) { const [, e] = t.split(/\/\/[^\/]+/); return e } return t }(kx(Nx(i))), this._locationStrategy.onPopState(o => { this._subject.emit({ url: this.path(!0), pop: !0, state: o.state, type: o.type }) }) } ngOnDestroy() { this._urlChangeSubscription?.unsubscribe(), this._urlChangeListeners = [] } path(e = !1) { return this.normalize(this._locationStrategy.path(e)) } getState() { return this._locationStrategy.getState() } isCurrentPathEqualTo(e, i = "") { return this.path() == this.normalize(e + ri(i)) } normalize(e) { return t.stripTrailingSlash(function _2(t, n) { if (!t || !n.startsWith(t)) return n; const e = n.substring(t.length); return "" === e || ["/", ";", "?", "#"].includes(e[0]) ? e : n }(this._basePath, Nx(e))) } prepareExternalUrl(e) { return e && "/" !== e[0] && (e = "/" + e), this._locationStrategy.prepareExternalUrl(e) } go(e, i = "", o = null) { this._locationStrategy.pushState(o, "", e, i), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + ri(i)), o) } replaceState(e, i = "", o = null) { this._locationStrategy.replaceState(o, "", e, i), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + ri(i)), o) } forward() { this._locationStrategy.forward() } back() { this._locationStrategy.back() } historyGo(e = 0) { this._locationStrategy.historyGo?.(e) } onUrlChange(e) { return this._urlChangeListeners.push(e), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(i => { this._notifyUrlChangeListeners(i.url, i.state) })), () => { const i = this._urlChangeListeners.indexOf(e); this._urlChangeListeners.splice(i, 1), 0 === this._urlChangeListeners.length && (this._urlChangeSubscription?.unsubscribe(), this._urlChangeSubscription = null) } } _notifyUrlChangeListeners(e = "", i) { this._urlChangeListeners.forEach(o => o(e, i)) } subscribe(e, i, o) { return this._subject.subscribe({ next: e, error: i, complete: o }) } static #e = this.normalizeQueryParams = ri; static #t = this.joinWithSlash = dp; static #n = this.stripTrailingSlash = kx; static #i = this.\u0275fac = function (i) { return new (i || t)(w(lo)) }; static #o = this.\u0275prov = I({ token: t, factory: function () { return function g2() { return new Rc(w(lo)) }() }, providedIn: "root" }) } return t })(); function Nx(t) { return t.replace(/\/index.html$/, "") } function Gx(t, n) { n = encodeURIComponent(n); for (const e of t.split(";")) { const i = e.indexOf("="), [o, r] = -1 == i ? [e, ""] : [e.slice(0, i), e.slice(i + 1)]; if (o.trim() === n) return decodeURIComponent(r) } return null } const yp = /\s+/, qx = []; let Wx = (() => { class t { constructor(e, i, o, r) { this._iterableDiffers = e, this._keyValueDiffers = i, this._ngEl = o, this._renderer = r, this.initialClasses = qx, this.stateMap = new Map } set klass(e) { this.initialClasses = null != e ? e.trim().split(yp) : qx } set ngClass(e) { this.rawClass = "string" == typeof e ? e.trim().split(yp) : e } ngDoCheck() { for (const i of this.initialClasses) this._updateState(i, !0); const e = this.rawClass; if (Array.isArray(e) || e instanceof Set) for (const i of e) this._updateState(i, !0); else if (null != e) for (const i of Object.keys(e)) this._updateState(i, !!e[i]); this._applyStateDiff() } _updateState(e, i) { const o = this.stateMap.get(e); void 0 !== o ? (o.enabled !== i && (o.changed = !0, o.enabled = i), o.touched = !0) : this.stateMap.set(e, { enabled: i, changed: !0, touched: !0 }) } _applyStateDiff() { for (const e of this.stateMap) { const i = e[0], o = e[1]; o.changed ? (this._toggleClass(i, o.enabled), o.changed = !1) : o.touched || (o.enabled && this._toggleClass(i, !1), this.stateMap.delete(i)), o.touched = !1 } } _toggleClass(e, i) { (e = e.trim()).length > 0 && e.split(yp).forEach(o => { i ? this._renderer.addClass(this._ngEl.nativeElement, o) : this._renderer.removeClass(this._ngEl.nativeElement, o) }) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(Ac), g(la), g(ye), g(ni)) }; static #t = this.\u0275dir = P({ type: t, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" }, standalone: !0 }) } return t })(); class iV { constructor(n, e, i, o) { this.$implicit = n, this.ngForOf = e, this.index = i, this.count = o } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let Ir = (() => { class t { set ngForOf(e) { this._ngForOf = e, this._ngForOfDirty = !0 } set ngForTrackBy(e) { this._trackByFn = e } get ngForTrackBy() { return this._trackByFn } constructor(e, i, o) { this._viewContainer = e, this._template = i, this._differs = o, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForTemplate(e) { e && (this._template = e) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const e = this._ngForOf; !this._differ && e && (this._differ = this._differs.find(e).create(this.ngForTrackBy)) } if (this._differ) { const e = this._differ.diff(this._ngForOf); e && this._applyChanges(e) } } _applyChanges(e) { const i = this._viewContainer; e.forEachOperation((o, r, s) => { if (null == o.previousIndex) i.createEmbeddedView(this._template, new iV(o.item, this._ngForOf, -1, -1), null === s ? void 0 : s); else if (null == s) i.remove(null === r ? void 0 : r); else if (null !== r) { const a = i.get(r); i.move(a, s), Zx(a, o) } }); for (let o = 0, r = i.length; o < r; o++) { const a = i.get(o).context; a.index = o, a.count = r, a.ngForOf = this._ngForOf } e.forEachIdentityChange(o => { Zx(i.get(o.currentIndex), o) }) } static ngTemplateContextGuard(e, i) { return !0 } static #e = this.\u0275fac = function (i) { return new (i || t)(g(cn), g(jn), g(Ac)) }; static #t = this.\u0275dir = P({ type: t, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" }, standalone: !0 }) } return t })(); function Zx(t, n) { t.context.$implicit = n.item } let Ii = (() => { class t { constructor(e, i) { this._viewContainer = e, this._context = new oV, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = i } set ngIf(e) { this._context.$implicit = this._context.ngIf = e, this._updateView() } set ngIfThen(e) { Xx("ngIfThen", e), this._thenTemplateRef = e, this._thenViewRef = null, this._updateView() } set ngIfElse(e) { Xx("ngIfElse", e), this._elseTemplateRef = e, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(e, i) { return !0 } static #e = this.\u0275fac = function (i) { return new (i || t)(g(cn), g(jn)) }; static #t = this.\u0275dir = P({ type: t, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" }, standalone: !0 }) } return t })(); class oV { constructor() { this.$implicit = null, this.ngIf = null } } function Xx(t, n) { if (n && !n.createEmbeddedView) throw new Error(`${t} must be a TemplateRef, but received '${Ze(n)}'.`) } class wp { constructor(n, e) { this._viewContainerRef = n, this._templateRef = e, this._created = !1 } create() { this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef) } destroy() { this._created = !1, this._viewContainerRef.clear() } enforceState(n) { n && !this._created ? this.create() : !n && this._created && this.destroy() } } let Uc = (() => { class t { constructor() { this._defaultViews = [], this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1 } set ngSwitch(e) { this._ngSwitch = e, 0 === this._caseCount && this._updateDefaultCases(!0) } _addCase() { return this._caseCount++ } _addDefault(e) { this._defaultViews.push(e) } _matchCase(e) { const i = e == this._ngSwitch; return this._lastCasesMatched = this._lastCasesMatched || i, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), i } _updateDefaultCases(e) { if (this._defaultViews.length > 0 && e !== this._defaultUsed) { this._defaultUsed = e; for (const i of this._defaultViews) i.enforceState(e) } } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275dir = P({ type: t, selectors: [["", "ngSwitch", ""]], inputs: { ngSwitch: "ngSwitch" }, standalone: !0 }) } return t })(), Kx = (() => { class t { constructor(e, i, o) { this.ngSwitch = o, o._addCase(), this._view = new wp(e, i) } ngDoCheck() { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(cn), g(jn), g(Uc, 9)) }; static #t = this.\u0275dir = P({ type: t, selectors: [["", "ngSwitchCase", ""]], inputs: { ngSwitchCase: "ngSwitchCase" }, standalone: !0 }) } return t })(), Jx = (() => { class t { constructor(e) { this._viewContainerRef = e, this._viewRef = null, this.ngTemplateOutletContext = null, this.ngTemplateOutlet = null, this.ngTemplateOutletInjector = null } ngOnChanges(e) { if (e.ngTemplateOutlet || e.ngTemplateOutletInjector) { const i = this._viewContainerRef; if (this._viewRef && i.remove(i.indexOf(this._viewRef)), this.ngTemplateOutlet) { const { ngTemplateOutlet: o, ngTemplateOutletContext: r, ngTemplateOutletInjector: s } = this; this._viewRef = i.createEmbeddedView(o, r, s ? { injector: s } : void 0) } else this._viewRef = null } else this._viewRef && e.ngTemplateOutletContext && this.ngTemplateOutletContext && (this._viewRef.context = this.ngTemplateOutletContext) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(cn)) }; static #t = this.\u0275dir = P({ type: t, selectors: [["", "ngTemplateOutlet", ""]], inputs: { ngTemplateOutletContext: "ngTemplateOutletContext", ngTemplateOutlet: "ngTemplateOutlet", ngTemplateOutletInjector: "ngTemplateOutletInjector" }, standalone: !0, features: [Ft] }) } return t })(), Ar = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({}) } return t })(); const tC = "browser"; function nC(t) { return "server" === t } let FV = (() => { class t { static #e = this.\u0275prov = I({ token: t, providedIn: "root", factory: () => new PV(w(te), window) }) } return t })(); class PV { constructor(n, e) { this.document = n, this.window = e, this.offset = () => [0, 0] } setOffset(n) { this.offset = Array.isArray(n) ? () => n : n } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(n) { this.supportsScrolling() && this.window.scrollTo(n[0], n[1]) } scrollToAnchor(n) { if (!this.supportsScrolling()) return; const e = function NV(t, n) { const e = t.getElementById(n) || t.getElementsByName(n)[0]; if (e) return e; if ("function" == typeof t.createTreeWalker && t.body && "function" == typeof t.body.attachShadow) { const i = t.createTreeWalker(t.body, NodeFilter.SHOW_ELEMENT); let o = i.currentNode; for (; o;) { const r = o.shadowRoot; if (r) { const s = r.getElementById(n) || r.querySelector(`[name="${n}"]`); if (s) return s } o = i.nextNode() } } return null }(this.document, n); e && (this.scrollToElement(e), e.focus()) } setHistoryScrollRestoration(n) { this.supportsScrolling() && (this.window.history.scrollRestoration = n) } scrollToElement(n) { const e = n.getBoundingClientRect(), i = e.left + this.window.pageXOffset, o = e.top + this.window.pageYOffset, r = this.offset(); this.window.scrollTo(i - r[0], o - r[1]) } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch { return !1 } } } class iC { } class rB extends h2 { constructor() { super(...arguments), this.supportsDOMEvents = !0 } } class Sp extends rB { static makeCurrent() { !function u2(t) { lp || (lp = t) }(new Sp) } onAndCancel(n, e, i) { return n.addEventListener(e, i), () => { n.removeEventListener(e, i) } } dispatchEvent(n, e) { n.dispatchEvent(e) } remove(n) { n.parentNode && n.parentNode.removeChild(n) } createElement(n, e) { return (e = e || this.getDefaultDocument()).createElement(n) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(n) { return n.nodeType === Node.ELEMENT_NODE } isShadowRoot(n) { return n instanceof DocumentFragment } getGlobalEventTarget(n, e) { return "window" === e ? window : "document" === e ? n : "body" === e ? n.body : null } getBaseHref(n) { const e = function sB() { return ha = ha || document.querySelector("base"), ha ? ha.getAttribute("href") : null }(); return null == e ? null : function aB(t) { Gc = Gc || document.createElement("a"), Gc.setAttribute("href", t); const n = Gc.pathname; return "/" === n.charAt(0) ? n : `/${n}` }(e) } resetBaseElement() { ha = null } getUserAgent() { return window.navigator.userAgent } getCookie(n) { return Gx(document.cookie, n) } } let Gc, ha = null, cB = (() => { class t { build() { return new XMLHttpRequest } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })(); const Mp = new E("EventManagerPlugins"); let lC = (() => { class t { constructor(e, i) { this._zone = i, this._eventNameToPlugin = new Map, e.forEach(o => { o.manager = this }), this._plugins = e.slice().reverse() } addEventListener(e, i, o) { return this._findPluginFor(i).addEventListener(e, i, o) } getZone() { return this._zone } _findPluginFor(e) { let i = this._eventNameToPlugin.get(e); if (i) return i; if (i = this._plugins.find(r => r.supports(e)), !i) throw new b(5101, !1); return this._eventNameToPlugin.set(e, i), i } static #e = this.\u0275fac = function (i) { return new (i || t)(w(Mp), w(z)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })(); class cC { constructor(n) { this._doc = n } } const Ip = "ng-app-id"; let dC = (() => { class t { constructor(e, i, o, r = {}) { this.doc = e, this.appId = i, this.nonce = o, this.platformId = r, this.styleRef = new Map, this.hostNodes = new Set, this.styleNodesInDOM = this.collectServerRenderedStyles(), this.platformIsServer = nC(r), this.resetHostNodes() } addStyles(e) { for (const i of e) 1 === this.changeUsageCount(i, 1) && this.onStyleAdded(i) } removeStyles(e) { for (const i of e) this.changeUsageCount(i, -1) <= 0 && this.onStyleRemoved(i) } ngOnDestroy() { const e = this.styleNodesInDOM; e && (e.forEach(i => i.remove()), e.clear()); for (const i of this.getAllStyles()) this.onStyleRemoved(i); this.resetHostNodes() } addHost(e) { this.hostNodes.add(e); for (const i of this.getAllStyles()) this.addStyleToHost(e, i) } removeHost(e) { this.hostNodes.delete(e) } getAllStyles() { return this.styleRef.keys() } onStyleAdded(e) { for (const i of this.hostNodes) this.addStyleToHost(i, e) } onStyleRemoved(e) { const i = this.styleRef; i.get(e)?.elements?.forEach(o => o.remove()), i.delete(e) } collectServerRenderedStyles() { const e = this.doc.head?.querySelectorAll(`style[${Ip}="${this.appId}"]`); if (e?.length) { const i = new Map; return e.forEach(o => { null != o.textContent && i.set(o.textContent, o) }), i } return null } changeUsageCount(e, i) { const o = this.styleRef; if (o.has(e)) { const r = o.get(e); return r.usage += i, r.usage } return o.set(e, { usage: i, elements: [] }), i } getStyleElement(e, i) { const o = this.styleNodesInDOM, r = o?.get(i); if (r?.parentNode === e) return o.delete(i), r.removeAttribute(Ip), r; { const s = this.doc.createElement("style"); return this.nonce && s.setAttribute("nonce", this.nonce), s.textContent = i, this.platformIsServer && s.setAttribute(Ip, this.appId), s } } addStyleToHost(e, i) { const o = this.getStyleElement(e, i); e.appendChild(o); const r = this.styleRef, s = r.get(i)?.elements; s ? s.push(o) : r.set(i, { elements: [o], usage: 1 }) } resetHostNodes() { const e = this.hostNodes; e.clear(), e.add(this.doc.head) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(te), w(Zl), w(kh, 8), w(Ci)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })(); const Ap = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, Tp = /%COMP%/g, fB = new E("RemoveStylesOnCompDestroy", { providedIn: "root", factory: () => !1 }); function hC(t, n) { return n.map(e => e.replace(Tp, t)) } let Rp = (() => { class t { constructor(e, i, o, r, s, a, l, c = null) { this.eventManager = e, this.sharedStylesHost = i, this.appId = o, this.removeStylesOnCompDestroy = r, this.doc = s, this.platformId = a, this.ngZone = l, this.nonce = c, this.rendererByCompId = new Map, this.platformIsServer = nC(a), this.defaultRenderer = new Op(e, s, l, this.platformIsServer) } createRenderer(e, i) { if (!e || !i) return this.defaultRenderer; this.platformIsServer && i.encapsulation === nn.ShadowDom && (i = { ...i, encapsulation: nn.Emulated }); const o = this.getOrCreateRenderer(e, i); return o instanceof pC ? o.applyToHost(e) : o instanceof kp && o.applyStyles(), o } getOrCreateRenderer(e, i) { const o = this.rendererByCompId; let r = o.get(i.id); if (!r) { const s = this.doc, a = this.ngZone, l = this.eventManager, c = this.sharedStylesHost, d = this.removeStylesOnCompDestroy, u = this.platformIsServer; switch (i.encapsulation) { case nn.Emulated: r = new pC(l, c, i, this.appId, d, s, a, u); break; case nn.ShadowDom: return new _B(l, c, e, i, s, a, this.nonce, u); default: r = new kp(l, c, i, d, s, a, u) }o.set(i.id, r) } return r } ngOnDestroy() { this.rendererByCompId.clear() } static #e = this.\u0275fac = function (i) { return new (i || t)(w(lC), w(dC), w(Zl), w(fB), w(te), w(Ci), w(z), w(kh)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })(); class Op { constructor(n, e, i, o) { this.eventManager = n, this.doc = e, this.ngZone = i, this.platformIsServer = o, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(n, e) { return e ? this.doc.createElementNS(Ap[e] || e, n) : this.doc.createElement(n) } createComment(n) { return this.doc.createComment(n) } createText(n) { return this.doc.createTextNode(n) } appendChild(n, e) { (fC(n) ? n.content : n).appendChild(e) } insertBefore(n, e, i) { n && (fC(n) ? n.content : n).insertBefore(e, i) } removeChild(n, e) { n && n.removeChild(e) } selectRootElement(n, e) { let i = "string" == typeof n ? this.doc.querySelector(n) : n; if (!i) throw new b(-5104, !1); return e || (i.textContent = ""), i } parentNode(n) { return n.parentNode } nextSibling(n) { return n.nextSibling } setAttribute(n, e, i, o) { if (o) { e = o + ":" + e; const r = Ap[o]; r ? n.setAttributeNS(r, e, i) : n.setAttribute(e, i) } else n.setAttribute(e, i) } removeAttribute(n, e, i) { if (i) { const o = Ap[i]; o ? n.removeAttributeNS(o, e) : n.removeAttribute(`${i}:${e}`) } else n.removeAttribute(e) } addClass(n, e) { n.classList.add(e) } removeClass(n, e) { n.classList.remove(e) } setStyle(n, e, i, o) { o & (xi.DashCase | xi.Important) ? n.style.setProperty(e, i, o & xi.Important ? "important" : "") : n.style[e] = i } removeStyle(n, e, i) { i & xi.DashCase ? n.style.removeProperty(e) : n.style[e] = "" } setProperty(n, e, i) { n[e] = i } setValue(n, e) { n.nodeValue = e } listen(n, e, i) { if ("string" == typeof n && !(n = Mi().getGlobalEventTarget(this.doc, n))) throw new Error(`Unsupported event target ${n} for event ${e}`); return this.eventManager.addEventListener(n, e, this.decoratePreventDefault(i)) } decoratePreventDefault(n) { return e => { if ("__ngUnwrap__" === e) return n; !1 === (this.platformIsServer ? this.ngZone.runGuarded(() => n(e)) : n(e)) && e.preventDefault() } } } function fC(t) { return "TEMPLATE" === t.tagName && void 0 !== t.content } class _B extends Op { constructor(n, e, i, o, r, s, a, l) { super(n, r, s, l), this.sharedStylesHost = e, this.hostEl = i, this.shadowRoot = i.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const c = hC(o.id, o.styles); for (const d of c) { const u = document.createElement("style"); a && u.setAttribute("nonce", a), u.textContent = d, this.shadowRoot.appendChild(u) } } nodeOrShadowRoot(n) { return n === this.hostEl ? this.shadowRoot : n } appendChild(n, e) { return super.appendChild(this.nodeOrShadowRoot(n), e) } insertBefore(n, e, i) { return super.insertBefore(this.nodeOrShadowRoot(n), e, i) } removeChild(n, e) { return super.removeChild(this.nodeOrShadowRoot(n), e) } parentNode(n) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(n))) } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } } class kp extends Op { constructor(n, e, i, o, r, s, a, l) { super(n, r, s, a), this.sharedStylesHost = e, this.removeStylesOnCompDestroy = o, this.styles = l ? hC(l, i.styles) : i.styles } applyStyles() { this.sharedStylesHost.addStyles(this.styles) } destroy() { this.removeStylesOnCompDestroy && this.sharedStylesHost.removeStyles(this.styles) } } class pC extends kp { constructor(n, e, i, o, r, s, a, l) { const c = o + "-" + i.id; super(n, e, i, r, s, a, l, c), this.contentAttr = function pB(t) { return "_ngcontent-%COMP%".replace(Tp, t) }(c), this.hostAttr = function mB(t) { return "_nghost-%COMP%".replace(Tp, t) }(c) } applyToHost(n) { this.applyStyles(), this.setAttribute(n, this.hostAttr, "") } createElement(n, e) { const i = super.createElement(n, e); return super.setAttribute(i, this.contentAttr, ""), i } } let vB = (() => { class t extends cC { constructor(e) { super(e) } supports(e) { return !0 } addEventListener(e, i, o) { return e.addEventListener(i, o, !1), () => this.removeEventListener(e, i, o) } removeEventListener(e, i, o) { return e.removeEventListener(i, o) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(te)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })(); const mC = ["alt", "control", "meta", "shift"], bB = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, yB = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }; let wB = (() => { class t extends cC { constructor(e) { super(e) } supports(e) { return null != t.parseEventName(e) } addEventListener(e, i, o) { const r = t.parseEventName(i), s = t.eventCallback(r.fullKey, o, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => Mi().onAndCancel(e, r.domEventName, s)) } static parseEventName(e) { const i = e.toLowerCase().split("."), o = i.shift(); if (0 === i.length || "keydown" !== o && "keyup" !== o) return null; const r = t._normalizeKey(i.pop()); let s = "", a = i.indexOf("code"); if (a > -1 && (i.splice(a, 1), s = "code."), mC.forEach(c => { const d = i.indexOf(c); d > -1 && (i.splice(d, 1), s += c + ".") }), s += r, 0 != i.length || 0 === r.length) return null; const l = {}; return l.domEventName = o, l.fullKey = s, l } static matchEventFullKeyCode(e, i) { let o = bB[e.key] || e.key, r = ""; return i.indexOf("code.") > -1 && (o = e.code, r = "code."), !(null == o || !o) && (o = o.toLowerCase(), " " === o ? o = "space" : "." === o && (o = "dot"), mC.forEach(s => { s !== o && (0, yB[s])(e) && (r += s + ".") }), r += o, r === i) } static eventCallback(e, i, o) { return r => { t.matchEventFullKeyCode(r, e) && o.runGuarded(() => i(r)) } } static _normalizeKey(e) { return "esc" === e ? "escape" : e } static #e = this.\u0275fac = function (i) { return new (i || t)(w(te)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })(); const EB = ax(XL, "browser", [{ provide: Ci, useValue: tC }, { provide: yb, useValue: function xB() { Sp.makeCurrent() }, multi: !0 }, { provide: te, useFactory: function DB() { return function JR(t) { yh = t }(document), document }, deps: [] }]), SB = new E(""), vC = [{ provide: Ec, useClass: class lB { addToWindow(n) { Ce.getAngularTestability = (i, o = !0) => { const r = n.findTestabilityInTree(i, o); if (null == r) throw new b(5103, !1); return r }, Ce.getAllAngularTestabilities = () => n.getAllTestabilities(), Ce.getAllAngularRootElements = () => n.getAllRootElements(), Ce.frameworkStabilizers || (Ce.frameworkStabilizers = []), Ce.frameworkStabilizers.push(i => { const o = Ce.getAllAngularTestabilities(); let r = o.length, s = !1; const a = function (l) { s = s || l, r--, 0 == r && i(s) }; o.forEach(l => { l.whenStable(a) }) }) } findTestabilityInTree(n, e, i) { return null == e ? null : n.getTestability(e) ?? (i ? Mi().isShadowRoot(e) ? this.findTestabilityInTree(n, e.host, !0) : this.findTestabilityInTree(n, e.parentElement, !0) : null) } }, deps: [] }, { provide: nx, useClass: Kf, deps: [z, Qf, Ec] }, { provide: Kf, useClass: Kf, deps: [z, Qf, Ec] }], bC = [{ provide: Ah, useValue: "root" }, { provide: sn, useFactory: function CB() { return new sn }, deps: [] }, { provide: Mp, useClass: vB, multi: !0, deps: [te, z, Ci] }, { provide: Mp, useClass: wB, multi: !0, deps: [te] }, Rp, dC, lC, { provide: Ls, useExisting: Rp }, { provide: iC, useClass: cB, deps: [] }, []]; let yC = (() => { class t { constructor(e) { } static withServerTransition(e) { return { ngModule: t, providers: [{ provide: Zl, useValue: e.appId }] } } static #e = this.\u0275fac = function (i) { return new (i || t)(w(SB, 12)) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ providers: [...bC, ...vC], imports: [Ar, KL] }) } return t })(), wC = (() => { class t { constructor(e) { this._doc = e } getTitle() { return this._doc.title } setTitle(e) { this._doc.title = e || "" } static #e = this.\u0275fac = function (i) { return new (i || t)(w(te)) }; static #t = this.\u0275prov = I({ token: t, factory: function (i) { let o = null; return o = i ? new i : function IB() { return new wC(w(te)) }(), o }, providedIn: "root" }) } return t })(); typeof window < "u" && window; let Np, Pp = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: function (i) { let o = null; return o = i ? new (i || t) : w(DC), o }, providedIn: "root" }) } return t })(), DC = (() => { class t extends Pp { constructor(e) { super(), this._doc = e } sanitize(e, i) { if (null == i) return null; switch (e) { case st.NONE: return i; case st.HTML: return Pn(i, "HTML") ? qt(i) : db(this._doc, String(i)).toString(); case st.STYLE: return Pn(i, "Style") ? qt(i) : i; case st.SCRIPT: if (Pn(i, "Script")) return qt(i); throw new b(5200, !1); case st.URL: return Pn(i, "URL") ? qt(i) : $l(String(i)); case st.RESOURCE_URL: if (Pn(i, "ResourceURL")) return qt(i); throw new b(5201, !1); default: throw new b(5202, !1) } } bypassSecurityTrustHtml(e) { return function sO(t) { return new eO(t) }(e) } bypassSecurityTrustStyle(e) { return function aO(t) { return new tO(t) }(e) } bypassSecurityTrustScript(e) { return function lO(t) { return new nO(t) }(e) } bypassSecurityTrustUrl(e) { return function cO(t) { return new iO(t) }(e) } bypassSecurityTrustResourceUrl(e) { return function dO(t) { return new oO(t) }(e) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(te)) }; static #t = this.\u0275prov = I({ token: t, factory: function (i) { let o = null; return o = i ? new i : function OB(t) { return new DC(t.get(te)) }(w(ft)), o }, providedIn: "root" }) } return t })(); try { Np = typeof Intl < "u" && Intl.v8BreakIterator } catch { Np = !1 } let Tr, Bt = (() => { class t { constructor(e) { this._platformId = e, this.isBrowser = this._platformId ? function kV(t) { return t === tC }(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !Np) && typeof CSS < "u" && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } static #e = this.\u0275fac = function (i) { return new (i || t)(w(Ci)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); const SC = ["color", "button", "checkbox", "date", "datetime-local", "email", "file", "hidden", "image", "month", "number", "password", "radio", "range", "reset", "search", "submit", "tel", "text", "time", "url", "week"]; function MC() { if (Tr) return Tr; if ("object" != typeof document || !document) return Tr = new Set(SC), Tr; let t = document.createElement("input"); return Tr = new Set(SC.filter(n => (t.setAttribute("type", n), t.type === n))), Tr } let fa, co, Lp; function Rr(t) { return function kB() { if (null == fa && typeof window < "u") try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => fa = !0 })) } finally { fa = fa || !1 } return fa }() ? t : !!t.capture } function FB() { if (null == co) { if ("object" != typeof document || !document || "function" != typeof Element || !Element) return co = !1, co; if ("scrollBehavior" in document.documentElement.style) co = !0; else { const t = Element.prototype.scrollTo; co = !!t && !/\{\s*\[native code\]\s*\}/.test(t.toString()) } } return co } function li(t) { return t.composedPath ? t.composedPath()[0] : t.target } function Vp() { return typeof __karma__ < "u" && !!__karma__ || typeof jasmine < "u" && !!jasmine || typeof jest < "u" && !!jest || typeof Mocha < "u" && !!Mocha } function pa(t, ...n) { return n.length ? n.some(e => t[e]) : t.altKey || t.shiftKey || t.ctrlKey || t.metaKey } function Ue(t, n, e) { const i = ne(t) || n || e ? { next: t, error: n, complete: e } : t; return i ? Pe((o, r) => { var s; null === (s = i.subscribe) || void 0 === s || s.call(i); let a = !0; o.subscribe(Ie(r, l => { var c; null === (c = i.next) || void 0 === c || c.call(i, l), r.next(l) }, () => { var l; a = !1, null === (l = i.complete) || void 0 === l || l.call(i), r.complete() }, l => { var c; a = !1, null === (c = i.error) || void 0 === c || c.call(i, l), r.error(l) }, () => { var l, c; a && (null === (l = i.unsubscribe) || void 0 === l || l.call(i)), null === (c = i.finalize) || void 0 === c || c.call(i) })) }) : pi } class JB extends Fe { constructor(n, e) { super() } schedule(n, e = 0) { return this } } const Wc = { setInterval(t, n, ...e) { const { delegate: i } = Wc; return i?.setInterval ? i.setInterval(t, n, ...e) : setInterval(t, n, ...e) }, clearInterval(t) { const { delegate: n } = Wc; return (n?.clearInterval || clearInterval)(t) }, delegate: void 0 }; class jp extends JB { constructor(n, e) { super(n, e), this.scheduler = n, this.work = e, this.pending = !1 } schedule(n, e = 0) { var i; if (this.closed) return this; this.state = n; const o = this.id, r = this.scheduler; return null != o && (this.id = this.recycleAsyncId(r, o, e)), this.pending = !0, this.delay = e, this.id = null !== (i = this.id) && void 0 !== i ? i : this.requestAsyncId(r, this.id, e), this } requestAsyncId(n, e, i = 0) { return Wc.setInterval(n.flush.bind(n, this), i) } recycleAsyncId(n, e, i = 0) { if (null != i && this.delay === i && !1 === this.pending) return e; null != e && Wc.clearInterval(e) } execute(n, e) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const i = this._execute(n, e); if (i) return i; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(n, e) { let o, i = !1; try { this.work(n) } catch (r) { i = !0, o = r || new Error("Scheduled action threw falsy error") } if (i) return this.unsubscribe(), o } unsubscribe() { if (!this.closed) { const { id: n, scheduler: e } = this, { actions: i } = e; this.work = this.state = this.scheduler = null, this.pending = !1, Io(i, this), null != n && (this.id = this.recycleAsyncId(e, n, null)), this.delay = null, super.unsubscribe() } } } const Hp = { now: () => (Hp.delegate || Date).now(), delegate: void 0 }; class ma { constructor(n, e = ma.now) { this.schedulerActionCtor = n, this.now = e } schedule(n, e = 0, i) { return new this.schedulerActionCtor(this, n).schedule(i, e) } } ma.now = Hp.now; class Up extends ma { constructor(n, e = ma.now) { super(n, e), this.actions = [], this._active = !1 } flush(n) { const { actions: e } = this; if (this._active) return void e.push(n); let i; this._active = !0; do { if (i = n.execute(n.state, n.delay)) break } while (n = e.shift()); if (this._active = !1, i) { for (; n = e.shift();)n.unsubscribe(); throw i } } } const Yc = new Up(jp), ej = Yc; function OC(t, n = Yc) { return Pe((e, i) => { let o = null, r = null, s = null; const a = () => { if (o) { o.unsubscribe(), o = null; const c = r; r = null, i.next(c) } }; function l() { const c = s + t, d = n.now(); if (d < c) return o = this.schedule(void 0, c - d), void i.add(o); a() } e.subscribe(Ie(i, c => { r = c, s = n.now(), o || (o = n.schedule(l, t), i.add(o)) }, () => { a(), i.complete() }, void 0, () => { r = o = null })) }) } function at(t, n) { return Pe((e, i) => { let o = 0; e.subscribe(Ie(i, r => t.call(n, r, o++) && i.next(r))) }) } function kC(t) { return at((n, e) => t <= e) } function Ti(t) { return Pe((n, e) => { dt(t).subscribe(Ie(e, () => e.complete(), tl)), !e.closed && n.subscribe(e) }) } function lt(t) { return null != t && "false" != `${t}` } function FC(t, n = 0) { return function tj(t) { return !isNaN(parseFloat(t)) && !isNaN(Number(t)) }(t) ? Number(t) : n } function Zc(t) { return Array.isArray(t) ? t : [t] } function Ge(t) { return null == t ? "" : "string" == typeof t ? t : `${t}px` } function Ri(t) { return t instanceof ye ? t.nativeElement : t } let ij = (() => { class t { create(e) { return typeof MutationObserver > "u" ? null : new MutationObserver(e) } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), PC = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ providers: [ij] }) } return t })(); const { isArray: oj } = Array, { getPrototypeOf: rj, prototype: sj, keys: aj } = Object; function NC(t) { if (1 === t.length) { const n = t[0]; if (oj(n)) return { args: n, keys: null }; if (function lj(t) { return t && "object" == typeof t && rj(t) === sj }(n)) { const e = aj(n); return { args: e.map(i => n[i]), keys: e } } } return { args: t, keys: null } } const { isArray: cj } = Array; function zp(t) { return X(n => function dj(t, n) { return cj(n) ? t(...n) : t(n) }(t, n)) } function LC(t, n) { return t.reduce((e, i, o) => (e[i] = n[o], e), {}) } function Xc(...t) { const n = is(t), e = zg(t), { args: i, keys: o } = NC(t); if (0 === i.length) return Ye([], n); const r = new xe(function uj(t, n, e = pi) { return i => { VC(n, () => { const { length: o } = t, r = new Array(o); let s = o, a = o; for (let l = 0; l < o; l++)VC(n, () => { const c = Ye(t[l], n); let d = !1; c.subscribe(Ie(i, u => { r[l] = u, d || (d = !0, a--), a || i.next(e(r.slice())) }, () => { --s || i.complete() })) }, i) }, i) } }(i, n, o ? s => LC(o, s) : pi)); return e ? r.pipe(zp(e)) : r } function VC(t, n, e) { t ? Zn(e, t, n) : n() } function ga(...t) { return function hj() { return Ao(1) }()(Ye(t, is(t))) } function St(t) { return t <= 0 ? () => vn : Pe((n, e) => { let i = 0; n.subscribe(Ie(e, o => { ++i <= t && (e.next(o), t <= i && e.complete()) })) }) } function $p(...t) { const n = is(t); return Pe((e, i) => { (n ? ga(t, e, n) : ga(t, e)).subscribe(i) }) } const BC = new Set; let uo, fj = (() => { class t { constructor(e, i) { this._platform = e, this._nonce = i, this._matchMedia = this._platform.isBrowser && window.matchMedia ? window.matchMedia.bind(window) : mj } matchMedia(e) { return (this._platform.WEBKIT || this._platform.BLINK) && function pj(t, n) { if (!BC.has(t)) try { uo || (uo = document.createElement("style"), n && (uo.nonce = n), uo.setAttribute("type", "text/css"), document.head.appendChild(uo)), uo.sheet && (uo.sheet.insertRule(`@media ${t} {body{ }}`, 0), BC.add(t)) } catch (e) { console.error(e) } }(e, this._nonce), this._matchMedia(e) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(Bt), w(kh, 8)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); function mj(t) { return { matches: "all" === t || "" === t, media: t, addListener: () => { }, removeListener: () => { } } } let gj = (() => { class t { constructor(e, i) { this._mediaMatcher = e, this._zone = i, this._queries = new Map, this._destroySubject = new ie } ngOnDestroy() { this._destroySubject.next(), this._destroySubject.complete() } isMatched(e) { return jC(Zc(e)).some(o => this._registerQuery(o).mql.matches) } observe(e) { let r = Xc(jC(Zc(e)).map(s => this._registerQuery(s).observable)); return r = ga(r.pipe(St(1)), r.pipe(kC(1), OC(0))), r.pipe(X(s => { const a = { matches: !1, breakpoints: {} }; return s.forEach(({ matches: l, query: c }) => { a.matches = a.matches || l, a.breakpoints[c] = l }), a })) } _registerQuery(e) { if (this._queries.has(e)) return this._queries.get(e); const i = this._mediaMatcher.matchMedia(e), r = { observable: new xe(s => { const a = l => this._zone.run(() => s.next(l)); return i.addListener(a), () => { i.removeListener(a) } }).pipe($p(i), X(({ matches: s }) => ({ query: e, matches: s })), Ti(this._destroySubject)), mql: i }; return this._queries.set(e, r), r } static #e = this.\u0275fac = function (i) { return new (i || t)(w(fj), w(z)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); function jC(t) { return t.map(n => n.split(",")).reduce((n, e) => n.concat(e)).map(n => n.trim()) } function UC(t, n, e) { const i = zC(t, n); i.some(o => o.trim() == e.trim()) || (i.push(e.trim()), t.setAttribute(n, i.join(" "))) } function Gp(t, n, e) { const o = zC(t, n).filter(r => r != e.trim()); o.length ? t.setAttribute(n, o.join(" ")) : t.removeAttribute(n) } function zC(t, n) { return (t.getAttribute(n) || "").match(/\S+/g) || [] } class bj { constructor(n) { this._items = n, this._activeItemIndex = -1, this._activeItem = null, this._wrap = !1, this._letterKeyStream = new ie, this._typeaheadSubscription = Fe.EMPTY, this._vertical = !0, this._allowedModifierKeys = [], this._homeAndEnd = !1, this._pageUpAndDown = { enabled: !1, delta: 10 }, this._skipPredicateFn = e => e.disabled, this._pressedLetters = [], this.tabOut = new ie, this.change = new ie, n instanceof ra && (this._itemChangesSubscription = n.changes.subscribe(e => { if (this._activeItem) { const o = e.toArray().indexOf(this._activeItem); o > -1 && o !== this._activeItemIndex && (this._activeItemIndex = o) } })) } skipPredicate(n) { return this._skipPredicateFn = n, this } withWrap(n = !0) { return this._wrap = n, this } withVerticalOrientation(n = !0) { return this._vertical = n, this } withHorizontalOrientation(n) { return this._horizontal = n, this } withAllowedModifierKeys(n) { return this._allowedModifierKeys = n, this } withTypeAhead(n = 200) { return this._typeaheadSubscription.unsubscribe(), this._typeaheadSubscription = this._letterKeyStream.pipe(Ue(e => this._pressedLetters.push(e)), OC(n), at(() => this._pressedLetters.length > 0), X(() => this._pressedLetters.join(""))).subscribe(e => { const i = this._getItemsArray(); for (let o = 1; o < i.length + 1; o++) { const r = (this._activeItemIndex + o) % i.length, s = i[r]; if (!this._skipPredicateFn(s) && 0 === s.getLabel().toUpperCase().trim().indexOf(e)) { this.setActiveItem(r); break } } this._pressedLetters = [] }), this } cancelTypeahead() { return this._pressedLetters = [], this } withHomeAndEnd(n = !0) { return this._homeAndEnd = n, this } withPageUpDown(n = !0, e = 10) { return this._pageUpAndDown = { enabled: n, delta: e }, this } setActiveItem(n) { const e = this._activeItem; this.updateActiveItem(n), this._activeItem !== e && this.change.next(this._activeItemIndex) } onKeydown(n) { const e = n.keyCode, o = ["altKey", "ctrlKey", "metaKey", "shiftKey"].every(r => !n[r] || this._allowedModifierKeys.indexOf(r) > -1); switch (e) { case 9: return void this.tabOut.next(); case 40: if (this._vertical && o) { this.setNextItemActive(); break } return; case 38: if (this._vertical && o) { this.setPreviousItemActive(); break } return; case 39: if (this._horizontal && o) { "rtl" === this._horizontal ? this.setPreviousItemActive() : this.setNextItemActive(); break } return; case 37: if (this._horizontal && o) { "rtl" === this._horizontal ? this.setNextItemActive() : this.setPreviousItemActive(); break } return; case 36: if (this._homeAndEnd && o) { this.setFirstItemActive(); break } return; case 35: if (this._homeAndEnd && o) { this.setLastItemActive(); break } return; case 33: if (this._pageUpAndDown.enabled && o) { const r = this._activeItemIndex - this._pageUpAndDown.delta; this._setActiveItemByIndex(r > 0 ? r : 0, 1); break } return; case 34: if (this._pageUpAndDown.enabled && o) { const r = this._activeItemIndex + this._pageUpAndDown.delta, s = this._getItemsArray().length; this._setActiveItemByIndex(r < s ? r : s - 1, -1); break } return; default: return void ((o || pa(n, "shiftKey")) && (n.key && 1 === n.key.length ? this._letterKeyStream.next(n.key.toLocaleUpperCase()) : (e >= 65 && e <= 90 || e >= 48 && e <= 57) && this._letterKeyStream.next(String.fromCharCode(e)))) }this._pressedLetters = [], n.preventDefault() } get activeItemIndex() { return this._activeItemIndex } get activeItem() { return this._activeItem } isTyping() { return this._pressedLetters.length > 0 } setFirstItemActive() { this._setActiveItemByIndex(0, 1) } setLastItemActive() { this._setActiveItemByIndex(this._items.length - 1, -1) } setNextItemActive() { this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1) } setPreviousItemActive() { this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1) } updateActiveItem(n) { const e = this._getItemsArray(), i = "number" == typeof n ? n : e.indexOf(n); this._activeItem = e[i] ?? null, this._activeItemIndex = i } destroy() { this._typeaheadSubscription.unsubscribe(), this._itemChangesSubscription?.unsubscribe(), this._letterKeyStream.complete(), this.tabOut.complete(), this.change.complete(), this._pressedLetters = [] } _setActiveItemByDelta(n) { this._wrap ? this._setActiveInWrapMode(n) : this._setActiveInDefaultMode(n) } _setActiveInWrapMode(n) { const e = this._getItemsArray(); for (let i = 1; i <= e.length; i++) { const o = (this._activeItemIndex + n * i + e.length) % e.length; if (!this._skipPredicateFn(e[o])) return void this.setActiveItem(o) } } _setActiveInDefaultMode(n) { this._setActiveItemByIndex(this._activeItemIndex + n, n) } _setActiveItemByIndex(n, e) { const i = this._getItemsArray(); if (i[n]) { for (; this._skipPredicateFn(i[n]);)if (!i[n += e]) return; this.setActiveItem(n) } } _getItemsArray() { return this._items instanceof ra ? this._items.toArray() : this._items } } class yj extends bj { setActiveItem(n) { this.activeItem && this.activeItem.setInactiveStyles(), super.setActiveItem(n), this.activeItem && this.activeItem.setActiveStyles() } } function GC(t) { return 0 === t.buttons || 0 === t.detail } function qC(t) { const n = t.touches && t.touches[0] || t.changedTouches && t.changedTouches[0]; return !(!n || -1 !== n.identifier || null != n.radiusX && 1 !== n.radiusX || null != n.radiusY && 1 !== n.radiusY) } const Sj = new E("cdk-input-modality-detector-options"), Mj = { ignoreKeys: [18, 17, 224, 91, 16] }, Or = Rr({ passive: !0, capture: !0 }); let Ij = (() => { class t { get mostRecentModality() { return this._modality.value } constructor(e, i, o, r) { this._platform = e, this._mostRecentTarget = null, this._modality = new At(null), this._lastTouchMs = 0, this._onKeydown = s => { this._options?.ignoreKeys?.some(a => a === s.keyCode) || (this._modality.next("keyboard"), this._mostRecentTarget = li(s)) }, this._onMousedown = s => { Date.now() - this._lastTouchMs < 650 || (this._modality.next(GC(s) ? "keyboard" : "mouse"), this._mostRecentTarget = li(s)) }, this._onTouchstart = s => { qC(s) ? this._modality.next("keyboard") : (this._lastTouchMs = Date.now(), this._modality.next("touch"), this._mostRecentTarget = li(s)) }, this._options = { ...Mj, ...r }, this.modalityDetected = this._modality.pipe(kC(1)), this.modalityChanged = this.modalityDetected.pipe(Wg()), e.isBrowser && i.runOutsideAngular(() => { o.addEventListener("keydown", this._onKeydown, Or), o.addEventListener("mousedown", this._onMousedown, Or), o.addEventListener("touchstart", this._onTouchstart, Or) }) } ngOnDestroy() { this._modality.complete(), this._platform.isBrowser && (document.removeEventListener("keydown", this._onKeydown, Or), document.removeEventListener("mousedown", this._onMousedown, Or), document.removeEventListener("touchstart", this._onTouchstart, Or)) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(Bt), w(z), w(te), w(Sj, 8)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); const Tj = new E("cdk-focus-monitor-default-options"), Kc = Rr({ passive: !0, capture: !0 }); let Rj = (() => { class t { constructor(e, i, o, r, s) { this._ngZone = e, this._platform = i, this._inputModalityDetector = o, this._origin = null, this._windowFocused = !1, this._originFromTouchInteraction = !1, this._elementInfo = new Map, this._monitoredElementCount = 0, this._rootNodeFocusListenerCount = new Map, this._windowFocusListener = () => { this._windowFocused = !0, this._windowFocusTimeoutId = window.setTimeout(() => this._windowFocused = !1) }, this._stopInputModalityDetector = new ie, this._rootNodeFocusAndBlurListener = a => { for (let c = li(a); c; c = c.parentElement)"focus" === a.type ? this._onFocus(a, c) : this._onBlur(a, c) }, this._document = r, this._detectionMode = s?.detectionMode || 0 } monitor(e, i = !1) { const o = Ri(e); if (!this._platform.isBrowser || 1 !== o.nodeType) return N(); const r = function NB(t) { if (function PB() { if (null == Lp) { const t = typeof document < "u" ? document.head : null; Lp = !(!t || !t.createShadowRoot && !t.attachShadow) } return Lp }()) { const n = t.getRootNode ? t.getRootNode() : null; if (typeof ShadowRoot < "u" && ShadowRoot && n instanceof ShadowRoot) return n } return null }(o) || this._getDocument(), s = this._elementInfo.get(o); if (s) return i && (s.checkChildren = !0), s.subject; const a = { checkChildren: i, subject: new ie, rootNode: r }; return this._elementInfo.set(o, a), this._registerGlobalListeners(a), a.subject } stopMonitoring(e) { const i = Ri(e), o = this._elementInfo.get(i); o && (o.subject.complete(), this._setClasses(i), this._elementInfo.delete(i), this._removeGlobalListeners(o)) } focusVia(e, i, o) { const r = Ri(e); r === this._getDocument().activeElement ? this._getClosestElementsInfo(r).forEach(([a, l]) => this._originChanged(a, i, l)) : (this._setOrigin(i), "function" == typeof r.focus && r.focus(o)) } ngOnDestroy() { this._elementInfo.forEach((e, i) => this.stopMonitoring(i)) } _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _getFocusOrigin(e) { return this._origin ? this._originFromTouchInteraction ? this._shouldBeAttributedToTouch(e) ? "touch" : "program" : this._origin : this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : e && this._isLastInteractionFromInputLabel(e) ? "mouse" : "program" } _shouldBeAttributedToTouch(e) { return 1 === this._detectionMode || !!e?.contains(this._inputModalityDetector._mostRecentTarget) } _setClasses(e, i) { e.classList.toggle("cdk-focused", !!i), e.classList.toggle("cdk-touch-focused", "touch" === i), e.classList.toggle("cdk-keyboard-focused", "keyboard" === i), e.classList.toggle("cdk-mouse-focused", "mouse" === i), e.classList.toggle("cdk-program-focused", "program" === i) } _setOrigin(e, i = !1) { this._ngZone.runOutsideAngular(() => { this._origin = e, this._originFromTouchInteraction = "touch" === e && i, 0 === this._detectionMode && (clearTimeout(this._originTimeoutId), this._originTimeoutId = setTimeout(() => this._origin = null, this._originFromTouchInteraction ? 650 : 1)) }) } _onFocus(e, i) { const o = this._elementInfo.get(i), r = li(e); !o || !o.checkChildren && i !== r || this._originChanged(i, this._getFocusOrigin(r), o) } _onBlur(e, i) { const o = this._elementInfo.get(i); !o || o.checkChildren && e.relatedTarget instanceof Node && i.contains(e.relatedTarget) || (this._setClasses(i), this._emitOrigin(o, null)) } _emitOrigin(e, i) { e.subject.observers.length && this._ngZone.run(() => e.subject.next(i)) } _registerGlobalListeners(e) { if (!this._platform.isBrowser) return; const i = e.rootNode, o = this._rootNodeFocusListenerCount.get(i) || 0; o || this._ngZone.runOutsideAngular(() => { i.addEventListener("focus", this._rootNodeFocusAndBlurListener, Kc), i.addEventListener("blur", this._rootNodeFocusAndBlurListener, Kc) }), this._rootNodeFocusListenerCount.set(i, o + 1), 1 == ++this._monitoredElementCount && (this._ngZone.runOutsideAngular(() => { this._getWindow().addEventListener("focus", this._windowFocusListener) }), this._inputModalityDetector.modalityDetected.pipe(Ti(this._stopInputModalityDetector)).subscribe(r => { this._setOrigin(r, !0) })) } _removeGlobalListeners(e) { const i = e.rootNode; if (this._rootNodeFocusListenerCount.has(i)) { const o = this._rootNodeFocusListenerCount.get(i); o > 1 ? this._rootNodeFocusListenerCount.set(i, o - 1) : (i.removeEventListener("focus", this._rootNodeFocusAndBlurListener, Kc), i.removeEventListener("blur", this._rootNodeFocusAndBlurListener, Kc), this._rootNodeFocusListenerCount.delete(i)) } --this._monitoredElementCount || (this._getWindow().removeEventListener("focus", this._windowFocusListener), this._stopInputModalityDetector.next(), clearTimeout(this._windowFocusTimeoutId), clearTimeout(this._originTimeoutId)) } _originChanged(e, i, o) { this._setClasses(e, i), this._emitOrigin(o, i), this._lastFocusOrigin = i } _getClosestElementsInfo(e) { const i = []; return this._elementInfo.forEach((o, r) => { (r === e || o.checkChildren && r.contains(e)) && i.push([r, o]) }), i } _isLastInteractionFromInputLabel(e) { const { _mostRecentTarget: i, mostRecentModality: o } = this._inputModalityDetector; if ("mouse" !== o || !i || i === e || "INPUT" !== e.nodeName && "TEXTAREA" !== e.nodeName || e.disabled) return !1; const r = e.labels; if (r) for (let s = 0; s < r.length; s++)if (r[s].contains(i)) return !0; return !1 } static #e = this.\u0275fac = function (i) { return new (i || t)(w(z), w(Bt), w(Ij), w(te, 8), w(Tj, 8)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); const YC = "cdk-high-contrast-black-on-white", ZC = "cdk-high-contrast-white-on-black", qp = "cdk-high-contrast-active"; let XC = (() => { class t { constructor(e, i) { this._platform = e, this._document = i, this._breakpointSubscription = T(gj).observe("(forced-colors: active)").subscribe(() => { this._hasCheckedHighContrastMode && (this._hasCheckedHighContrastMode = !1, this._applyBodyHighContrastModeCssClasses()) }) } getHighContrastMode() { if (!this._platform.isBrowser) return 0; const e = this._document.createElement("div"); e.style.backgroundColor = "rgb(1,2,3)", e.style.position = "absolute", this._document.body.appendChild(e); const i = this._document.defaultView || window, o = i && i.getComputedStyle ? i.getComputedStyle(e) : null, r = (o && o.backgroundColor || "").replace(/ /g, ""); switch (e.remove(), r) { case "rgb(0,0,0)": case "rgb(45,50,54)": case "rgb(32,32,32)": return 2; case "rgb(255,255,255)": case "rgb(255,250,239)": return 1 }return 0 } ngOnDestroy() { this._breakpointSubscription.unsubscribe() } _applyBodyHighContrastModeCssClasses() { if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) { const e = this._document.body.classList; e.remove(qp, YC, ZC), this._hasCheckedHighContrastMode = !0; const i = this.getHighContrastMode(); 1 === i ? e.add(qp, YC) : 2 === i && e.add(qp, ZC) } } static #e = this.\u0275fac = function (i) { return new (i || t)(w(Bt), w(te)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), Oj = (() => { class t { constructor(e) { e._applyBodyHighContrastModeCssClasses() } static #e = this.\u0275fac = function (i) { return new (i || t)(w(XC)) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ imports: [PC] }) } return t })(); const kj = new E("cdk-dir-doc", { providedIn: "root", factory: function Fj() { return T(te) } }), Pj = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i; let Wp = (() => { class t { constructor(e) { this.value = "ltr", this.change = new ue, e && (this.value = function Nj(t) { const n = t?.toLowerCase() || ""; return "auto" === n && typeof navigator < "u" && navigator?.language ? Pj.test(navigator.language) ? "rtl" : "ltr" : "rtl" === n ? "rtl" : "ltr" }((e.body ? e.body.dir : null) || (e.documentElement ? e.documentElement.dir : null) || "ltr")) } ngOnDestroy() { this.change.complete() } static #e = this.\u0275fac = function (i) { return new (i || t)(w(kj, 8)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), _a = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({}) } return t })(); const Lj = ["text"]; function Vj(t, n) { if (1 & t && U(0, "mat-pseudo-checkbox", 6), 2 & t) { const e = Le(); k("disabled", e.disabled)("state", e.selected ? "checked" : "unchecked") } } function Bj(t, n) { 1 & t && U(0, "mat-pseudo-checkbox", 7), 2 & t && k("disabled", Le().disabled) } function jj(t, n) { if (1 & t && (x(0, "span", 8), A(1), y()), 2 & t) { const e = Le(); S(1), ln("(", e.group.label, ")") } } const Hj = [[["mat-icon"]], "*"], Uj = ["mat-icon", "*"], $j = new E("mat-sanity-checks", { providedIn: "root", factory: function zj() { return !0 } }); let qe = (() => { class t { constructor(e, i, o) { this._sanityChecks = i, this._document = o, this._hasDoneGlobalChecks = !1, e._applyBodyHighContrastModeCssClasses(), this._hasDoneGlobalChecks || (this._hasDoneGlobalChecks = !0) } _checkIsEnabled(e) { return !Vp() && ("boolean" == typeof this._sanityChecks ? this._sanityChecks : !!this._sanityChecks[e]) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(XC), w($j, 8), w(te)) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ imports: [_a, _a] }) } return t })(); function Gj(t, n) { return class extends t { get color() { return this._color } set color(e) { const i = e || this.defaultColor; i !== this._color && (this._color && this._elementRef.nativeElement.classList.remove(`mat-${this._color}`), i && this._elementRef.nativeElement.classList.add(`mat-${i}`), this._color = i) } constructor(...e) { super(...e), this.defaultColor = n, this.color = n } } } function JC(t) { return class extends t { get disableRipple() { return this._disableRipple } set disableRipple(n) { this._disableRipple = lt(n) } constructor(...n) { super(...n), this._disableRipple = !1 } } } function qj(t, n = 0) { return class extends t { get tabIndex() { return this.disabled ? -1 : this._tabIndex } set tabIndex(e) { this._tabIndex = null != e ? FC(e) : this.defaultTabIndex } constructor(...e) { super(...e), this._tabIndex = n, this.defaultTabIndex = n } } } function Wj(t) { return class extends t { updateErrorState() { const n = this.errorState, r = (this.errorStateMatcher || this._defaultErrorStateMatcher).isErrorState(this.ngControl ? this.ngControl.control : null, this._parentFormGroup || this._parentForm); r !== n && (this.errorState = r, this.stateChanges.next()) } constructor(...n) { super(...n), this.errorState = !1 } } } let Zj = (() => { class t { isErrorState(e, i) { return !!(e && e.invalid && (e.touched || i && i.submitted)) } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); class Xj { constructor(n, e, i, o = !1) { this._renderer = n, this.element = e, this.config = i, this._animationForciblyDisabledThroughCss = o, this.state = 3 } fadeOut() { this._renderer.fadeOutRipple(this) } } const eD = Rr({ passive: !0, capture: !0 }); class Kj { constructor() { this._events = new Map, this._delegateEventHandler = n => { const e = li(n); e && this._events.get(n.type)?.forEach((i, o) => { (o === e || o.contains(e)) && i.forEach(r => r.handleEvent(n)) }) } } addHandler(n, e, i, o) { const r = this._events.get(e); if (r) { const s = r.get(i); s ? s.add(o) : r.set(i, new Set([o])) } else this._events.set(e, new Map([[i, new Set([o])]])), n.runOutsideAngular(() => { document.addEventListener(e, this._delegateEventHandler, eD) }) } removeHandler(n, e, i) { const o = this._events.get(n); if (!o) return; const r = o.get(e); r && (r.delete(i), 0 === r.size && o.delete(e), 0 === o.size && (this._events.delete(n), document.removeEventListener(n, this._delegateEventHandler, eD))) } } const tD = { enterDuration: 225, exitDuration: 150 }, nD = Rr({ passive: !0, capture: !0 }), iD = ["mousedown", "touchstart"], oD = ["mouseup", "mouseleave", "touchend", "touchcancel"]; class Qc { static #e = this._eventManager = new Kj; constructor(n, e, i, o) { this._target = n, this._ngZone = e, this._platform = o, this._isPointerDown = !1, this._activeRipples = new Map, this._pointerUpEventsRegistered = !1, o.isBrowser && (this._containerElement = Ri(i)) } fadeInRipple(n, e, i = {}) { const o = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect(), r = { ...tD, ...i.animation }; i.centered && (n = o.left + o.width / 2, e = o.top + o.height / 2); const s = i.radius || function Jj(t, n, e) { const i = Math.max(Math.abs(t - e.left), Math.abs(t - e.right)), o = Math.max(Math.abs(n - e.top), Math.abs(n - e.bottom)); return Math.sqrt(i * i + o * o) }(n, e, o), a = n - o.left, l = e - o.top, c = r.enterDuration, d = document.createElement("div"); d.classList.add("mat-ripple-element"), d.style.left = a - s + "px", d.style.top = l - s + "px", d.style.height = 2 * s + "px", d.style.width = 2 * s + "px", null != i.color && (d.style.backgroundColor = i.color), d.style.transitionDuration = `${c}ms`, this._containerElement.appendChild(d); const u = window.getComputedStyle(d), f = u.transitionDuration, p = "none" === u.transitionProperty || "0s" === f || "0s, 0s" === f || 0 === o.width && 0 === o.height, m = new Xj(this, d, i, p); d.style.transform = "scale3d(1, 1, 1)", m.state = 0, i.persistent || (this._mostRecentTransientRipple = m); let _ = null; return !p && (c || r.exitDuration) && this._ngZone.runOutsideAngular(() => { const C = () => this._finishRippleTransition(m), v = () => this._destroyRipple(m); d.addEventListener("transitionend", C), d.addEventListener("transitioncancel", v), _ = { onTransitionEnd: C, onTransitionCancel: v } }), this._activeRipples.set(m, _), (p || !c) && this._finishRippleTransition(m), m } fadeOutRipple(n) { if (2 === n.state || 3 === n.state) return; const e = n.element, i = { ...tD, ...n.config.animation }; e.style.transitionDuration = `${i.exitDuration}ms`, e.style.opacity = "0", n.state = 2, (n._animationForciblyDisabledThroughCss || !i.exitDuration) && this._finishRippleTransition(n) } fadeOutAll() { this._getActiveRipples().forEach(n => n.fadeOut()) } fadeOutAllNonPersistent() { this._getActiveRipples().forEach(n => { n.config.persistent || n.fadeOut() }) } setupTriggerEvents(n) { const e = Ri(n); !this._platform.isBrowser || !e || e === this._triggerElement || (this._removeTriggerEvents(), this._triggerElement = e, iD.forEach(i => { Qc._eventManager.addHandler(this._ngZone, i, e, this) })) } handleEvent(n) { "mousedown" === n.type ? this._onMousedown(n) : "touchstart" === n.type ? this._onTouchStart(n) : this._onPointerUp(), this._pointerUpEventsRegistered || (this._ngZone.runOutsideAngular(() => { oD.forEach(e => { this._triggerElement.addEventListener(e, this, nD) }) }), this._pointerUpEventsRegistered = !0) } _finishRippleTransition(n) { 0 === n.state ? this._startFadeOutTransition(n) : 2 === n.state && this._destroyRipple(n) } _startFadeOutTransition(n) { const e = n === this._mostRecentTransientRipple, { persistent: i } = n.config; n.state = 1, !i && (!e || !this._isPointerDown) && n.fadeOut() } _destroyRipple(n) { const e = this._activeRipples.get(n) ?? null; this._activeRipples.delete(n), this._activeRipples.size || (this._containerRect = null), n === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null), n.state = 3, null !== e && (n.element.removeEventListener("transitionend", e.onTransitionEnd), n.element.removeEventListener("transitioncancel", e.onTransitionCancel)), n.element.remove() } _onMousedown(n) { const e = GC(n), i = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + 800; !this._target.rippleDisabled && !e && !i && (this._isPointerDown = !0, this.fadeInRipple(n.clientX, n.clientY, this._target.rippleConfig)) } _onTouchStart(n) { if (!this._target.rippleDisabled && !qC(n)) { this._lastTouchStartEvent = Date.now(), this._isPointerDown = !0; const e = n.changedTouches; if (e) for (let i = 0; i < e.length; i++)this.fadeInRipple(e[i].clientX, e[i].clientY, this._target.rippleConfig) } } _onPointerUp() { this._isPointerDown && (this._isPointerDown = !1, this._getActiveRipples().forEach(n => { !n.config.persistent && (1 === n.state || n.config.terminateOnPointerUp && 0 === n.state) && n.fadeOut() })) } _getActiveRipples() { return Array.from(this._activeRipples.keys()) } _removeTriggerEvents() { const n = this._triggerElement; n && (iD.forEach(e => Qc._eventManager.removeHandler(e, n, this)), this._pointerUpEventsRegistered && oD.forEach(e => n.removeEventListener(e, this, nD))) } } const eH = new E("mat-ripple-global-options"); let rD = (() => { class t { get disabled() { return this._disabled } set disabled(e) { e && this.fadeOutAllNonPersistent(), this._disabled = e, this._setupTriggerEventsIfEnabled() } get trigger() { return this._trigger || this._elementRef.nativeElement } set trigger(e) { this._trigger = e, this._setupTriggerEventsIfEnabled() } constructor(e, i, o, r, s) { this._elementRef = e, this._animationMode = s, this.radius = 0, this._disabled = !1, this._isInitialized = !1, this._globalOptions = r || {}, this._rippleRenderer = new Qc(this, i, e, o) } ngOnInit() { this._isInitialized = !0, this._setupTriggerEventsIfEnabled() } ngOnDestroy() { this._rippleRenderer._removeTriggerEvents() } fadeOutAll() { this._rippleRenderer.fadeOutAll() } fadeOutAllNonPersistent() { this._rippleRenderer.fadeOutAllNonPersistent() } get rippleConfig() { return { centered: this.centered, radius: this.radius, color: this.color, animation: { ...this._globalOptions.animation, ..."NoopAnimations" === this._animationMode ? { enterDuration: 0, exitDuration: 0 } : {}, ...this.animation }, terminateOnPointerUp: this._globalOptions.terminateOnPointerUp } } get rippleDisabled() { return this.disabled || !!this._globalOptions.disabled } _setupTriggerEventsIfEnabled() { !this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger) } launch(e, i = 0, o) { return "number" == typeof e ? this._rippleRenderer.fadeInRipple(e, i, { ...this.rippleConfig, ...o }) : this._rippleRenderer.fadeInRipple(0, 0, { ...this.rippleConfig, ...e }) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(ye), g(z), g(Bt), g(eH, 8), g(eo, 8)) }; static #t = this.\u0275dir = P({ type: t, selectors: [["", "mat-ripple", ""], ["", "matRipple", ""]], hostAttrs: [1, "mat-ripple"], hostVars: 2, hostBindings: function (i, o) { 2 & i && Je("mat-ripple-unbounded", o.unbounded) }, inputs: { color: ["matRippleColor", "color"], unbounded: ["matRippleUnbounded", "unbounded"], centered: ["matRippleCentered", "centered"], radius: ["matRippleRadius", "radius"], animation: ["matRippleAnimation", "animation"], disabled: ["matRippleDisabled", "disabled"], trigger: ["matRippleTrigger", "trigger"] }, exportAs: ["matRipple"] }) } return t })(), Yp = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ imports: [qe, qe] }) } return t })(), tH = (() => { class t { constructor(e) { this._animationMode = e, this.state = "unchecked", this.disabled = !1, this.appearance = "full" } static #e = this.\u0275fac = function (i) { return new (i || t)(g(eo, 8)) }; static #t = this.\u0275cmp = tt({ type: t, selectors: [["mat-pseudo-checkbox"]], hostAttrs: [1, "mat-pseudo-checkbox"], hostVars: 12, hostBindings: function (i, o) { 2 & i && Je("mat-pseudo-checkbox-indeterminate", "indeterminate" === o.state)("mat-pseudo-checkbox-checked", "checked" === o.state)("mat-pseudo-checkbox-disabled", o.disabled)("mat-pseudo-checkbox-minimal", "minimal" === o.appearance)("mat-pseudo-checkbox-full", "full" === o.appearance)("_mat-animation-noopable", "NoopAnimations" === o._animationMode) }, inputs: { state: "state", disabled: "disabled", appearance: "appearance" }, decls: 0, vars: 0, template: function (i, o) { }, styles: ['.mat-pseudo-checkbox{border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox._mat-animation-noopable{transition:none !important;animation:none !important}.mat-pseudo-checkbox._mat-animation-noopable::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{left:1px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{left:1px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}.mat-pseudo-checkbox-full{border:2px solid}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate{border-color:rgba(0,0,0,0)}.mat-pseudo-checkbox{width:18px;height:18px}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-checked::after{width:14px;height:6px;transform-origin:center;top:-4.2426406871px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-indeterminate::after{top:8px;width:16px}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked::after{width:10px;height:4px;transform-origin:center;top:-2.8284271247px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate::after{top:6px;width:12px}'], encapsulation: 2, changeDetection: 0 }) } return t })(), nH = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ imports: [qe] }) } return t })(); const sD = new E("MAT_OPTION_PARENT_COMPONENT"), aD = new E("MatOptgroup"); let iH = 0; class lD { constructor(n, e = !1) { this.source = n, this.isUserInput = e } } let oH = (() => { class t { get multiple() { return this._parent && this._parent.multiple } get selected() { return this._selected } get disabled() { return this.group && this.group.disabled || this._disabled } set disabled(e) { this._disabled = lt(e) } get disableRipple() { return !(!this._parent || !this._parent.disableRipple) } get hideSingleSelectionIndicator() { return !(!this._parent || !this._parent.hideSingleSelectionIndicator) } constructor(e, i, o, r) { this._element = e, this._changeDetectorRef = i, this._parent = o, this.group = r, this._selected = !1, this._active = !1, this._disabled = !1, this._mostRecentViewValue = "", this.id = "mat-option-" + iH++, this.onSelectionChange = new ue, this._stateChanges = new ie } get active() { return this._active } get viewValue() { return (this._text?.nativeElement.textContent || "").trim() } select(e = !0) { this._selected || (this._selected = !0, this._changeDetectorRef.markForCheck(), e && this._emitSelectionChangeEvent()) } deselect(e = !0) { this._selected && (this._selected = !1, this._changeDetectorRef.markForCheck(), e && this._emitSelectionChangeEvent()) } focus(e, i) { const o = this._getHostElement(); "function" == typeof o.focus && o.focus(i) } setActiveStyles() { this._active || (this._active = !0, this._changeDetectorRef.markForCheck()) } setInactiveStyles() { this._active && (this._active = !1, this._changeDetectorRef.markForCheck()) } getLabel() { return this.viewValue } _handleKeydown(e) { (13 === e.keyCode || 32 === e.keyCode) && !pa(e) && (this._selectViaInteraction(), e.preventDefault()) } _selectViaInteraction() { this.disabled || (this._selected = !this.multiple || !this._selected, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent(!0)) } _getTabIndex() { return this.disabled ? "-1" : "0" } _getHostElement() { return this._element.nativeElement } ngAfterViewChecked() { if (this._selected) { const e = this.viewValue; e !== this._mostRecentViewValue && (this._mostRecentViewValue && this._stateChanges.next(), this._mostRecentViewValue = e) } } ngOnDestroy() { this._stateChanges.complete() } _emitSelectionChangeEvent(e = !1) { this.onSelectionChange.emit(new lD(this, e)) } static #e = this.\u0275fac = function (i) { ic() }; static #t = this.\u0275dir = P({ type: t, viewQuery: function (i, o) { if (1 & i && dn(Lj, 7), 2 & i) { let r; Re(r = Oe()) && (o._text = r.first) } }, inputs: { value: "value", id: "id", disabled: "disabled" }, outputs: { onSelectionChange: "onSelectionChange" } }) } return t })(), cD = (() => { class t extends oH { constructor(e, i, o, r) { super(e, i, o, r) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(ye), g(Un), g(sD, 8), g(aD, 8)) }; static #t = this.\u0275cmp = tt({ type: t, selectors: [["mat-option"]], hostAttrs: ["role", "option", 1, "mat-mdc-option", "mdc-list-item"], hostVars: 11, hostBindings: function (i, o) { 1 & i && se("click", function () { return o._selectViaInteraction() })("keydown", function (s) { return o._handleKeydown(s) }), 2 & i && (Ks("id", o.id), Ke("aria-selected", o.selected)("aria-disabled", o.disabled.toString()), Je("mdc-list-item--selected", o.selected)("mat-mdc-option-multiple", o.multiple)("mat-mdc-option-active", o.active)("mdc-list-item--disabled", o.disabled)) }, exportAs: ["matOption"], features: [K], ngContentSelectors: Uj, decls: 8, vars: 5, consts: [["class", "mat-mdc-option-pseudo-checkbox", "aria-hidden", "true", 3, "disabled", "state", 4, "ngIf"], [1, "mdc-list-item__primary-text"], ["text", ""], ["class", "mat-mdc-option-pseudo-checkbox", "state", "checked", "aria-hidden", "true", "appearance", "minimal", 3, "disabled", 4, "ngIf"], ["class", "cdk-visually-hidden", 4, "ngIf"], ["aria-hidden", "true", "mat-ripple", "", 1, "mat-mdc-option-ripple", "mat-mdc-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled"], ["aria-hidden", "true", 1, "mat-mdc-option-pseudo-checkbox", 3, "disabled", "state"], ["state", "checked", "aria-hidden", "true", "appearance", "minimal", 1, "mat-mdc-option-pseudo-checkbox", 3, "disabled"], [1, "cdk-visually-hidden"]], template: function (i, o) { 1 & i && (io(Hj), Q(0, Vj, 1, 2, "mat-pseudo-checkbox", 0), mt(1), x(2, "span", 1, 2), mt(4, 1), y(), Q(5, Bj, 1, 1, "mat-pseudo-checkbox", 3), Q(6, jj, 2, 1, "span", 4), U(7, "div", 5)), 2 & i && (k("ngIf", o.multiple), S(5), k("ngIf", !o.multiple && o.selected && !o.hideSingleSelectionIndicator), S(1), k("ngIf", o.group && o.group._inert), S(1), k("matRippleTrigger", o._getHostElement())("matRippleDisabled", o.disabled || o.disableRipple)) }, dependencies: [rD, Ii, tH], styles: ['.mat-mdc-option{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:16px;padding-right:16px;-webkit-user-select:none;user-select:none;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;cursor:pointer;-webkit-tap-highlight-color:rgba(0,0,0,0);color:var(--mat-option-label-text-color);font-family:var(--mat-option-label-text-font);line-height:var(--mat-option-label-text-line-height);font-size:var(--mat-option-label-text-size);letter-spacing:var(--mat-option-label-text-tracking);font-weight:var(--mat-option-label-text-weight);min-height:48px}.mat-mdc-option:focus{outline:none}[dir=rtl] .mat-mdc-option,.mat-mdc-option[dir=rtl]{padding-left:16px;padding-right:16px}.mat-mdc-option:hover:not(.mdc-list-item--disabled){background-color:var(--mat-option-hover-state-layer-color)}.mat-mdc-option:focus.mdc-list-item,.mat-mdc-option.mat-mdc-option-active.mdc-list-item{background-color:var(--mat-option-focus-state-layer-color)}.mat-mdc-option.mdc-list-item--selected:not(.mdc-list-item--disabled) .mdc-list-item__primary-text{color:var(--mat-option-selected-state-label-text-color)}.mat-mdc-option.mdc-list-item--selected:not(.mdc-list-item--disabled):not(.mat-mdc-option-multiple){background-color:var(--mat-option-selected-state-layer-color)}.mat-mdc-option.mdc-list-item{align-items:center}.mat-mdc-option.mdc-list-item--disabled{cursor:default;pointer-events:none}.mat-mdc-option.mdc-list-item--disabled .mat-mdc-option-pseudo-checkbox,.mat-mdc-option.mdc-list-item--disabled .mdc-list-item__primary-text,.mat-mdc-option.mdc-list-item--disabled>mat-icon{opacity:.38}.mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:32px}[dir=rtl] .mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:16px;padding-right:32px}.mat-mdc-option .mat-icon,.mat-mdc-option .mat-pseudo-checkbox-full{margin-right:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-icon,[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-full{margin-right:0;margin-left:16px}.mat-mdc-option .mat-pseudo-checkbox-minimal{margin-left:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-minimal{margin-right:16px;margin-left:0}.mat-mdc-option .mat-mdc-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-mdc-option .mdc-list-item__primary-text{white-space:normal;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;font-family:inherit;text-decoration:inherit;text-transform:inherit;margin-right:auto}[dir=rtl] .mat-mdc-option .mdc-list-item__primary-text{margin-right:0;margin-left:auto}.cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}[dir=rtl] .cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{right:auto;left:16px}.mat-mdc-option-active .mat-mdc-focus-indicator::before{content:""}'], encapsulation: 2, changeDetection: 0 }) } return t })(), dD = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ imports: [Yp, Ar, qe, nH] }) } return t })(), aH = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ imports: [qe, qe] }) } return t })(); const Jc = ts(t => function () { t(this), this.name = "EmptyError", this.message = "no elements in sequence" }); function Zp(t) { return new xe(n => { dt(t()).subscribe(n) }) } function kr(t, n) { const e = ne(t) ? t : () => t, i = o => o.error(e()); return new xe(n ? o => n.schedule(i, 0, o) : i) } function Xp() { return Pe((t, n) => { let e = null; t._refCount++; const i = Ie(n, void 0, void 0, void 0, () => { if (!t || t._refCount <= 0 || 0 < --t._refCount) return void (e = null); const o = t._connection, r = e; e = null, o && (!r || o === r) && o.unsubscribe(), n.unsubscribe() }); t.subscribe(i), i.closed || (e = t.connect()) }) } class uD extends xe { constructor(n, e) { super(), this.source = n, this.subjectFactory = e, this._subject = null, this._refCount = 0, this._connection = null, Ig(n) && (this.lift = n.lift) } _subscribe(n) { return this.getSubject().subscribe(n) } getSubject() { const n = this._subject; return (!n || n.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; const { _connection: n } = this; this._subject = this._connection = null, n?.unsubscribe() } connect() { let n = this._connection; if (!n) { n = this._connection = new Fe; const e = this.getSubject(); n.add(this.source.subscribe(Ie(e, void 0, () => { this._teardown(), e.complete() }, i => { this._teardown(), e.error(i) }, () => this._teardown()))), n.closed && (this._connection = null, n = Fe.EMPTY) } return n } refCount() { return Xp()(this) } } function ed(t) { return Pe((n, e) => { let i = !1; n.subscribe(Ie(e, o => { i = !0, e.next(o) }, () => { i || e.next(t), e.complete() })) }) } function hD(t = cH) { return Pe((n, e) => { let i = !1; n.subscribe(Ie(e, o => { i = !0, e.next(o) }, () => i ? e.complete() : e.error(t()))) }) } function cH() { return new Jc } function ho(t, n) { const e = arguments.length >= 2; return i => i.pipe(t ? at((o, r) => t(o, r, i)) : pi, St(1), e ? ed(n) : hD(() => new Jc)) } function Fr(t, n) { return ne(n) ? We(t, n, 1) : We(t, 1) } function Oi(t) { return Pe((n, e) => { let r, i = null, o = !1; i = n.subscribe(Ie(e, void 0, void 0, s => { r = dt(t(s, Oi(t)(n))), i ? (i.unsubscribe(), i = null, r.subscribe(e)) : o = !0 })), o && (i.unsubscribe(), i = null, r.subscribe(e)) }) } function Kp(t) { return t <= 0 ? () => vn : Pe((n, e) => { let i = []; n.subscribe(Ie(e, o => { i.push(o), t < i.length && i.shift() }, () => { for (const o of i) e.next(o); e.complete() }, void 0, () => { i = null })) }) } function fD(t) { return X(() => t) } function Pr(t) { return Pe((n, e) => { try { n.subscribe(e) } finally { e.add(t) } }) } const Z = "primary", ba = Symbol("RouteTitle"); class fH { constructor(n) { this.params = n || {} } has(n) { return Object.prototype.hasOwnProperty.call(this.params, n) } get(n) { if (this.has(n)) { const e = this.params[n]; return Array.isArray(e) ? e[0] : e } return null } getAll(n) { if (this.has(n)) { const e = this.params[n]; return Array.isArray(e) ? e : [e] } return [] } get keys() { return Object.keys(this.params) } } function Nr(t) { return new fH(t) } function pH(t, n, e) { const i = e.path.split("/"); if (i.length > t.length || "full" === e.pathMatch && (n.hasChildren() || i.length < t.length)) return null; const o = {}; for (let r = 0; r < i.length; r++) { const s = i[r], a = t[r]; if (s.startsWith(":")) o[s.substring(1)] = a; else if (s !== a.path) return null } return { consumed: t.slice(0, i.length), posParams: o } } function zn(t, n) { const e = t ? Object.keys(t) : void 0, i = n ? Object.keys(n) : void 0; if (!e || !i || e.length != i.length) return !1; let o; for (let r = 0; r < e.length; r++)if (o = e[r], !pD(t[o], n[o])) return !1; return !0 } function pD(t, n) { if (Array.isArray(t) && Array.isArray(n)) { if (t.length !== n.length) return !1; const e = [...t].sort(), i = [...n].sort(); return e.every((o, r) => i[r] === o) } return t === n } function mD(t) { return t.length > 0 ? t[t.length - 1] : null } function ki(t) { return function lH(t) { return !!t && (t instanceof xe || ne(t.lift) && ne(t.subscribe)) }(t) ? t : Zs(t) ? Ye(Promise.resolve(t)) : N(t) } const gH = { exact: function vD(t, n, e) { if (!fo(t.segments, n.segments) || !td(t.segments, n.segments, e) || t.numberOfChildren !== n.numberOfChildren) return !1; for (const i in n.children) if (!t.children[i] || !vD(t.children[i], n.children[i], e)) return !1; return !0 }, subset: bD }, gD = { exact: function _H(t, n) { return zn(t, n) }, subset: function vH(t, n) { return Object.keys(n).length <= Object.keys(t).length && Object.keys(n).every(e => pD(t[e], n[e])) }, ignored: () => !0 }; function _D(t, n, e) { return gH[e.paths](t.root, n.root, e.matrixParams) && gD[e.queryParams](t.queryParams, n.queryParams) && !("exact" === e.fragment && t.fragment !== n.fragment) } function bD(t, n, e) { return yD(t, n, n.segments, e) } function yD(t, n, e, i) { if (t.segments.length > e.length) { const o = t.segments.slice(0, e.length); return !(!fo(o, e) || n.hasChildren() || !td(o, e, i)) } if (t.segments.length === e.length) { if (!fo(t.segments, e) || !td(t.segments, e, i)) return !1; for (const o in n.children) if (!t.children[o] || !bD(t.children[o], n.children[o], i)) return !1; return !0 } { const o = e.slice(0, t.segments.length), r = e.slice(t.segments.length); return !!(fo(t.segments, o) && td(t.segments, o, i) && t.children[Z]) && yD(t.children[Z], n, r, i) } } function td(t, n, e) { return n.every((i, o) => gD[e](t[o].parameters, i.parameters)) } class Lr { constructor(n = new _e([], {}), e = {}, i = null) { this.root = n, this.queryParams = e, this.fragment = i } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Nr(this.queryParams)), this._queryParamMap } toString() { return wH.serialize(this) } } class _e { constructor(n, e) { this.segments = n, this.children = e, this.parent = null, Object.values(e).forEach(i => i.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return nd(this) } } class ya { constructor(n, e) { this.path = n, this.parameters = e } get parameterMap() { return this._parameterMap || (this._parameterMap = Nr(this.parameters)), this._parameterMap } toString() { return CD(this) } } function fo(t, n) { return t.length === n.length && t.every((e, i) => e.path === n[i].path) } let wa = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: function () { return new Qp }, providedIn: "root" }) } return t })(); class Qp { parse(n) { const e = new OH(n); return new Lr(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment()) } serialize(n) { const e = `/${xa(n.root, !0)}`, i = function DH(t) { const n = Object.keys(t).map(e => { const i = t[e]; return Array.isArray(i) ? i.map(o => `${id(e)}=${id(o)}`).join("&") : `${id(e)}=${id(i)}` }).filter(e => !!e); return n.length ? `?${n.join("&")}` : "" }(n.queryParams); return `${e}${i}${"string" == typeof n.fragment ? `#${function xH(t) { return encodeURI(t) }(n.fragment)}` : ""}` } } const wH = new Qp; function nd(t) { return t.segments.map(n => CD(n)).join("/") } function xa(t, n) { if (!t.hasChildren()) return nd(t); if (n) { const e = t.children[Z] ? xa(t.children[Z], !1) : "", i = []; return Object.entries(t.children).forEach(([o, r]) => { o !== Z && i.push(`${o}:${xa(r, !1)}`) }), i.length > 0 ? `${e}(${i.join("//")})` : e } { const e = function yH(t, n) { let e = []; return Object.entries(t.children).forEach(([i, o]) => { i === Z && (e = e.concat(n(o, i))) }), Object.entries(t.children).forEach(([i, o]) => { i !== Z && (e = e.concat(n(o, i))) }), e }(t, (i, o) => o === Z ? [xa(t.children[Z], !1)] : [`${o}:${xa(i, !1)}`]); return 1 === Object.keys(t.children).length && null != t.children[Z] ? `${nd(t)}/${e[0]}` : `${nd(t)}/(${e.join("//")})` } } function wD(t) { return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function id(t) { return wD(t).replace(/%3B/gi, ";") } function Jp(t) { return wD(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function od(t) { return decodeURIComponent(t) } function xD(t) { return od(t.replace(/\+/g, "%20")) } function CD(t) { return `${Jp(t.path)}${function CH(t) { return Object.keys(t).map(n => `;${Jp(n)}=${Jp(t[n])}`).join("") }(t.parameters)}` } const EH = /^[^\/()?;#]+/; function em(t) { const n = t.match(EH); return n ? n[0] : "" } const SH = /^[^\/()?;=#]+/, IH = /^[^=?&#]+/, TH = /^[^&#]+/; class OH { constructor(n) { this.url = n, this.remaining = n } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new _e([], {}) : new _e([], this.parseChildren()) } parseQueryParams() { const n = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(n) } while (this.consumeOptional("&")); return n } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const n = []; for (this.peekStartsWith("(") || n.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), n.push(this.parseSegment()); let e = {}; this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0)); let i = {}; return this.peekStartsWith("(") && (i = this.parseParens(!1)), (n.length > 0 || Object.keys(e).length > 0) && (i[Z] = new _e(n, e)), i } parseSegment() { const n = em(this.remaining); if ("" === n && this.peekStartsWith(";")) throw new b(4009, !1); return this.capture(n), new ya(od(n), this.parseMatrixParams()) } parseMatrixParams() { const n = {}; for (; this.consumeOptional(";");)this.parseParam(n); return n } parseParam(n) { const e = function MH(t) { const n = t.match(SH); return n ? n[0] : "" }(this.remaining); if (!e) return; this.capture(e); let i = ""; if (this.consumeOptional("=")) { const o = em(this.remaining); o && (i = o, this.capture(i)) } n[od(e)] = od(i) } parseQueryParam(n) { const e = function AH(t) { const n = t.match(IH); return n ? n[0] : "" }(this.remaining); if (!e) return; this.capture(e); let i = ""; if (this.consumeOptional("=")) { const s = function RH(t) { const n = t.match(TH); return n ? n[0] : "" }(this.remaining); s && (i = s, this.capture(i)) } const o = xD(e), r = xD(i); if (n.hasOwnProperty(o)) { let s = n[o]; Array.isArray(s) || (s = [s], n[o] = s), s.push(r) } else n[o] = r } parseParens(n) { const e = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const i = em(this.remaining), o = this.remaining[i.length]; if ("/" !== o && ")" !== o && ";" !== o) throw new b(4010, !1); let r; i.indexOf(":") > -1 ? (r = i.slice(0, i.indexOf(":")), this.capture(r), this.capture(":")) : n && (r = Z); const s = this.parseChildren(); e[r] = 1 === Object.keys(s).length ? s[Z] : new _e([], s), this.consumeOptional("//") } return e } peekStartsWith(n) { return this.remaining.startsWith(n) } consumeOptional(n) { return !!this.peekStartsWith(n) && (this.remaining = this.remaining.substring(n.length), !0) } capture(n) { if (!this.consumeOptional(n)) throw new b(4011, !1) } } function DD(t) { return t.segments.length > 0 ? new _e([], { [Z]: t }) : t } function ED(t) { const n = {}; for (const i of Object.keys(t.children)) { const r = ED(t.children[i]); if (i === Z && 0 === r.segments.length && r.hasChildren()) for (const [s, a] of Object.entries(r.children)) n[s] = a; else (r.segments.length > 0 || r.hasChildren()) && (n[i] = r) } return function kH(t) { if (1 === t.numberOfChildren && t.children[Z]) { const n = t.children[Z]; return new _e(t.segments.concat(n.segments), n.children) } return t }(new _e(t.segments, n)) } function po(t) { return t instanceof Lr } function SD(t) { let n; const o = DD(function e(r) { const s = {}; for (const l of r.children) { const c = e(l); s[l.outlet] = c } const a = new _e(r.url, s); return r === t && (n = a), a }(t.root)); return n ?? o } function MD(t, n, e, i) { let o = t; for (; o.parent;)o = o.parent; if (0 === n.length) return tm(o, o, o, e, i); const r = function PH(t) { if ("string" == typeof t[0] && 1 === t.length && "/" === t[0]) return new AD(!0, 0, t); let n = 0, e = !1; const i = t.reduce((o, r, s) => { if ("object" == typeof r && null != r) { if (r.outlets) { const a = {}; return Object.entries(r.outlets).forEach(([l, c]) => { a[l] = "string" == typeof c ? c.split("/") : c }), [...o, { outlets: a }] } if (r.segmentPath) return [...o, r.segmentPath] } return "string" != typeof r ? [...o, r] : 0 === s ? (r.split("/").forEach((a, l) => { 0 == l && "." === a || (0 == l && "" === a ? e = !0 : ".." === a ? n++ : "" != a && o.push(a)) }), o) : [...o, r] }, []); return new AD(e, n, i) }(n); if (r.toRoot()) return tm(o, o, new _e([], {}), e, i); const s = function NH(t, n, e) { if (t.isAbsolute) return new sd(n, !0, 0); if (!e) return new sd(n, !1, NaN); if (null === e.parent) return new sd(e, !0, 0); const i = rd(t.commands[0]) ? 0 : 1; return function LH(t, n, e) { let i = t, o = n, r = e; for (; r > o;) { if (r -= o, i = i.parent, !i) throw new b(4005, !1); o = i.segments.length } return new sd(i, !1, o - r) }(e, e.segments.length - 1 + i, t.numberOfDoubleDots) }(r, o, t), a = s.processChildren ? Da(s.segmentGroup, s.index, r.commands) : TD(s.segmentGroup, s.index, r.commands); return tm(o, s.segmentGroup, a, e, i) } function rd(t) { return "object" == typeof t && null != t && !t.outlets && !t.segmentPath } function Ca(t) { return "object" == typeof t && null != t && t.outlets } function tm(t, n, e, i, o) { let s, r = {}; i && Object.entries(i).forEach(([l, c]) => { r[l] = Array.isArray(c) ? c.map(d => `${d}`) : `${c}` }), s = t === n ? e : ID(t, n, e); const a = DD(ED(s)); return new Lr(a, r, o) } function ID(t, n, e) { const i = {}; return Object.entries(t.children).forEach(([o, r]) => { i[o] = r === n ? e : ID(r, n, e) }), new _e(t.segments, i) } class AD { constructor(n, e, i) { if (this.isAbsolute = n, this.numberOfDoubleDots = e, this.commands = i, n && i.length > 0 && rd(i[0])) throw new b(4003, !1); const o = i.find(Ca); if (o && o !== mD(i)) throw new b(4004, !1) } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class sd { constructor(n, e, i) { this.segmentGroup = n, this.processChildren = e, this.index = i } } function TD(t, n, e) { if (t || (t = new _e([], {})), 0 === t.segments.length && t.hasChildren()) return Da(t, n, e); const i = function BH(t, n, e) { let i = 0, o = n; const r = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; o < t.segments.length;) { if (i >= e.length) return r; const s = t.segments[o], a = e[i]; if (Ca(a)) break; const l = `${a}`, c = i < e.length - 1 ? e[i + 1] : null; if (o > 0 && void 0 === l) break; if (l && c && "object" == typeof c && void 0 === c.outlets) { if (!OD(l, c, s)) return r; i += 2 } else { if (!OD(l, {}, s)) return r; i++ } o++ } return { match: !0, pathIndex: o, commandIndex: i } }(t, n, e), o = e.slice(i.commandIndex); if (i.match && i.pathIndex < t.segments.length) { const r = new _e(t.segments.slice(0, i.pathIndex), {}); return r.children[Z] = new _e(t.segments.slice(i.pathIndex), t.children), Da(r, 0, o) } return i.match && 0 === o.length ? new _e(t.segments, {}) : i.match && !t.hasChildren() ? nm(t, n, e) : i.match ? Da(t, 0, o) : nm(t, n, e) } function Da(t, n, e) { if (0 === e.length) return new _e(t.segments, {}); { const i = function VH(t) { return Ca(t[0]) ? t[0].outlets : { [Z]: t } }(e), o = {}; if (Object.keys(i).some(r => r !== Z) && t.children[Z] && 1 === t.numberOfChildren && 0 === t.children[Z].segments.length) { const r = Da(t.children[Z], n, e); return new _e(t.segments, r.children) } return Object.entries(i).forEach(([r, s]) => { "string" == typeof s && (s = [s]), null !== s && (o[r] = TD(t.children[r], n, s)) }), Object.entries(t.children).forEach(([r, s]) => { void 0 === i[r] && (o[r] = s) }), new _e(t.segments, o) } } function nm(t, n, e) { const i = t.segments.slice(0, n); let o = 0; for (; o < e.length;) { const r = e[o]; if (Ca(r)) { const l = jH(r.outlets); return new _e(i, l) } if (0 === o && rd(e[0])) { i.push(new ya(t.segments[n].path, RD(e[0]))), o++; continue } const s = Ca(r) ? r.outlets[Z] : `${r}`, a = o < e.length - 1 ? e[o + 1] : null; s && a && rd(a) ? (i.push(new ya(s, RD(a))), o += 2) : (i.push(new ya(s, {})), o++) } return new _e(i, {}) } function jH(t) { const n = {}; return Object.entries(t).forEach(([e, i]) => { "string" == typeof i && (i = [i]), null !== i && (n[e] = nm(new _e([], {}), 0, i)) }), n } function RD(t) { const n = {}; return Object.entries(t).forEach(([e, i]) => n[e] = `${i}`), n } function OD(t, n, e) { return t == e.path && zn(n, e.parameters) } const Ea = "imperative"; class $n { constructor(n, e) { this.id = n, this.url = e } } class ad extends $n { constructor(n, e, i = "imperative", o = null) { super(n, e), this.type = 0, this.navigationTrigger = i, this.restoredState = o } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class Fi extends $n { constructor(n, e, i) { super(n, e), this.urlAfterRedirects = i, this.type = 1 } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class Sa extends $n { constructor(n, e, i, o) { super(n, e), this.reason = i, this.code = o, this.type = 2 } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class Vr extends $n { constructor(n, e, i, o) { super(n, e), this.reason = i, this.code = o, this.type = 16 } } class ld extends $n { constructor(n, e, i, o) { super(n, e), this.error = i, this.target = o, this.type = 3 } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class kD extends $n { constructor(n, e, i, o) { super(n, e), this.urlAfterRedirects = i, this.state = o, this.type = 4 } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class HH extends $n { constructor(n, e, i, o) { super(n, e), this.urlAfterRedirects = i, this.state = o, this.type = 7 } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class UH extends $n { constructor(n, e, i, o, r) { super(n, e), this.urlAfterRedirects = i, this.state = o, this.shouldActivate = r, this.type = 8 } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class zH extends $n { constructor(n, e, i, o) { super(n, e), this.urlAfterRedirects = i, this.state = o, this.type = 5 } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class $H extends $n { constructor(n, e, i, o) { super(n, e), this.urlAfterRedirects = i, this.state = o, this.type = 6 } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class GH { constructor(n) { this.route = n, this.type = 9 } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class qH { constructor(n) { this.route = n, this.type = 10 } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class WH { constructor(n) { this.snapshot = n, this.type = 11 } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class YH { constructor(n) { this.snapshot = n, this.type = 12 } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class ZH { constructor(n) { this.snapshot = n, this.type = 13 } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class XH { constructor(n) { this.snapshot = n, this.type = 14 } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class FD { constructor(n, e, i) { this.routerEvent = n, this.position = e, this.anchor = i, this.type = 15 } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } class im { } class om { constructor(n) { this.url = n } } class KH { constructor() { this.outlet = null, this.route = null, this.injector = null, this.children = new Ma, this.attachRef = null } } let Ma = (() => { class t { constructor() { this.contexts = new Map } onChildOutletCreated(e, i) { const o = this.getOrCreateContext(e); o.outlet = i, this.contexts.set(e, o) } onChildOutletDestroyed(e) { const i = this.getContext(e); i && (i.outlet = null, i.attachRef = null) } onOutletDeactivated() { const e = this.contexts; return this.contexts = new Map, e } onOutletReAttached(e) { this.contexts = e } getOrCreateContext(e) { let i = this.getContext(e); return i || (i = new KH, this.contexts.set(e, i)), i } getContext(e) { return this.contexts.get(e) || null } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); class PD { constructor(n) { this._root = n } get root() { return this._root.value } parent(n) { const e = this.pathFromRoot(n); return e.length > 1 ? e[e.length - 2] : null } children(n) { const e = rm(n, this._root); return e ? e.children.map(i => i.value) : [] } firstChild(n) { const e = rm(n, this._root); return e && e.children.length > 0 ? e.children[0].value : null } siblings(n) { const e = sm(n, this._root); return e.length < 2 ? [] : e[e.length - 2].children.map(o => o.value).filter(o => o !== n) } pathFromRoot(n) { return sm(n, this._root).map(e => e.value) } } function rm(t, n) { if (t === n.value) return n; for (const e of n.children) { const i = rm(t, e); if (i) return i } return null } function sm(t, n) { if (t === n.value) return [n]; for (const e of n.children) { const i = sm(t, e); if (i.length) return i.unshift(n), i } return [] } class ci { constructor(n, e) { this.value = n, this.children = e } toString() { return `TreeNode(${this.value})` } } function Br(t) { const n = {}; return t && t.children.forEach(e => n[e.value.outlet] = e), n } class ND extends PD { constructor(n, e) { super(n), this.snapshot = e, am(this, n) } toString() { return this.snapshot.toString() } } function LD(t, n) { const e = function QH(t, n) { const s = new cd([], {}, {}, "", {}, Z, n, null, {}); return new BD("", new ci(s, [])) }(0, n), i = new At([new ya("", {})]), o = new At({}), r = new At({}), s = new At({}), a = new At(""), l = new Gn(i, o, s, a, r, Z, n, e.root); return l.snapshot = e.root, new ND(new ci(l, []), e) } class Gn { constructor(n, e, i, o, r, s, a, l) { this.urlSubject = n, this.paramsSubject = e, this.queryParamsSubject = i, this.fragmentSubject = o, this.dataSubject = r, this.outlet = s, this.component = a, this._futureSnapshot = l, this.title = this.dataSubject?.pipe(X(c => c[ba])) ?? N(void 0), this.url = n, this.params = e, this.queryParams = i, this.fragment = o, this.data = r } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(X(n => Nr(n)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(X(n => Nr(n)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function VD(t, n = "emptyOnly") { const e = t.pathFromRoot; let i = 0; if ("always" !== n) for (i = e.length - 1; i >= 1;) { const o = e[i], r = e[i - 1]; if (o.routeConfig && "" === o.routeConfig.path) i--; else { if (r.component) break; i-- } } return function JH(t) { return t.reduce((n, e) => ({ params: { ...n.params, ...e.params }, data: { ...n.data, ...e.data }, resolve: { ...e.data, ...n.resolve, ...e.routeConfig?.data, ...e._resolvedData } }), { params: {}, data: {}, resolve: {} }) }(e.slice(i)) } class cd { get title() { return this.data?.[ba] } constructor(n, e, i, o, r, s, a, l, c) { this.url = n, this.params = e, this.queryParams = i, this.fragment = o, this.data = r, this.outlet = s, this.component = a, this.routeConfig = l, this._resolve = c } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = Nr(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Nr(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(i => i.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class BD extends PD { constructor(n, e) { super(e), this.url = n, am(this, e) } toString() { return jD(this._root) } } function am(t, n) { n.value._routerState = t, n.children.forEach(e => am(t, e)) } function jD(t) { const n = t.children.length > 0 ? ` { ${t.children.map(jD).join(", ")} } ` : ""; return `${t.value}${n}` } function lm(t) { if (t.snapshot) { const n = t.snapshot, e = t._futureSnapshot; t.snapshot = e, zn(n.queryParams, e.queryParams) || t.queryParamsSubject.next(e.queryParams), n.fragment !== e.fragment && t.fragmentSubject.next(e.fragment), zn(n.params, e.params) || t.paramsSubject.next(e.params), function mH(t, n) { if (t.length !== n.length) return !1; for (let e = 0; e < t.length; ++e)if (!zn(t[e], n[e])) return !1; return !0 }(n.url, e.url) || t.urlSubject.next(e.url), zn(n.data, e.data) || t.dataSubject.next(e.data) } else t.snapshot = t._futureSnapshot, t.dataSubject.next(t._futureSnapshot.data) } function cm(t, n) { const e = zn(t.params, n.params) && function bH(t, n) { return fo(t, n) && t.every((e, i) => zn(e.parameters, n[i].parameters)) }(t.url, n.url); return e && !(!t.parent != !n.parent) && (!t.parent || cm(t.parent, n.parent)) } let dm = (() => { class t { constructor() { this.activated = null, this._activatedRoute = null, this.name = Z, this.activateEvents = new ue, this.deactivateEvents = new ue, this.attachEvents = new ue, this.detachEvents = new ue, this.parentContexts = T(Ma), this.location = T(cn), this.changeDetector = T(Un), this.environmentInjector = T(Wt), this.inputBinder = T(dd, { optional: !0 }), this.supportsBindingToComponentInputs = !0 } get activatedComponentRef() { return this.activated } ngOnChanges(e) { if (e.name) { const { firstChange: i, previousValue: o } = e.name; if (i) return; this.isTrackedInParentContexts(o) && (this.deactivate(), this.parentContexts.onChildOutletDestroyed(o)), this.initializeOutletWithName() } } ngOnDestroy() { this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name), this.inputBinder?.unsubscribeFromRouteData(this) } isTrackedInParentContexts(e) { return this.parentContexts.getContext(e)?.outlet === this } ngOnInit() { this.initializeOutletWithName() } initializeOutletWithName() { if (this.parentContexts.onChildOutletCreated(this.name, this), this.activated) return; const e = this.parentContexts.getContext(this.name); e?.route && (e.attachRef ? this.attach(e.attachRef, e.route) : this.activateWith(e.route, e.injector)) } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new b(4012, !1); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new b(4012, !1); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new b(4012, !1); this.location.detach(); const e = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(e.instance), e } attach(e, i) { this.activated = e, this._activatedRoute = i, this.location.insert(e.hostView), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.attachEvents.emit(e.instance) } deactivate() { if (this.activated) { const e = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(e) } } activateWith(e, i) { if (this.isActivated) throw new b(4013, !1); this._activatedRoute = e; const o = this.location, s = e.snapshot.component, a = this.parentContexts.getOrCreateContext(this.name).children, l = new eU(e, a, o.injector); this.activated = o.createComponent(s, { index: o.length, injector: l, environmentInjector: i ?? this.environmentInjector }), this.changeDetector.markForCheck(), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.activateEvents.emit(this.activated.instance) } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275dir = P({ type: t, selectors: [["router-outlet"]], inputs: { name: "name" }, outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"], standalone: !0, features: [Ft] }) } return t })(); class eU { constructor(n, e, i) { this.route = n, this.childContexts = e, this.parent = i } get(n, e) { return n === Gn ? this.route : n === Ma ? this.childContexts : this.parent.get(n, e) } } const dd = new E(""); let HD = (() => { class t { constructor() { this.outletDataSubscriptions = new Map } bindActivatedRouteToOutletComponent(e) { this.unsubscribeFromRouteData(e), this.subscribeToRouteData(e) } unsubscribeFromRouteData(e) { this.outletDataSubscriptions.get(e)?.unsubscribe(), this.outletDataSubscriptions.delete(e) } subscribeToRouteData(e) { const { activatedRoute: i } = e, o = Xc([i.queryParams, i.params, i.data]).pipe(Tt(([r, s, a], l) => (a = { ...r, ...s, ...a }, 0 === l ? N(a) : Promise.resolve(a)))).subscribe(r => { if (!e.isActivated || !e.activatedComponentRef || e.activatedRoute !== i || null === i.component) return void this.unsubscribeFromRouteData(e); const s = function d2(t) { const n = oe(t); if (!n) return null; const e = new Us(n); return { get selector() { return e.selector }, get type() { return e.componentType }, get inputs() { return e.inputs }, get outputs() { return e.outputs }, get ngContentSelectors() { return e.ngContentSelectors }, get isStandalone() { return n.standalone }, get isSignal() { return n.signals } } }(i.component); if (s) for (const { templateName: a } of s.inputs) e.activatedComponentRef.setInput(a, r[a]); else this.unsubscribeFromRouteData(e) }); this.outletDataSubscriptions.set(e, o) } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })(); function Ia(t, n, e) { if (e && t.shouldReuseRoute(n.value, e.value.snapshot)) { const i = e.value; i._futureSnapshot = n.value; const o = function nU(t, n, e) { return n.children.map(i => { for (const o of e.children) if (t.shouldReuseRoute(i.value, o.value.snapshot)) return Ia(t, i, o); return Ia(t, i) }) }(t, n, e); return new ci(i, o) } { if (t.shouldAttach(n.value)) { const r = t.retrieve(n.value); if (null !== r) { const s = r.route; return s.value._futureSnapshot = n.value, s.children = n.children.map(a => Ia(t, a)), s } } const i = function iU(t) { return new Gn(new At(t.url), new At(t.params), new At(t.queryParams), new At(t.fragment), new At(t.data), t.outlet, t.component, t) }(n.value), o = n.children.map(r => Ia(t, r)); return new ci(i, o) } } const um = "ngNavigationCancelingError"; function UD(t, n) { const { redirectTo: e, navigationBehaviorOptions: i } = po(n) ? { redirectTo: n, navigationBehaviorOptions: void 0 } : n, o = zD(!1, 0, n); return o.url = e, o.navigationBehaviorOptions = i, o } function zD(t, n, e) { const i = new Error("NavigationCancelingError: " + (t || "")); return i[um] = !0, i.cancellationCode = n, e && (i.url = e), i } function $D(t) { return t && t[um] } let GD = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275cmp = tt({ type: t, selectors: [["ng-component"]], standalone: !0, features: [lw], decls: 1, vars: 0, template: function (i, o) { 1 & i && U(0, "router-outlet") }, dependencies: [dm], encapsulation: 2 }) } return t })(); function hm(t) { const n = t.children && t.children.map(hm), e = n ? { ...t, children: n } : { ...t }; return !e.component && !e.loadComponent && (n || e.loadChildren) && e.outlet && e.outlet !== Z && (e.component = GD), e } function Sn(t) { return t.outlet || Z } function Aa(t) { if (!t) return null; if (t.routeConfig?._injector) return t.routeConfig._injector; for (let n = t.parent; n; n = n.parent) { const e = n.routeConfig; if (e?._loadedInjector) return e._loadedInjector; if (e?._injector) return e._injector } return null } class uU { constructor(n, e, i, o, r) { this.routeReuseStrategy = n, this.futureState = e, this.currState = i, this.forwardEvent = o, this.inputBindingEnabled = r } activate(n) { const e = this.futureState._root, i = this.currState ? this.currState._root : null; this.deactivateChildRoutes(e, i, n), lm(this.futureState.root), this.activateChildRoutes(e, i, n) } deactivateChildRoutes(n, e, i) { const o = Br(e); n.children.forEach(r => { const s = r.value.outlet; this.deactivateRoutes(r, o[s], i), delete o[s] }), Object.values(o).forEach(r => { this.deactivateRouteAndItsChildren(r, i) }) } deactivateRoutes(n, e, i) { const o = n.value, r = e ? e.value : null; if (o === r) if (o.component) { const s = i.getContext(o.outlet); s && this.deactivateChildRoutes(n, e, s.children) } else this.deactivateChildRoutes(n, e, i); else r && this.deactivateRouteAndItsChildren(e, i) } deactivateRouteAndItsChildren(n, e) { n.value.component && this.routeReuseStrategy.shouldDetach(n.value.snapshot) ? this.detachAndStoreRouteSubtree(n, e) : this.deactivateRouteAndOutlet(n, e) } detachAndStoreRouteSubtree(n, e) { const i = e.getContext(n.value.outlet), o = i && n.value.component ? i.children : e, r = Br(n); for (const s of Object.keys(r)) this.deactivateRouteAndItsChildren(r[s], o); if (i && i.outlet) { const s = i.outlet.detach(), a = i.children.onOutletDeactivated(); this.routeReuseStrategy.store(n.value.snapshot, { componentRef: s, route: n, contexts: a }) } } deactivateRouteAndOutlet(n, e) { const i = e.getContext(n.value.outlet), o = i && n.value.component ? i.children : e, r = Br(n); for (const s of Object.keys(r)) this.deactivateRouteAndItsChildren(r[s], o); i && (i.outlet && (i.outlet.deactivate(), i.children.onOutletDeactivated()), i.attachRef = null, i.route = null) } activateChildRoutes(n, e, i) { const o = Br(e); n.children.forEach(r => { this.activateRoutes(r, o[r.value.outlet], i), this.forwardEvent(new XH(r.value.snapshot)) }), n.children.length && this.forwardEvent(new YH(n.value.snapshot)) } activateRoutes(n, e, i) { const o = n.value, r = e ? e.value : null; if (lm(o), o === r) if (o.component) { const s = i.getOrCreateContext(o.outlet); this.activateChildRoutes(n, e, s.children) } else this.activateChildRoutes(n, e, i); else if (o.component) { const s = i.getOrCreateContext(o.outlet); if (this.routeReuseStrategy.shouldAttach(o.snapshot)) { const a = this.routeReuseStrategy.retrieve(o.snapshot); this.routeReuseStrategy.store(o.snapshot, null), s.children.onOutletReAttached(a.contexts), s.attachRef = a.componentRef, s.route = a.route.value, s.outlet && s.outlet.attach(a.componentRef, a.route.value), lm(a.route.value), this.activateChildRoutes(n, null, s.children) } else { const a = Aa(o.snapshot); s.attachRef = null, s.route = o, s.injector = a, s.outlet && s.outlet.activateWith(o, s.injector), this.activateChildRoutes(n, null, s.children) } } else this.activateChildRoutes(n, null, i) } } class qD { constructor(n) { this.path = n, this.route = this.path[this.path.length - 1] } } class ud { constructor(n, e) { this.component = n, this.route = e } } function hU(t, n, e) { const i = t._root; return Ta(i, n ? n._root : null, e, [i.value]) } function jr(t, n) { const e = Symbol(), i = n.get(t, e); return i === e ? "function" != typeof t || function mA(t) { return null !== al(t) }(t) ? n.get(t) : t : i } function Ta(t, n, e, i, o = { canDeactivateChecks: [], canActivateChecks: [] }) { const r = Br(n); return t.children.forEach(s => { (function pU(t, n, e, i, o = { canDeactivateChecks: [], canActivateChecks: [] }) { const r = t.value, s = n ? n.value : null, a = e ? e.getContext(t.value.outlet) : null; if (s && r.routeConfig === s.routeConfig) { const l = function mU(t, n, e) { if ("function" == typeof e) return e(t, n); switch (e) { case "pathParamsChange": return !fo(t.url, n.url); case "pathParamsOrQueryParamsChange": return !fo(t.url, n.url) || !zn(t.queryParams, n.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !cm(t, n) || !zn(t.queryParams, n.queryParams); default: return !cm(t, n) } }(s, r, r.routeConfig.runGuardsAndResolvers); l ? o.canActivateChecks.push(new qD(i)) : (r.data = s.data, r._resolvedData = s._resolvedData), Ta(t, n, r.component ? a ? a.children : null : e, i, o), l && a && a.outlet && a.outlet.isActivated && o.canDeactivateChecks.push(new ud(a.outlet.component, s)) } else s && Ra(n, a, o), o.canActivateChecks.push(new qD(i)), Ta(t, null, r.component ? a ? a.children : null : e, i, o) })(s, r[s.value.outlet], e, i.concat([s.value]), o), delete r[s.value.outlet] }), Object.entries(r).forEach(([s, a]) => Ra(a, e.getContext(s), o)), o } function Ra(t, n, e) { const i = Br(t), o = t.value; Object.entries(i).forEach(([r, s]) => { Ra(s, o.component ? n ? n.children.getContext(r) : null : n, e) }), e.canDeactivateChecks.push(new ud(o.component && n && n.outlet && n.outlet.isActivated ? n.outlet.component : null, o)) } function Oa(t) { return "function" == typeof t } function WD(t) { return t instanceof Jc || "EmptyError" === t?.name } const hd = Symbol("INITIAL_VALUE"); function Hr() { return Tt(t => Xc(t.map(n => n.pipe(St(1), $p(hd)))).pipe(X(n => { for (const e of n) if (!0 !== e) { if (e === hd) return hd; if (!1 === e || e instanceof Lr) return e } return !0 }), at(n => n !== hd), St(1))) } function YD(t) { return function yI(...t) { return Eg(t) }(Ue(n => { if (po(n)) throw UD(0, n) }), X(n => !0 === n)) } class fd { constructor(n) { this.segmentGroup = n || null } } class ZD { constructor(n) { this.urlTree = n } } function Ur(t) { return kr(new fd(t)) } function XD(t) { return kr(new ZD(t)) } class PU { constructor(n, e) { this.urlSerializer = n, this.urlTree = e } noMatchError(n) { return new b(4002, !1) } lineralizeSegments(n, e) { let i = [], o = e.root; for (; ;) { if (i = i.concat(o.segments), 0 === o.numberOfChildren) return N(i); if (o.numberOfChildren > 1 || !o.children[Z]) return kr(new b(4e3, !1)); o = o.children[Z] } } applyRedirectCommands(n, e, i) { return this.applyRedirectCreateUrlTree(e, this.urlSerializer.parse(e), n, i) } applyRedirectCreateUrlTree(n, e, i, o) { const r = this.createSegmentGroup(n, e.root, i, o); return new Lr(r, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment) } createQueryParams(n, e) { const i = {}; return Object.entries(n).forEach(([o, r]) => { if ("string" == typeof r && r.startsWith(":")) { const a = r.substring(1); i[o] = e[a] } else i[o] = r }), i } createSegmentGroup(n, e, i, o) { const r = this.createSegments(n, e.segments, i, o); let s = {}; return Object.entries(e.children).forEach(([a, l]) => { s[a] = this.createSegmentGroup(n, l, i, o) }), new _e(r, s) } createSegments(n, e, i, o) { return e.map(r => r.path.startsWith(":") ? this.findPosParam(n, r, o) : this.findOrReturn(r, i)) } findPosParam(n, e, i) { const o = i[e.path.substring(1)]; if (!o) throw new b(4001, !1); return o } findOrReturn(n, e) { let i = 0; for (const o of e) { if (o.path === n.path) return e.splice(i), o; i++ } return n } } const fm = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function NU(t, n, e, i, o) { const r = pm(t, n, e); return r.matched ? (i = function rU(t, n) { return t.providers && !t._injector && (t._injector = Ff(t.providers, n, `Route: ${t.path}`)), t._injector ?? n }(n, i), function OU(t, n, e, i) { const o = n.canMatch; return o && 0 !== o.length ? N(o.map(s => { const a = jr(s, t); return ki(function wU(t) { return t && Oa(t.canMatch) }(a) ? a.canMatch(n, e) : t.runInContext(() => a(n, e))) })).pipe(Hr(), YD()) : N(!0) }(i, n, e).pipe(X(s => !0 === s ? r : { ...fm }))) : N(r) } function pm(t, n, e) { if ("" === n.path) return "full" === n.pathMatch && (t.hasChildren() || e.length > 0) ? { ...fm } : { matched: !0, consumedSegments: [], remainingSegments: e, parameters: {}, positionalParamSegments: {} }; const o = (n.matcher || pH)(e, t, n); if (!o) return { ...fm }; const r = {}; Object.entries(o.posParams ?? {}).forEach(([a, l]) => { r[a] = l.path }); const s = o.consumed.length > 0 ? { ...r, ...o.consumed[o.consumed.length - 1].parameters } : r; return { matched: !0, consumedSegments: o.consumed, remainingSegments: e.slice(o.consumed.length), parameters: s, positionalParamSegments: o.posParams ?? {} } } function KD(t, n, e, i) { return e.length > 0 && function BU(t, n, e) { return e.some(i => pd(t, n, i) && Sn(i) !== Z) }(t, e, i) ? { segmentGroup: new _e(n, VU(i, new _e(e, t.children))), slicedSegments: [] } : 0 === e.length && function jU(t, n, e) { return e.some(i => pd(t, n, i)) }(t, e, i) ? { segmentGroup: new _e(t.segments, LU(t, 0, e, i, t.children)), slicedSegments: e } : { segmentGroup: new _e(t.segments, t.children), slicedSegments: e } } function LU(t, n, e, i, o) { const r = {}; for (const s of i) if (pd(t, e, s) && !o[Sn(s)]) { const a = new _e([], {}); r[Sn(s)] = a } return { ...o, ...r } } function VU(t, n) { const e = {}; e[Z] = n; for (const i of t) if ("" === i.path && Sn(i) !== Z) { const o = new _e([], {}); e[Sn(i)] = o } return e } function pd(t, n, e) { return (!(t.hasChildren() || n.length > 0) || "full" !== e.pathMatch) && "" === e.path } class $U { constructor(n, e, i, o, r, s, a) { this.injector = n, this.configLoader = e, this.rootComponentType = i, this.config = o, this.urlTree = r, this.paramsInheritanceStrategy = s, this.urlSerializer = a, this.allowRedirects = !0, this.applyRedirects = new PU(this.urlSerializer, this.urlTree) } noMatchError(n) { return new b(4002, !1) } recognize() { const n = KD(this.urlTree.root, [], [], this.config).segmentGroup; return this.processSegmentGroup(this.injector, this.config, n, Z).pipe(Oi(e => { if (e instanceof ZD) return this.allowRedirects = !1, this.urlTree = e.urlTree, this.match(e.urlTree); throw e instanceof fd ? this.noMatchError(e) : e }), X(e => { const i = new cd([], Object.freeze({}), Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, {}, Z, this.rootComponentType, null, {}), o = new ci(i, e), r = new BD("", o), s = function FH(t, n, e = null, i = null) { return MD(SD(t), n, e, i) }(i, [], this.urlTree.queryParams, this.urlTree.fragment); return s.queryParams = this.urlTree.queryParams, r.url = this.urlSerializer.serialize(s), this.inheritParamsAndData(r._root), { state: r, tree: s } })) } match(n) { return this.processSegmentGroup(this.injector, this.config, n.root, Z).pipe(Oi(i => { throw i instanceof fd ? this.noMatchError(i) : i })) } inheritParamsAndData(n) { const e = n.value, i = VD(e, this.paramsInheritanceStrategy); e.params = Object.freeze(i.params), e.data = Object.freeze(i.data), n.children.forEach(o => this.inheritParamsAndData(o)) } processSegmentGroup(n, e, i, o) { return 0 === i.segments.length && i.hasChildren() ? this.processChildren(n, e, i) : this.processSegment(n, e, i, i.segments, o, !0) } processChildren(n, e, i) { const o = []; for (const r of Object.keys(i.children)) "primary" === r ? o.unshift(r) : o.push(r); return Ye(o).pipe(Fr(r => { const s = i.children[r], a = function cU(t, n) { const e = t.filter(i => Sn(i) === n); return e.push(...t.filter(i => Sn(i) !== n)), e }(e, r); return this.processSegmentGroup(n, a, s, r) }), function uH(t, n) { return Pe(function dH(t, n, e, i, o) { return (r, s) => { let a = e, l = n, c = 0; r.subscribe(Ie(s, d => { const u = c++; l = a ? t(l, d, u) : (a = !0, d), i && s.next(l) }, o && (() => { a && s.next(l), s.complete() }))) } }(t, n, arguments.length >= 2, !0)) }((r, s) => (r.push(...s), r)), ed(null), function hH(t, n) { const e = arguments.length >= 2; return i => i.pipe(t ? at((o, r) => t(o, r, i)) : pi, Kp(1), e ? ed(n) : hD(() => new Jc)) }(), We(r => { if (null === r) return Ur(i); const s = QD(r); return function GU(t) { t.sort((n, e) => n.value.outlet === Z ? -1 : e.value.outlet === Z ? 1 : n.value.outlet.localeCompare(e.value.outlet)) }(s), N(s) })) } processSegment(n, e, i, o, r, s) { return Ye(e).pipe(Fr(a => this.processSegmentAgainstRoute(a._injector ?? n, e, a, i, o, r, s).pipe(Oi(l => { if (l instanceof fd) return N(null); throw l }))), ho(a => !!a), Oi(a => { if (WD(a)) return function UU(t, n, e) { return 0 === n.length && !t.children[e] }(i, o, r) ? N([]) : Ur(i); throw a })) } processSegmentAgainstRoute(n, e, i, o, r, s, a) { return function HU(t, n, e, i) { return !!(Sn(t) === i || i !== Z && pd(n, e, t)) && ("**" === t.path || pm(n, t, e).matched) }(i, o, r, s) ? void 0 === i.redirectTo ? this.matchSegmentAgainstRoute(n, o, i, r, s, a) : a && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(n, o, e, i, r, s) : Ur(o) : Ur(o) } expandSegmentAgainstRouteUsingRedirect(n, e, i, o, r, s) { return "**" === o.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(n, i, o, s) : this.expandRegularSegmentAgainstRouteUsingRedirect(n, e, i, o, r, s) } expandWildCardWithParamsAgainstRouteUsingRedirect(n, e, i, o) { const r = this.applyRedirects.applyRedirectCommands([], i.redirectTo, {}); return i.redirectTo.startsWith("/") ? XD(r) : this.applyRedirects.lineralizeSegments(i, r).pipe(We(s => { const a = new _e(s, {}); return this.processSegment(n, e, a, s, o, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(n, e, i, o, r, s) { const { matched: a, consumedSegments: l, remainingSegments: c, positionalParamSegments: d } = pm(e, o, r); if (!a) return Ur(e); const u = this.applyRedirects.applyRedirectCommands(l, o.redirectTo, d); return o.redirectTo.startsWith("/") ? XD(u) : this.applyRedirects.lineralizeSegments(o, u).pipe(We(h => this.processSegment(n, i, e, h.concat(c), s, !1))) } matchSegmentAgainstRoute(n, e, i, o, r, s) { let a; if ("**" === i.path) { const l = o.length > 0 ? mD(o).parameters : {}; a = N({ snapshot: new cd(o, l, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, JD(i), Sn(i), i.component ?? i._loadedComponent ?? null, i, eE(i)), consumedSegments: [], remainingSegments: [] }), e.children = {} } else a = NU(e, i, o, n).pipe(X(({ matched: l, consumedSegments: c, remainingSegments: d, parameters: u }) => l ? { snapshot: new cd(c, u, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, JD(i), Sn(i), i.component ?? i._loadedComponent ?? null, i, eE(i)), consumedSegments: c, remainingSegments: d } : null)); return a.pipe(Tt(l => null === l ? Ur(e) : this.getChildConfig(n = i._injector ?? n, i, o).pipe(Tt(({ routes: c }) => { const d = i._loadedInjector ?? n, { snapshot: u, consumedSegments: h, remainingSegments: f } = l, { segmentGroup: p, slicedSegments: m } = KD(e, h, f, c); if (0 === m.length && p.hasChildren()) return this.processChildren(d, c, p).pipe(X(C => null === C ? null : [new ci(u, C)])); if (0 === c.length && 0 === m.length) return N([new ci(u, [])]); const _ = Sn(i) === r; return this.processSegment(d, c, p, m, _ ? Z : r, !0).pipe(X(C => [new ci(u, C)])) })))) } getChildConfig(n, e, i) { return e.children ? N({ routes: e.children, injector: n }) : e.loadChildren ? void 0 !== e._loadedRoutes ? N({ routes: e._loadedRoutes, injector: e._loadedInjector }) : function RU(t, n, e, i) { const o = n.canLoad; return void 0 === o || 0 === o.length ? N(!0) : N(o.map(s => { const a = jr(s, t); return ki(function _U(t) { return t && Oa(t.canLoad) }(a) ? a.canLoad(n, e) : t.runInContext(() => a(n, e))) })).pipe(Hr(), YD()) }(n, e, i).pipe(We(o => o ? this.configLoader.loadChildren(n, e).pipe(Ue(r => { e._loadedRoutes = r.routes, e._loadedInjector = r.injector })) : function FU(t) { return kr(zD(!1, 3)) }())) : N({ routes: [], injector: n }) } } function qU(t) { const n = t.value.routeConfig; return n && "" === n.path } function QD(t) { const n = [], e = new Set; for (const i of t) { if (!qU(i)) { n.push(i); continue } const o = n.find(r => i.value.routeConfig === r.value.routeConfig); void 0 !== o ? (o.children.push(...i.children), e.add(o)) : n.push(i) } for (const i of e) { const o = QD(i.children); n.push(new ci(i.value, o)) } return n.filter(i => !e.has(i)) } function JD(t) { return t.data || {} } function eE(t) { return t.resolve || {} } function tE(t) { return "string" == typeof t.title || null === t.title } function mm(t) { return Tt(n => { const e = t(n); return e ? Ye(e).pipe(X(() => n)) : N(n) }) } const zr = new E("ROUTES"); let gm = (() => { class t { constructor() { this.componentLoaders = new WeakMap, this.childrenLoaders = new WeakMap, this.compiler = T(Qw) } loadComponent(e) { if (this.componentLoaders.get(e)) return this.componentLoaders.get(e); if (e._loadedComponent) return N(e._loadedComponent); this.onLoadStartListener && this.onLoadStartListener(e); const i = ki(e.loadComponent()).pipe(X(nE), Ue(r => { this.onLoadEndListener && this.onLoadEndListener(e), e._loadedComponent = r }), Pr(() => { this.componentLoaders.delete(e) })), o = new uD(i, () => new ie).pipe(Xp()); return this.componentLoaders.set(e, o), o } loadChildren(e, i) { if (this.childrenLoaders.get(i)) return this.childrenLoaders.get(i); if (i._loadedRoutes) return N({ routes: i._loadedRoutes, injector: i._loadedInjector }); this.onLoadStartListener && this.onLoadStartListener(i); const r = function JU(t, n, e, i) { return ki(t.loadChildren()).pipe(X(nE), We(o => o instanceof sw || Array.isArray(o) ? N(o) : Ye(n.compileModuleAsync(o))), X(o => { i && i(t); let r, s, a = !1; return Array.isArray(o) ? (s = o, !0) : (r = o.create(e).injector, s = r.get(zr, [], { optional: !0, self: !0 }).flat()), { routes: s.map(hm), injector: r } })) }(i, this.compiler, e, this.onLoadEndListener).pipe(Pr(() => { this.childrenLoaders.delete(i) })), s = new uD(r, () => new ie).pipe(Xp()); return this.childrenLoaders.set(i, s), s } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); function nE(t) { return function ez(t) { return t && "object" == typeof t && "default" in t }(t) ? t.default : t } let md = (() => { class t { get hasRequestedNavigation() { return 0 !== this.navigationId } constructor() { this.currentNavigation = null, this.currentTransition = null, this.lastSuccessfulNavigation = null, this.events = new ie, this.transitionAbortSubject = new ie, this.configLoader = T(gm), this.environmentInjector = T(Wt), this.urlSerializer = T(wa), this.rootContexts = T(Ma), this.inputBindingEnabled = null !== T(dd, { optional: !0 }), this.navigationId = 0, this.afterPreactivation = () => N(void 0), this.rootComponentType = null, this.configLoader.onLoadEndListener = o => this.events.next(new qH(o)), this.configLoader.onLoadStartListener = o => this.events.next(new GH(o)) } complete() { this.transitions?.complete() } handleNavigationRequest(e) { const i = ++this.navigationId; this.transitions?.next({ ...this.transitions.value, ...e, id: i }) } setupNavigations(e, i, o) { return this.transitions = new At({ id: 0, currentUrlTree: i, currentRawUrl: i, currentBrowserUrl: i, extractedUrl: e.urlHandlingStrategy.extract(i), urlAfterRedirects: e.urlHandlingStrategy.extract(i), rawUrl: i, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: Ea, restoredState: null, currentSnapshot: o.snapshot, targetSnapshot: null, currentRouterState: o, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.transitions.pipe(at(r => 0 !== r.id), X(r => ({ ...r, extractedUrl: e.urlHandlingStrategy.extract(r.rawUrl) })), Tt(r => { this.currentTransition = r; let s = !1, a = !1; return N(r).pipe(Ue(l => { this.currentNavigation = { id: l.id, initialUrl: l.rawUrl, extractedUrl: l.extractedUrl, trigger: l.source, extras: l.extras, previousNavigation: this.lastSuccessfulNavigation ? { ...this.lastSuccessfulNavigation, previousNavigation: null } : null } }), Tt(l => { const c = l.currentBrowserUrl.toString(), d = !e.navigated || l.extractedUrl.toString() !== c || c !== l.currentUrlTree.toString(); if (!d && "reload" !== (l.extras.onSameUrlNavigation ?? e.onSameUrlNavigation)) { const h = ""; return this.events.next(new Vr(l.id, this.urlSerializer.serialize(l.rawUrl), h, 0)), l.resolve(null), vn } if (e.urlHandlingStrategy.shouldProcessUrl(l.rawUrl)) return N(l).pipe(Tt(h => { const f = this.transitions?.getValue(); return this.events.next(new ad(h.id, this.urlSerializer.serialize(h.extractedUrl), h.source, h.restoredState)), f !== this.transitions?.getValue() ? vn : Promise.resolve(h) }), function WU(t, n, e, i, o, r) { return We(s => function zU(t, n, e, i, o, r, s = "emptyOnly") { return new $U(t, n, e, i, o, s, r).recognize() }(t, n, e, i, s.extractedUrl, o, r).pipe(X(({ state: a, tree: l }) => ({ ...s, targetSnapshot: a, urlAfterRedirects: l })))) }(this.environmentInjector, this.configLoader, this.rootComponentType, e.config, this.urlSerializer, e.paramsInheritanceStrategy), Ue(h => { r.targetSnapshot = h.targetSnapshot, r.urlAfterRedirects = h.urlAfterRedirects, this.currentNavigation = { ...this.currentNavigation, finalUrl: h.urlAfterRedirects }; const f = new kD(h.id, this.urlSerializer.serialize(h.extractedUrl), this.urlSerializer.serialize(h.urlAfterRedirects), h.targetSnapshot); this.events.next(f) })); if (d && e.urlHandlingStrategy.shouldProcessUrl(l.currentRawUrl)) { const { id: h, extractedUrl: f, source: p, restoredState: m, extras: _ } = l, C = new ad(h, this.urlSerializer.serialize(f), p, m); this.events.next(C); const v = LD(0, this.rootComponentType).snapshot; return this.currentTransition = r = { ...l, targetSnapshot: v, urlAfterRedirects: f, extras: { ..._, skipLocationChange: !1, replaceUrl: !1 } }, N(r) } { const h = ""; return this.events.next(new Vr(l.id, this.urlSerializer.serialize(l.extractedUrl), h, 1)), l.resolve(null), vn } }), Ue(l => { const c = new HH(l.id, this.urlSerializer.serialize(l.extractedUrl), this.urlSerializer.serialize(l.urlAfterRedirects), l.targetSnapshot); this.events.next(c) }), X(l => (this.currentTransition = r = { ...l, guards: hU(l.targetSnapshot, l.currentSnapshot, this.rootContexts) }, r)), function CU(t, n) { return We(e => { const { targetSnapshot: i, currentSnapshot: o, guards: { canActivateChecks: r, canDeactivateChecks: s } } = e; return 0 === s.length && 0 === r.length ? N({ ...e, guardsResult: !0 }) : function DU(t, n, e, i) { return Ye(t).pipe(We(o => function TU(t, n, e, i, o) { const r = n && n.routeConfig ? n.routeConfig.canDeactivate : null; return r && 0 !== r.length ? N(r.map(a => { const l = Aa(n) ?? o, c = jr(a, l); return ki(function yU(t) { return t && Oa(t.canDeactivate) }(c) ? c.canDeactivate(t, n, e, i) : l.runInContext(() => c(t, n, e, i))).pipe(ho()) })).pipe(Hr()) : N(!0) }(o.component, o.route, e, n, i)), ho(o => !0 !== o, !0)) }(s, i, o, t).pipe(We(a => a && function gU(t) { return "boolean" == typeof t }(a) ? function EU(t, n, e, i) { return Ye(n).pipe(Fr(o => ga(function MU(t, n) { return null !== t && n && n(new WH(t)), N(!0) }(o.route.parent, i), function SU(t, n) { return null !== t && n && n(new ZH(t)), N(!0) }(o.route, i), function AU(t, n, e) { const i = n[n.length - 1], r = n.slice(0, n.length - 1).reverse().map(s => function fU(t) { const n = t.routeConfig ? t.routeConfig.canActivateChild : null; return n && 0 !== n.length ? { node: t, guards: n } : null }(s)).filter(s => null !== s).map(s => Zp(() => N(s.guards.map(l => { const c = Aa(s.node) ?? e, d = jr(l, c); return ki(function bU(t) { return t && Oa(t.canActivateChild) }(d) ? d.canActivateChild(i, t) : c.runInContext(() => d(i, t))).pipe(ho()) })).pipe(Hr()))); return N(r).pipe(Hr()) }(t, o.path, e), function IU(t, n, e) { const i = n.routeConfig ? n.routeConfig.canActivate : null; if (!i || 0 === i.length) return N(!0); const o = i.map(r => Zp(() => { const s = Aa(n) ?? e, a = jr(r, s); return ki(function vU(t) { return t && Oa(t.canActivate) }(a) ? a.canActivate(n, t) : s.runInContext(() => a(n, t))).pipe(ho()) })); return N(o).pipe(Hr()) }(t, o.route, e))), ho(o => !0 !== o, !0)) }(i, r, t, n) : N(a)), X(a => ({ ...e, guardsResult: a }))) }) }(this.environmentInjector, l => this.events.next(l)), Ue(l => { if (r.guardsResult = l.guardsResult, po(l.guardsResult)) throw UD(0, l.guardsResult); const c = new UH(l.id, this.urlSerializer.serialize(l.extractedUrl), this.urlSerializer.serialize(l.urlAfterRedirects), l.targetSnapshot, !!l.guardsResult); this.events.next(c) }), at(l => !!l.guardsResult || (this.cancelNavigationTransition(l, "", 3), !1)), mm(l => { if (l.guards.canActivateChecks.length) return N(l).pipe(Ue(c => { const d = new zH(c.id, this.urlSerializer.serialize(c.extractedUrl), this.urlSerializer.serialize(c.urlAfterRedirects), c.targetSnapshot); this.events.next(d) }), Tt(c => { let d = !1; return N(c).pipe(function YU(t, n) { return We(e => { const { targetSnapshot: i, guards: { canActivateChecks: o } } = e; if (!o.length) return N(e); let r = 0; return Ye(o).pipe(Fr(s => function ZU(t, n, e, i) { const o = t.routeConfig, r = t._resolve; return void 0 !== o?.title && !tE(o) && (r[ba] = o.title), function XU(t, n, e, i) { const o = function KU(t) { return [...Object.keys(t), ...Object.getOwnPropertySymbols(t)] }(t); if (0 === o.length) return N({}); const r = {}; return Ye(o).pipe(We(s => function QU(t, n, e, i) { const o = Aa(n) ?? i, r = jr(t, o); return ki(r.resolve ? r.resolve(n, e) : o.runInContext(() => r(n, e))) }(t[s], n, e, i).pipe(ho(), Ue(a => { r[s] = a }))), Kp(1), fD(r), Oi(s => WD(s) ? vn : kr(s))) }(r, t, n, i).pipe(X(s => (t._resolvedData = s, t.data = VD(t, e).resolve, o && tE(o) && (t.data[ba] = o.title), null))) }(s.route, i, t, n)), Ue(() => r++), Kp(1), We(s => r === o.length ? N(e) : vn)) }) }(e.paramsInheritanceStrategy, this.environmentInjector), Ue({ next: () => d = !0, complete: () => { d || this.cancelNavigationTransition(c, "", 2) } })) }), Ue(c => { const d = new $H(c.id, this.urlSerializer.serialize(c.extractedUrl), this.urlSerializer.serialize(c.urlAfterRedirects), c.targetSnapshot); this.events.next(d) })) }), mm(l => { const c = d => { const u = []; d.routeConfig?.loadComponent && !d.routeConfig._loadedComponent && u.push(this.configLoader.loadComponent(d.routeConfig).pipe(Ue(h => { d.component = h }), X(() => { }))); for (const h of d.children) u.push(...c(h)); return u }; return Xc(c(l.targetSnapshot.root)).pipe(ed(), St(1)) }), mm(() => this.afterPreactivation()), X(l => { const c = function tU(t, n, e) { const i = Ia(t, n._root, e ? e._root : void 0); return new ND(i, n) }(e.routeReuseStrategy, l.targetSnapshot, l.currentRouterState); return this.currentTransition = r = { ...l, targetRouterState: c }, r }), Ue(() => { this.events.next(new im) }), ((t, n, e, i) => X(o => (new uU(n, o.targetRouterState, o.currentRouterState, e, i).activate(t), o)))(this.rootContexts, e.routeReuseStrategy, l => this.events.next(l), this.inputBindingEnabled), St(1), Ue({ next: l => { s = !0, this.lastSuccessfulNavigation = this.currentNavigation, this.events.next(new Fi(l.id, this.urlSerializer.serialize(l.extractedUrl), this.urlSerializer.serialize(l.urlAfterRedirects))), e.titleStrategy?.updateTitle(l.targetRouterState.snapshot), l.resolve(!0) }, complete: () => { s = !0 } }), Ti(this.transitionAbortSubject.pipe(Ue(l => { throw l }))), Pr(() => { s || a || this.cancelNavigationTransition(r, "", 1), this.currentNavigation?.id === r.id && (this.currentNavigation = null) }), Oi(l => { if (a = !0, $D(l)) this.events.next(new Sa(r.id, this.urlSerializer.serialize(r.extractedUrl), l.message, l.cancellationCode)), function oU(t) { return $D(t) && po(t.url) }(l) ? this.events.next(new om(l.url)) : r.resolve(!1); else { this.events.next(new ld(r.id, this.urlSerializer.serialize(r.extractedUrl), l, r.targetSnapshot ?? void 0)); try { r.resolve(e.errorHandler(l)) } catch (c) { r.reject(c) } } return vn })) })) } cancelNavigationTransition(e, i, o) { const r = new Sa(e.id, this.urlSerializer.serialize(e.extractedUrl), i, o); this.events.next(r), e.resolve(!1) } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); function iE(t) { return t !== Ea } let oE = (() => { class t { buildTitle(e) { let i, o = e.root; for (; void 0 !== o;)i = this.getResolvedTitleForRoute(o) ?? i, o = o.children.find(r => r.outlet === Z); return i } getResolvedTitleForRoute(e) { return e.data[ba] } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: function () { return T(tz) }, providedIn: "root" }) } return t })(), tz = (() => { class t extends oE { constructor(e) { super(), this.title = e } updateTitle(e) { const i = this.buildTitle(e); void 0 !== i && this.title.setTitle(i) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(wC)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), nz = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: function () { return T(oz) }, providedIn: "root" }) } return t })(); class iz { shouldDetach(n) { return !1 } store(n, e) { } shouldAttach(n) { return !1 } retrieve(n) { return null } shouldReuseRoute(n, e) { return n.routeConfig === e.routeConfig } } let oz = (() => { class t extends iz { static #e = this.\u0275fac = function () { let e; return function (o) { return (e || (e = ze(t)))(o || t) } }(); static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); const gd = new E("", { providedIn: "root", factory: () => ({}) }); let rz = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: function () { return T(sz) }, providedIn: "root" }) } return t })(), sz = (() => { class t { shouldProcessUrl(e) { return !0 } extract(e) { return e } merge(e, i) { return e } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); var ka = function (t) { return t[t.COMPLETE = 0] = "COMPLETE", t[t.FAILED = 1] = "FAILED", t[t.REDIRECTING = 2] = "REDIRECTING", t }(ka || {}); function rE(t, n) { t.events.pipe(at(e => e instanceof Fi || e instanceof Sa || e instanceof ld || e instanceof Vr), X(e => e instanceof Fi || e instanceof Vr ? ka.COMPLETE : e instanceof Sa && (0 === e.code || 1 === e.code) ? ka.REDIRECTING : ka.FAILED), at(e => e !== ka.REDIRECTING), St(1)).subscribe(() => { n() }) } function az(t) { throw t } function lz(t, n, e) { return n.parse("/") } const cz = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, dz = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let Mt = (() => { class t { get navigationId() { return this.navigationTransitions.navigationId } get browserPageId() { return "computed" !== this.canceledNavigationResolution ? this.currentPageId : this.location.getState()?.\u0275routerPageId ?? this.currentPageId } get events() { return this._events } constructor() { this.disposed = !1, this.currentPageId = 0, this.console = T(Kw), this.isNgZoneEnabled = !1, this._events = new ie, this.options = T(gd, { optional: !0 }) || {}, this.pendingTasks = T(Cc), this.errorHandler = this.options.errorHandler || az, this.malformedUriErrorHandler = this.options.malformedUriErrorHandler || lz, this.navigated = !1, this.lastSuccessfulId = -1, this.urlHandlingStrategy = T(rz), this.routeReuseStrategy = T(nz), this.titleStrategy = T(oE), this.onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore", this.paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly", this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred", this.canceledNavigationResolution = this.options.canceledNavigationResolution || "replace", this.config = T(zr, { optional: !0 })?.flat() ?? [], this.navigationTransitions = T(md), this.urlSerializer = T(wa), this.location = T(Rc), this.componentInputBindingEnabled = !!T(dd, { optional: !0 }), this.eventsSubscription = new Fe, this.isNgZoneEnabled = T(z) instanceof z && z.isInAngularZone(), this.resetConfig(this.config), this.currentUrlTree = new Lr, this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.routerState = LD(0, null), this.navigationTransitions.setupNavigations(this, this.currentUrlTree, this.routerState).subscribe(e => { this.lastSuccessfulId = e.id, this.currentPageId = this.browserPageId }, e => { this.console.warn(`Unhandled Navigation Error: ${e}`) }), this.subscribeToNavigationEvents() } subscribeToNavigationEvents() { const e = this.navigationTransitions.events.subscribe(i => { try { const { currentTransition: o } = this.navigationTransitions; if (null === o) return void (sE(i) && this._events.next(i)); if (i instanceof ad) iE(o.source) && (this.browserUrlTree = o.extractedUrl); else if (i instanceof Vr) this.rawUrlTree = o.rawUrl; else if (i instanceof kD) { if ("eager" === this.urlUpdateStrategy) { if (!o.extras.skipLocationChange) { const r = this.urlHandlingStrategy.merge(o.urlAfterRedirects, o.rawUrl); this.setBrowserUrl(r, o) } this.browserUrlTree = o.urlAfterRedirects } } else if (i instanceof im) this.currentUrlTree = o.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(o.urlAfterRedirects, o.rawUrl), this.routerState = o.targetRouterState, "deferred" === this.urlUpdateStrategy && (o.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, o), this.browserUrlTree = o.urlAfterRedirects); else if (i instanceof Sa) 0 !== i.code && 1 !== i.code && (this.navigated = !0), (3 === i.code || 2 === i.code) && this.restoreHistory(o); else if (i instanceof om) { const r = this.urlHandlingStrategy.merge(i.url, o.currentRawUrl), s = { skipLocationChange: o.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy || iE(o.source) }; this.scheduleNavigation(r, Ea, null, s, { resolve: o.resolve, reject: o.reject, promise: o.promise }) } i instanceof ld && this.restoreHistory(o, !0), i instanceof Fi && (this.navigated = !0), sE(i) && this._events.next(i) } catch (o) { this.navigationTransitions.transitionAbortSubject.next(o) } }); this.eventsSubscription.add(e) } resetRootComponentType(e) { this.routerState.root.component = e, this.navigationTransitions.rootComponentType = e } initialNavigation() { if (this.setUpLocationChangeListener(), !this.navigationTransitions.hasRequestedNavigation) { const e = this.location.getState(); this.navigateToSyncWithBrowser(this.location.path(!0), Ea, e) } } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(e => { const i = "popstate" === e.type ? "popstate" : "hashchange"; "popstate" === i && setTimeout(() => { this.navigateToSyncWithBrowser(e.url, i, e.state) }, 0) })) } navigateToSyncWithBrowser(e, i, o) { const r = { replaceUrl: !0 }, s = o?.navigationId ? o : null; if (o) { const l = { ...o }; delete l.navigationId, delete l.\u0275routerPageId, 0 !== Object.keys(l).length && (r.state = l) } const a = this.parseUrl(e); this.scheduleNavigation(a, i, s, r) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.navigationTransitions.currentNavigation } get lastSuccessfulNavigation() { return this.navigationTransitions.lastSuccessfulNavigation } resetConfig(e) { this.config = e.map(hm), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.navigationTransitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0, this.eventsSubscription.unsubscribe() } createUrlTree(e, i = {}) { const { relativeTo: o, queryParams: r, fragment: s, queryParamsHandling: a, preserveFragment: l } = i, c = l ? this.currentUrlTree.fragment : s; let u, d = null; switch (a) { case "merge": d = { ...this.currentUrlTree.queryParams, ...r }; break; case "preserve": d = this.currentUrlTree.queryParams; break; default: d = r || null }null !== d && (d = this.removeEmptyProps(d)); try { u = SD(o ? o.snapshot : this.routerState.snapshot.root) } catch { ("string" != typeof e[0] || !e[0].startsWith("/")) && (e = []), u = this.currentUrlTree.root } return MD(u, e, d, c ?? null) } navigateByUrl(e, i = { skipLocationChange: !1 }) { const o = po(e) ? e : this.parseUrl(e), r = this.urlHandlingStrategy.merge(o, this.rawUrlTree); return this.scheduleNavigation(r, Ea, null, i) } navigate(e, i = { skipLocationChange: !1 }) { return function uz(t) { for (let n = 0; n < t.length; n++)if (null == t[n]) throw new b(4008, !1) }(e), this.navigateByUrl(this.createUrlTree(e, i), i) } serializeUrl(e) { return this.urlSerializer.serialize(e) } parseUrl(e) { let i; try { i = this.urlSerializer.parse(e) } catch (o) { i = this.malformedUriErrorHandler(o, this.urlSerializer, e) } return i } isActive(e, i) { let o; if (o = !0 === i ? { ...cz } : !1 === i ? { ...dz } : i, po(e)) return _D(this.currentUrlTree, e, o); const r = this.parseUrl(e); return _D(this.currentUrlTree, r, o) } removeEmptyProps(e) { return Object.keys(e).reduce((i, o) => { const r = e[o]; return null != r && (i[o] = r), i }, {}) } scheduleNavigation(e, i, o, r, s) { if (this.disposed) return Promise.resolve(!1); let a, l, c; s ? (a = s.resolve, l = s.reject, c = s.promise) : c = new Promise((u, h) => { a = u, l = h }); const d = this.pendingTasks.add(); return rE(this, () => { queueMicrotask(() => this.pendingTasks.remove(d)) }), this.navigationTransitions.handleNavigationRequest({ source: i, restoredState: o, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, currentBrowserUrl: this.browserUrlTree, rawUrl: e, extras: r, resolve: a, reject: l, promise: c, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), c.catch(u => Promise.reject(u)) } setBrowserUrl(e, i) { const o = this.urlSerializer.serialize(e); if (this.location.isCurrentPathEqualTo(o) || i.extras.replaceUrl) { const s = { ...i.extras.state, ...this.generateNgRouterState(i.id, this.browserPageId) }; this.location.replaceState(o, "", s) } else { const r = { ...i.extras.state, ...this.generateNgRouterState(i.id, this.browserPageId + 1) }; this.location.go(o, "", r) } } restoreHistory(e, i = !1) { if ("computed" === this.canceledNavigationResolution) { const r = this.currentPageId - this.browserPageId; 0 !== r ? this.location.historyGo(r) : this.currentUrlTree === this.getCurrentNavigation()?.finalUrl && 0 === r && (this.resetState(e), this.browserUrlTree = e.currentUrlTree, this.resetUrlToCurrentUrlTree()) } else "replace" === this.canceledNavigationResolution && (i && this.resetState(e), this.resetUrlToCurrentUrlTree()) } resetState(e) { this.routerState = e.currentRouterState, this.currentUrlTree = e.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, e.rawUrl) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } generateNgRouterState(e, i) { return "computed" === this.canceledNavigationResolution ? { navigationId: e, \u0275routerPageId: i } : { navigationId: e } } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); function sE(t) { return !(t instanceof im || t instanceof om) } let $r = (() => { class t { constructor(e, i, o, r, s, a) { this.router = e, this.route = i, this.tabIndexAttribute = o, this.renderer = r, this.el = s, this.locationStrategy = a, this.href = null, this.commands = null, this.onChanges = new ie, this.preserveFragment = !1, this.skipLocationChange = !1, this.replaceUrl = !1; const l = s.nativeElement.tagName?.toLowerCase(); this.isAnchorElement = "a" === l || "area" === l, this.isAnchorElement ? this.subscription = e.events.subscribe(c => { c instanceof Fi && this.updateHref() }) : this.setTabIndexIfNotOnNativeEl("0") } setTabIndexIfNotOnNativeEl(e) { null != this.tabIndexAttribute || this.isAnchorElement || this.applyAttributeValue("tabindex", e) } ngOnChanges(e) { this.isAnchorElement && this.updateHref(), this.onChanges.next(this) } set routerLink(e) { null != e ? (this.commands = Array.isArray(e) ? e : [e], this.setTabIndexIfNotOnNativeEl("0")) : (this.commands = null, this.setTabIndexIfNotOnNativeEl(null)) } onClick(e, i, o, r, s) { return !!(null === this.urlTree || this.isAnchorElement && (0 !== e || i || o || r || s || "string" == typeof this.target && "_self" != this.target)) || (this.router.navigateByUrl(this.urlTree, { skipLocationChange: this.skipLocationChange, replaceUrl: this.replaceUrl, state: this.state }), !this.isAnchorElement) } ngOnDestroy() { this.subscription?.unsubscribe() } updateHref() { this.href = null !== this.urlTree && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) : null; const e = null === this.href ? null : function hb(t, n, e) { return function EO(t, n) { return "src" === n && ("embed" === t || "frame" === t || "iframe" === t || "media" === t || "script" === t) || "href" === n && ("base" === t || "link" === t) ? ub : tr }(n, e)(t) }(this.href, this.el.nativeElement.tagName.toLowerCase(), "href"); this.applyAttributeValue("href", e) } applyAttributeValue(e, i) { const o = this.renderer, r = this.el.nativeElement; null !== i ? o.setAttribute(r, e, i) : o.removeAttribute(r, e) } get urlTree() { return null === this.commands ? null : this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: this.preserveFragment }) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(Mt), g(Gn), Uo("tabindex"), g(ni), g(ye), g(lo)) }; static #t = this.\u0275dir = P({ type: t, selectors: [["", "routerLink", ""]], hostVars: 1, hostBindings: function (i, o) { 1 & i && se("click", function (s) { return o.onClick(s.button, s.ctrlKey, s.shiftKey, s.altKey, s.metaKey) }), 2 & i && Ke("target", o.target) }, inputs: { target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", state: "state", relativeTo: "relativeTo", preserveFragment: ["preserveFragment", "preserveFragment", Sr], skipLocationChange: ["skipLocationChange", "skipLocationChange", Sr], replaceUrl: ["replaceUrl", "replaceUrl", Sr], routerLink: "routerLink" }, standalone: !0, features: [xy, Ft] }) } return t })(); class aE { } let pz = (() => { class t { constructor(e, i, o, r, s) { this.router = e, this.injector = o, this.preloadingStrategy = r, this.loader = s } setUpPreloading() { this.subscription = this.router.events.pipe(at(e => e instanceof Fi), Fr(() => this.preload())).subscribe(() => { }) } preload() { return this.processRoutes(this.injector, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(e, i) { const o = []; for (const r of i) { r.providers && !r._injector && (r._injector = Ff(r.providers, e, `Route: ${r.path}`)); const s = r._injector ?? e, a = r._loadedInjector ?? s; (r.loadChildren && !r._loadedRoutes && void 0 === r.canLoad || r.loadComponent && !r._loadedComponent) && o.push(this.preloadConfig(s, r)), (r.children || r._loadedRoutes) && o.push(this.processRoutes(a, r.children ?? r._loadedRoutes)) } return Ye(o).pipe(Ao()) } preloadConfig(e, i) { return this.preloadingStrategy.preload(i, () => { let o; o = i.loadChildren && void 0 === i.canLoad ? this.loader.loadChildren(e, i) : N(null); const r = o.pipe(We(s => null === s ? N(void 0) : (i._loadedRoutes = s.routes, i._loadedInjector = s.injector, this.processRoutes(s.injector ?? e, s.routes)))); return i.loadComponent && !i._loadedComponent ? Ye([r, this.loader.loadComponent(i)]).pipe(Ao()) : r }) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(Mt), w(Qw), w(Wt), w(aE), w(gm)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); const _m = new E(""); let lE = (() => { class t { constructor(e, i, o, r, s = {}) { this.urlSerializer = e, this.transitions = i, this.viewportScroller = o, this.zone = r, this.options = s, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, s.scrollPositionRestoration = s.scrollPositionRestoration || "disabled", s.anchorScrolling = s.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.transitions.events.subscribe(e => { e instanceof ad ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = e.navigationTrigger, this.restoredId = e.restoredState ? e.restoredState.navigationId : 0) : e instanceof Fi ? (this.lastId = e.id, this.scheduleScrollEvent(e, this.urlSerializer.parse(e.urlAfterRedirects).fragment)) : e instanceof Vr && 0 === e.code && (this.lastSource = void 0, this.restoredId = 0, this.scheduleScrollEvent(e, this.urlSerializer.parse(e.url).fragment)) }) } consumeScrollEvents() { return this.transitions.events.subscribe(e => { e instanceof FD && (e.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(e.position) : e.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(e.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(e, i) { this.zone.runOutsideAngular(() => { setTimeout(() => { this.zone.run(() => { this.transitions.events.next(new FD(e, "popstate" === this.lastSource ? this.store[this.restoredId] : null, i)) }) }, 0) }) } ngOnDestroy() { this.routerEventsSubscription?.unsubscribe(), this.scrollEventsSubscription?.unsubscribe() } static #e = this.\u0275fac = function (i) { ic() }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })(); function di(t, n) { return { \u0275kind: t, \u0275providers: n } } function dE() { const t = T(ft); return n => { const e = t.get(Si); if (n !== e.components[0]) return; const i = t.get(Mt), o = t.get(uE); 1 === t.get(vm) && i.initialNavigation(), t.get(hE, null, J.Optional)?.setUpPreloading(), t.get(_m, null, J.Optional)?.init(), i.resetRootComponentType(e.componentTypes[0]), o.closed || (o.next(), o.complete(), o.unsubscribe()) } } const uE = new E("", { factory: () => new ie }), vm = new E("", { providedIn: "root", factory: () => 1 }), hE = new E(""); function vz(t) { return di(0, [{ provide: hE, useExisting: pz }, { provide: aE, useExisting: t }]) } const fE = new E("ROUTER_FORROOT_GUARD"), yz = [Rc, { provide: wa, useClass: Qp }, Mt, Ma, { provide: Gn, useFactory: function cE(t) { return t.routerState.root }, deps: [Mt] }, gm, []]; function wz() { return new rx("Router", Mt) } let pE = (() => { class t { constructor(e) { } static forRoot(e, i) { return { ngModule: t, providers: [yz, [], { provide: zr, multi: !0, useValue: e }, { provide: fE, useFactory: Ez, deps: [[Mt, new Xi, new Es]] }, { provide: gd, useValue: i || {} }, i?.useHash ? { provide: lo, useClass: m2 } : { provide: lo, useClass: Px }, { provide: _m, useFactory: () => { const t = T(FV), n = T(z), e = T(gd), i = T(md), o = T(wa); return e.scrollOffset && t.setOffset(e.scrollOffset), new lE(o, i, t, n, e) } }, i?.preloadingStrategy ? vz(i.preloadingStrategy).\u0275providers : [], { provide: rx, multi: !0, useFactory: wz }, i?.initialNavigation ? Sz(i) : [], i?.bindToComponentInputs ? di(8, [HD, { provide: dd, useExisting: HD }]).\u0275providers : [], [{ provide: mE, useFactory: dE }, { provide: tp, multi: !0, useExisting: mE }]] } } static forChild(e) { return { ngModule: t, providers: [{ provide: zr, multi: !0, useValue: e }] } } static #e = this.\u0275fac = function (i) { return new (i || t)(w(fE, 8)) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({}) } return t })(); function Ez(t) { return "guarded" } function Sz(t) { return ["disabled" === t.initialNavigation ? di(3, [{ provide: Wf, multi: !0, useFactory: () => { const n = T(Mt); return () => { n.setUpLocationChangeListener() } } }, { provide: vm, useValue: 2 }]).\u0275providers : [], "enabledBlocking" === t.initialNavigation ? di(2, [{ provide: vm, useValue: 0 }, { provide: Wf, multi: !0, deps: [ft], useFactory: n => { const e = n.get(f2, Promise.resolve()); return () => e.then(() => new Promise(i => { const o = n.get(Mt), r = n.get(uE); rE(o, () => { i(!0) }), n.get(md).afterPreactivation = () => (i(!0), r.closed ? N(void 0) : r), o.initialNavigation() })) } }]).\u0275providers : []] } const mE = new E(""); class _d { } class vd { } class pn { constructor(n) { this.normalizedNames = new Map, this.lazyUpdate = null, n ? "string" == typeof n ? this.lazyInit = () => { this.headers = new Map, n.split("\n").forEach(e => { const i = e.indexOf(":"); if (i > 0) { const o = e.slice(0, i), r = o.toLowerCase(), s = e.slice(i + 1).trim(); this.maybeSetNormalizedName(o, r), this.headers.has(r) ? this.headers.get(r).push(s) : this.headers.set(r, [s]) } }) } : typeof Headers < "u" && n instanceof Headers ? (this.headers = new Map, n.forEach((e, i) => { this.setHeaderEntries(i, e) })) : this.lazyInit = () => { this.headers = new Map, Object.entries(n).forEach(([e, i]) => { this.setHeaderEntries(e, i) }) } : this.headers = new Map } has(n) { return this.init(), this.headers.has(n.toLowerCase()) } get(n) { this.init(); const e = this.headers.get(n.toLowerCase()); return e && e.length > 0 ? e[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(n) { return this.init(), this.headers.get(n.toLowerCase()) || null } append(n, e) { return this.clone({ name: n, value: e, op: "a" }) } set(n, e) { return this.clone({ name: n, value: e, op: "s" }) } delete(n, e) { return this.clone({ name: n, value: e, op: "d" }) } maybeSetNormalizedName(n, e) { this.normalizedNames.has(e) || this.normalizedNames.set(e, n) } init() { this.lazyInit && (this.lazyInit instanceof pn ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(n => this.applyUpdate(n)), this.lazyUpdate = null)) } copyFrom(n) { n.init(), Array.from(n.headers.keys()).forEach(e => { this.headers.set(e, n.headers.get(e)), this.normalizedNames.set(e, n.normalizedNames.get(e)) }) } clone(n) { const e = new pn; return e.lazyInit = this.lazyInit && this.lazyInit instanceof pn ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([n]), e } applyUpdate(n) { const e = n.name.toLowerCase(); switch (n.op) { case "a": case "s": let i = n.value; if ("string" == typeof i && (i = [i]), 0 === i.length) return; this.maybeSetNormalizedName(n.name, e); const o = ("a" === n.op ? this.headers.get(e) : void 0) || []; o.push(...i), this.headers.set(e, o); break; case "d": const r = n.value; if (r) { let s = this.headers.get(e); if (!s) return; s = s.filter(a => -1 === r.indexOf(a)), 0 === s.length ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, s) } else this.headers.delete(e), this.normalizedNames.delete(e) } } setHeaderEntries(n, e) { const i = (Array.isArray(e) ? e : [e]).map(r => r.toString()), o = n.toLowerCase(); this.headers.set(o, i), this.maybeSetNormalizedName(n, o) } forEach(n) { this.init(), Array.from(this.normalizedNames.keys()).forEach(e => n(this.normalizedNames.get(e), this.headers.get(e))) } } class Iz { encodeKey(n) { return gE(n) } encodeValue(n) { return gE(n) } decodeKey(n) { return decodeURIComponent(n) } decodeValue(n) { return decodeURIComponent(n) } } const Tz = /%(\d[a-f0-9])/gi, Rz = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "3D": "=", "3F": "?", "2F": "/" }; function gE(t) { return encodeURIComponent(t).replace(Tz, (n, e) => Rz[e] ?? n) } function bd(t) { return `${t}` } class Pi { constructor(n = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = n.encoder || new Iz, n.fromString) { if (n.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function Az(t, n) { const e = new Map; return t.length > 0 && t.replace(/^\?/, "").split("&").forEach(o => { const r = o.indexOf("="), [s, a] = -1 == r ? [n.decodeKey(o), ""] : [n.decodeKey(o.slice(0, r)), n.decodeValue(o.slice(r + 1))], l = e.get(s) || []; l.push(a), e.set(s, l) }), e }(n.fromString, this.encoder) } else n.fromObject ? (this.map = new Map, Object.keys(n.fromObject).forEach(e => { const i = n.fromObject[e], o = Array.isArray(i) ? i.map(bd) : [bd(i)]; this.map.set(e, o) })) : this.map = null } has(n) { return this.init(), this.map.has(n) } get(n) { this.init(); const e = this.map.get(n); return e ? e[0] : null } getAll(n) { return this.init(), this.map.get(n) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(n, e) { return this.clone({ param: n, value: e, op: "a" }) } appendAll(n) { const e = []; return Object.keys(n).forEach(i => { const o = n[i]; Array.isArray(o) ? o.forEach(r => { e.push({ param: i, value: r, op: "a" }) }) : e.push({ param: i, value: o, op: "a" }) }), this.clone(e) } set(n, e) { return this.clone({ param: n, value: e, op: "s" }) } delete(n, e) { return this.clone({ param: n, value: e, op: "d" }) } toString() { return this.init(), this.keys().map(n => { const e = this.encoder.encodeKey(n); return this.map.get(n).map(i => e + "=" + this.encoder.encodeValue(i)).join("&") }).filter(n => "" !== n).join("&") } clone(n) { const e = new Pi({ encoder: this.encoder }); return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat(n), e } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(n => this.map.set(n, this.cloneFrom.map.get(n))), this.updates.forEach(n => { switch (n.op) { case "a": case "s": const e = ("a" === n.op ? this.map.get(n.param) : void 0) || []; e.push(bd(n.value)), this.map.set(n.param, e); break; case "d": if (void 0 === n.value) { this.map.delete(n.param); break } { let i = this.map.get(n.param) || []; const o = i.indexOf(bd(n.value)); -1 !== o && i.splice(o, 1), i.length > 0 ? this.map.set(n.param, i) : this.map.delete(n.param) } } }), this.cloneFrom = this.updates = null) } } class Oz { constructor() { this.map = new Map } set(n, e) { return this.map.set(n, e), this } get(n) { return this.map.has(n) || this.map.set(n, n.defaultValue()), this.map.get(n) } delete(n) { return this.map.delete(n), this } has(n) { return this.map.has(n) } keys() { return this.map.keys() } } function _E(t) { return typeof ArrayBuffer < "u" && t instanceof ArrayBuffer } function vE(t) { return typeof Blob < "u" && t instanceof Blob } function bE(t) { return typeof FormData < "u" && t instanceof FormData } class Fa { constructor(n, e, i, o) { let r; if (this.url = e, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = n.toUpperCase(), function kz(t) { switch (t) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || o ? (this.body = void 0 !== i ? i : null, r = o) : r = i, r && (this.reportProgress = !!r.reportProgress, this.withCredentials = !!r.withCredentials, r.responseType && (this.responseType = r.responseType), r.headers && (this.headers = r.headers), r.context && (this.context = r.context), r.params && (this.params = r.params)), this.headers || (this.headers = new pn), this.context || (this.context = new Oz), this.params) { const s = this.params.toString(); if (0 === s.length) this.urlWithParams = e; else { const a = e.indexOf("?"); this.urlWithParams = e + (-1 === a ? "?" : a < e.length - 1 ? "&" : "") + s } } else this.params = new Pi, this.urlWithParams = e } serializeBody() { return null === this.body ? null : _E(this.body) || vE(this.body) || bE(this.body) || function Fz(t) { return typeof URLSearchParams < "u" && t instanceof URLSearchParams }(this.body) || "string" == typeof this.body ? this.body : this.body instanceof Pi ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || bE(this.body) ? null : vE(this.body) ? this.body.type || null : _E(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof Pi ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(n = {}) { const e = n.method || this.method, i = n.url || this.url, o = n.responseType || this.responseType, r = void 0 !== n.body ? n.body : this.body, s = void 0 !== n.withCredentials ? n.withCredentials : this.withCredentials, a = void 0 !== n.reportProgress ? n.reportProgress : this.reportProgress; let l = n.headers || this.headers, c = n.params || this.params; const d = n.context ?? this.context; return void 0 !== n.setHeaders && (l = Object.keys(n.setHeaders).reduce((u, h) => u.set(h, n.setHeaders[h]), l)), n.setParams && (c = Object.keys(n.setParams).reduce((u, h) => u.set(h, n.setParams[h]), c)), new Fa(e, i, r, { params: c, headers: l, context: d, reportProgress: a, responseType: o, withCredentials: s }) } } var Gr = function (t) { return t[t.Sent = 0] = "Sent", t[t.UploadProgress = 1] = "UploadProgress", t[t.ResponseHeader = 2] = "ResponseHeader", t[t.DownloadProgress = 3] = "DownloadProgress", t[t.Response = 4] = "Response", t[t.User = 5] = "User", t }(Gr || {}); class bm { constructor(n, e = 200, i = "OK") { this.headers = n.headers || new pn, this.status = void 0 !== n.status ? n.status : e, this.statusText = n.statusText || i, this.url = n.url || null, this.ok = this.status >= 200 && this.status < 300 } } class ym extends bm { constructor(n = {}) { super(n), this.type = Gr.ResponseHeader } clone(n = {}) { return new ym({ headers: n.headers || this.headers, status: void 0 !== n.status ? n.status : this.status, statusText: n.statusText || this.statusText, url: n.url || this.url || void 0 }) } } class qr extends bm { constructor(n = {}) { super(n), this.type = Gr.Response, this.body = void 0 !== n.body ? n.body : null } clone(n = {}) { return new qr({ body: void 0 !== n.body ? n.body : this.body, headers: n.headers || this.headers, status: void 0 !== n.status ? n.status : this.status, statusText: n.statusText || this.statusText, url: n.url || this.url || void 0 }) } } class yE extends bm { constructor(n) { super(n, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${n.url || "(unknown url)"}` : `Http failure response for ${n.url || "(unknown url)"}: ${n.status} ${n.statusText}`, this.error = n.error || null } } function wm(t, n) { return { body: n, headers: t.headers, context: t.context, observe: t.observe, params: t.params, reportProgress: t.reportProgress, responseType: t.responseType, withCredentials: t.withCredentials } } let Pa = (() => { class t { constructor(e) { this.handler = e } request(e, i, o = {}) { let r; if (e instanceof Fa) r = e; else { let l, c; l = o.headers instanceof pn ? o.headers : new pn(o.headers), o.params && (c = o.params instanceof Pi ? o.params : new Pi({ fromObject: o.params })), r = new Fa(e, i, void 0 !== o.body ? o.body : null, { headers: l, context: o.context, params: c, reportProgress: o.reportProgress, responseType: o.responseType || "json", withCredentials: o.withCredentials }) } const s = N(r).pipe(Fr(l => this.handler.handle(l))); if (e instanceof Fa || "events" === o.observe) return s; const a = s.pipe(at(l => l instanceof qr)); switch (o.observe || "body") { case "body": switch (r.responseType) { case "arraybuffer": return a.pipe(X(l => { if (null !== l.body && !(l.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return l.body })); case "blob": return a.pipe(X(l => { if (null !== l.body && !(l.body instanceof Blob)) throw new Error("Response is not a Blob."); return l.body })); case "text": return a.pipe(X(l => { if (null !== l.body && "string" != typeof l.body) throw new Error("Response is not a string."); return l.body })); default: return a.pipe(X(l => l.body)) }case "response": return a; default: throw new Error(`Unreachable: unhandled observe type ${o.observe}}`) } } delete(e, i = {}) { return this.request("DELETE", e, i) } get(e, i = {}) { return this.request("GET", e, i) } head(e, i = {}) { return this.request("HEAD", e, i) } jsonp(e, i) { return this.request("JSONP", e, { params: (new Pi).append(i, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(e, i = {}) { return this.request("OPTIONS", e, i) } patch(e, i, o = {}) { return this.request("PATCH", e, wm(o, i)) } post(e, i, o = {}) { return this.request("POST", e, wm(o, i)) } put(e, i, o = {}) { return this.request("PUT", e, wm(o, i)) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(_d)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })(); function CE(t, n) { return n(t) } function Nz(t, n) { return (e, i) => n.intercept(e, { handle: o => t(o, i) }) } const Vz = new E(""), Na = new E(""), DE = new E(""); function Bz() { let t = null; return (n, e) => { null === t && (t = (T(Vz, { optional: !0 }) ?? []).reduceRight(Nz, CE)); const i = T(Cc), o = i.add(); return t(n, e).pipe(Pr(() => i.remove(o))) } } let EE = (() => { class t extends _d { constructor(e, i) { super(), this.backend = e, this.injector = i, this.chain = null, this.pendingTasks = T(Cc) } handle(e) { if (null === this.chain) { const o = Array.from(new Set([...this.injector.get(Na), ...this.injector.get(DE, [])])); this.chain = o.reduceRight((r, s) => function Lz(t, n, e) { return (i, o) => e.runInContext(() => n(i, r => t(r, o))) }(r, s, this.injector), CE) } const i = this.pendingTasks.add(); return this.chain(e, o => this.backend.handle(o)).pipe(Pr(() => this.pendingTasks.remove(i))) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(vd), w(Wt)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })(); const zz = /^\)\]\}',?\n/; let ME = (() => { class t { constructor(e) { this.xhrFactory = e } handle(e) { if ("JSONP" === e.method) throw new b(-2800, !1); const i = this.xhrFactory; return (i.\u0275loadImpl ? Ye(i.\u0275loadImpl()) : N(null)).pipe(Tt(() => new xe(r => { const s = i.build(); if (s.open(e.method, e.urlWithParams), e.withCredentials && (s.withCredentials = !0), e.headers.forEach((m, _) => s.setRequestHeader(m, _.join(","))), e.headers.has("Accept") || s.setRequestHeader("Accept", "application/json, text/plain, */*"), !e.headers.has("Content-Type")) { const m = e.detectContentTypeHeader(); null !== m && s.setRequestHeader("Content-Type", m) } if (e.responseType) { const m = e.responseType.toLowerCase(); s.responseType = "json" !== m ? m : "text" } const a = e.serializeBody(); let l = null; const c = () => { if (null !== l) return l; const m = s.statusText || "OK", _ = new pn(s.getAllResponseHeaders()), C = function $z(t) { return "responseURL" in t && t.responseURL ? t.responseURL : /^X-Request-URL:/m.test(t.getAllResponseHeaders()) ? t.getResponseHeader("X-Request-URL") : null }(s) || e.url; return l = new ym({ headers: _, status: s.status, statusText: m, url: C }), l }, d = () => { let { headers: m, status: _, statusText: C, url: v } = c(), M = null; 204 !== _ && (M = typeof s.response > "u" ? s.responseText : s.response), 0 === _ && (_ = M ? 200 : 0); let O = _ >= 200 && _ < 300; if ("json" === e.responseType && "string" == typeof M) { const $ = M; M = M.replace(zz, ""); try { M = "" !== M ? JSON.parse(M) : null } catch (ve) { M = $, O && (O = !1, M = { error: ve, text: M }) } } O ? (r.next(new qr({ body: M, headers: m, status: _, statusText: C, url: v || void 0 })), r.complete()) : r.error(new yE({ error: M, headers: m, status: _, statusText: C, url: v || void 0 })) }, u = m => { const { url: _ } = c(), C = new yE({ error: m, status: s.status || 0, statusText: s.statusText || "Unknown Error", url: _ || void 0 }); r.error(C) }; let h = !1; const f = m => { h || (r.next(c()), h = !0); let _ = { type: Gr.DownloadProgress, loaded: m.loaded }; m.lengthComputable && (_.total = m.total), "text" === e.responseType && s.responseText && (_.partialText = s.responseText), r.next(_) }, p = m => { let _ = { type: Gr.UploadProgress, loaded: m.loaded }; m.lengthComputable && (_.total = m.total), r.next(_) }; return s.addEventListener("load", d), s.addEventListener("error", u), s.addEventListener("timeout", u), s.addEventListener("abort", u), e.reportProgress && (s.addEventListener("progress", f), null !== a && s.upload && s.upload.addEventListener("progress", p)), s.send(a), r.next({ type: Gr.Sent }), () => { s.removeEventListener("error", u), s.removeEventListener("abort", u), s.removeEventListener("load", d), s.removeEventListener("timeout", u), e.reportProgress && (s.removeEventListener("progress", f), null !== a && s.upload && s.upload.removeEventListener("progress", p)), s.readyState !== s.DONE && s.abort() } }))) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(iC)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })(); const xm = new E("XSRF_ENABLED"), IE = new E("XSRF_COOKIE_NAME", { providedIn: "root", factory: () => "XSRF-TOKEN" }), AE = new E("XSRF_HEADER_NAME", { providedIn: "root", factory: () => "X-XSRF-TOKEN" }); class TE { } let Wz = (() => { class t { constructor(e, i, o) { this.doc = e, this.platform = i, this.cookieName = o, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const e = this.doc.cookie || ""; return e !== this.lastCookieString && (this.parseCount++, this.lastToken = Gx(e, this.cookieName), this.lastCookieString = e), this.lastToken } static #e = this.\u0275fac = function (i) { return new (i || t)(w(te), w(Ci), w(IE)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })(); function Yz(t, n) { const e = t.url.toLowerCase(); if (!T(xm) || "GET" === t.method || "HEAD" === t.method || e.startsWith("http://") || e.startsWith("https://")) return n(t); const i = T(TE).getToken(), o = T(AE); return null != i && !t.headers.has(o) && (t = t.clone({ headers: t.headers.set(o, i) })), n(t) } var Ni = function (t) { return t[t.Interceptors = 0] = "Interceptors", t[t.LegacyInterceptors = 1] = "LegacyInterceptors", t[t.CustomXsrfConfiguration = 2] = "CustomXsrfConfiguration", t[t.NoXsrfProtection = 3] = "NoXsrfProtection", t[t.JsonpSupport = 4] = "JsonpSupport", t[t.RequestsMadeViaParent = 5] = "RequestsMadeViaParent", t[t.Fetch = 6] = "Fetch", t }(Ni || {}); function Zz(...t) { const n = [Pa, ME, EE, { provide: _d, useExisting: EE }, { provide: vd, useExisting: ME }, { provide: Na, useValue: Yz, multi: !0 }, { provide: xm, useValue: !0 }, { provide: TE, useClass: Wz }]; for (const e of t) n.push(...e.\u0275providers); return function Sh(t) { return { \u0275providers: t } }(n) } const RE = new E("LEGACY_INTERCEPTOR_FN"); function Xz() { return function mo(t, n) { return { \u0275kind: t, \u0275providers: n } }(Ni.LegacyInterceptors, [{ provide: RE, useFactory: Bz }, { provide: Na, useExisting: RE, multi: !0 }]) } let Kz = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ providers: [Zz(Xz())] }) } return t })(), go = (() => { class t { constructor(e) { this.http = e, this.res = !1, this.endpoint = "https://bookstore-5wpg.onrender.com/api/", this._options = { headers: new pn({ "Content-Type": "application/json" }) } } getallBooks() { return this.http.get(this.endpoint + "books") } getBookDetails(e) { return this.http.get(this.endpoint + "books/get/" + e) } addBook(e) { return this.http.post(this.endpoint + "books/create", JSON.stringify(e)) } getUserShopdetails(e) { return this.http.get(this.endpoint + "user/get/shop-cart-items/" + e) } addItemToShopcart(e) { return console.log(e), this.http.post(this.endpoint + "user/addshopcart", JSON.stringify(e), this._options) } delShopcarItem(e) { return this.http.post(this.endpoint + "user/shop/delete", JSON.stringify(e), this._options) } sendComment(e, i, o) { const r = { id: i, name: o, comment: e }; console.log(r), this.http.post(this.endpoint + "books/comments/add", JSON.stringify(r), this._options).subscribe() } getComments(e) { return console.log(e), this.http.get(this.endpoint + "books/comments/get/" + e) } placeOrder(e) { return this.http.post(this.endpoint + "user/orders/create", JSON.stringify(e), this._options) } setOutOfStock(e) { e.forEach(i => { this.http.get(this.endpoint + "books/add-to/out-of-stock/" + i).subscribe(o => { console.log(o) }) }) } getOrderHistory(e) { return this.http.get(this.endpoint + "user/order-history/id/" + e) } searchBook(e) { return this.http.get(`${this.endpoint}books/search/${0 === e.length ? "9" : e}`) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(Pa)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); function i$(t, n) { if (1 & t && (x(0, "a", 3)(1, "div", 4), U(2, "img", 5), y(), x(3, "div", 6)(4, "h2"), A(5), y(), x(6, "p"), A(7), y()()()), 2 & t) { const e = n.$implicit; yr("routerLink", "book/", e._id, ""), S(2), br("src", e.img1, tr), S(3), Zt(e.title), S(2), ln("By ", e.author, "") } } let o$ = (() => { class t { constructor(e) { this.api = e, this.api.getallBooks().subscribe(i => this.data = i) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(go)) }; static #t = this.\u0275cmp = tt({ type: t, selectors: [["app-home"]], decls: 3, vars: 1, consts: [[1, "container", "py-5", 2, "background-color", "#fff"], [1, "row", "mx-auto"], ["class", "cont col-lg-4 border m-2 text-center", 3, "routerLink", 4, "ngFor", "ngForOf"], [1, "cont", "col-lg-4", "border", "m-2", "text-center", 3, "routerLink"], [1, "img-container", "my-3"], ["height", "200", "alt", "", "srcset", "", 3, "src"], [1, "content"]], template: function (i, o) { 1 & i && (x(0, "div", 0)(1, "div", 1), Q(2, i$, 8, 4, "a", 2), y()()), 2 & i && (S(2), k("ngForOf", o.data)) }, dependencies: [Ir, $r], styles: [".cont[_ngcontent-%COMP%]{width:19rem;text-decoration:none;color:#000;transition:.3s}.cont[_ngcontent-%COMP%]:hover{box-shadow:0 0 5px #0003}.cont[_ngcontent-%COMP%]:hover   h2[_ngcontent-%COMP%]{color:#00f}@media (max-width: 700px){.cont[_ngcontent-%COMP%]{width:100%}}"] }) } return t })(); function OE(t, n, e, i, o, r, s) { try { var a = t[r](s), l = a.value } catch (c) { return void e(c) } a.done ? n(l) : Promise.resolve(l).then(i, o) } function Wr(t) { return function () { var n = this, e = arguments; return new Promise(function (i, o) { var r = t.apply(n, e); function s(l) { OE(r, i, o, s, a, "next", l) } function a(l) { OE(r, i, o, s, a, "throw", l) } s(void 0) }) } } let Yr = (() => { class t { constructor(e) { this.http = e, this.loggedIn = new At(!1), this.logState = this.loggedIn.asObservable(), this.endpoint = "https://bookstore-5wpg.onrender.com/api/user", this._options = { headers: new pn({ "Content-Type": "application/json" }) }, this.checkUserLogState() } userRegister(e) { return new Promise((i, o) => { this.http.post(this.endpoint + "/register", JSON.stringify(e), this._options).subscribe(r => { r.flag && (this.loggedIn.next(!0), console.log(r), this.addUserLocally(r), i(r)) }, r => { console.error("Login failed:", r), o(r) }) }) } userLogin(e) { return new Promise((i, o) => { this.http.post(this.endpoint + "/login", JSON.stringify(e), this._options).subscribe(r => { r.flag ? (this.loggedIn.next(!0), console.log(r), this.addUserLocally(r), i(r)) : (console.log(r), i(r)) }, r => { o(r) }) }) } addUserLocally(e) { localStorage.setItem("loggedIn", "true"), localStorage.setItem("user", JSON.stringify(e)) } logout() { localStorage.removeItem("loggedIn"), localStorage.removeItem("user"), this.loggedIn.next(!1) } checkUserLogState() { const e = localStorage.getItem("loggedIn"), i = localStorage.getItem("user"); "true" === e && i && this.loggedIn.next(!0) } getUser() { return Wr(function* () { const e = localStorage.getItem("user"); return e ? yield JSON.parse(e) : null })() } static #e = this.\u0275fac = function (i) { return new (i || t)(w(Pa)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); function kE(...t) { const n = zg(t), { args: e, keys: i } = NC(t), o = new xe(r => { const { length: s } = e; if (!s) return void r.complete(); const a = new Array(s); let l = s, c = s; for (let d = 0; d < s; d++) { let u = !1; dt(e[d]).subscribe(Ie(r, h => { u || (u = !0, c--), a[d] = h }, () => l--, void 0, () => { (!l || !u) && (c || r.next(i ? LC(i, a) : a), r.complete()) })) } }); return n ? o.pipe(zp(n)) : o } let FE = (() => { class t { constructor(e, i) { this._renderer = e, this._elementRef = i, this.onChange = o => { }, this.onTouched = () => { } } setProperty(e, i) { this._renderer.setProperty(this._elementRef.nativeElement, e, i) } registerOnTouched(e) { this.onTouched = e } registerOnChange(e) { this.onChange = e } setDisabledState(e) { this.setProperty("disabled", e) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(ni), g(ye)) }; static #t = this.\u0275dir = P({ type: t }) } return t })(), _o = (() => { class t extends FE { static #e = this.\u0275fac = function () { let e; return function (o) { return (e || (e = ze(t)))(o || t) } }(); static #t = this.\u0275dir = P({ type: t, features: [K] }) } return t })(); const mn = new E("NgValueAccessor"), s$ = { provide: mn, useExisting: be(() => vo), multi: !0 }, l$ = new E("CompositionEventMode"); let vo = (() => { class t extends FE { constructor(e, i, o) { super(e, i), this._compositionMode = o, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function a$() { const t = Mi() ? Mi().getUserAgent() : ""; return /android (\d+)/.test(t.toLowerCase()) }()) } writeValue(e) { this.setProperty("value", e ?? "") } _handleInput(e) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(e) } _compositionStart() { this._composing = !0 } _compositionEnd(e) { this._composing = !1, this._compositionMode && this.onChange(e) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(ni), g(ye), g(l$, 8)) }; static #t = this.\u0275dir = P({ type: t, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (i, o) { 1 & i && se("input", function (s) { return o._handleInput(s.target.value) })("blur", function () { return o.onTouched() })("compositionstart", function () { return o._compositionStart() })("compositionend", function (s) { return o._compositionEnd(s.target.value) }) }, features: [ge([s$]), K] }) } return t })(); function Li(t) { return null == t || ("string" == typeof t || Array.isArray(t)) && 0 === t.length } function NE(t) { return null != t && "number" == typeof t.length } const gt = new E("NgValidators"), Vi = new E("NgAsyncValidators"), c$ = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/; class jt { static min(n) { return function LE(t) { return n => { if (Li(n.value) || Li(t)) return null; const e = parseFloat(n.value); return !isNaN(e) && e < t ? { min: { min: t, actual: n.value } } : null } }(n) } static max(n) { return function VE(t) { return n => { if (Li(n.value) || Li(t)) return null; const e = parseFloat(n.value); return !isNaN(e) && e > t ? { max: { max: t, actual: n.value } } : null } }(n) } static required(n) { return BE(n) } static requiredTrue(n) { return function jE(t) { return !0 === t.value ? null : { required: !0 } }(n) } static email(n) { return function HE(t) { return Li(t.value) || c$.test(t.value) ? null : { email: !0 } }(n) } static minLength(n) { return function UE(t) { return n => Li(n.value) || !NE(n.value) ? null : n.value.length < t ? { minlength: { requiredLength: t, actualLength: n.value.length } } : null }(n) } static maxLength(n) { return function zE(t) { return n => NE(n.value) && n.value.length > t ? { maxlength: { requiredLength: t, actualLength: n.value.length } } : null }(n) } static pattern(n) { return function $E(t) { if (!t) return wd; let n, e; return "string" == typeof t ? (e = "", "^" !== t.charAt(0) && (e += "^"), e += t, "$" !== t.charAt(t.length - 1) && (e += "$"), n = new RegExp(e)) : (e = t.toString(), n = t), i => { if (Li(i.value)) return null; const o = i.value; return n.test(o) ? null : { pattern: { requiredPattern: e, actualValue: o } } } }(n) } static nullValidator(n) { return null } static compose(n) { return XE(n) } static composeAsync(n) { return KE(n) } } function BE(t) { return Li(t.value) ? { required: !0 } : null } function wd(t) { return null } function GE(t) { return null != t } function qE(t) { return Zs(t) ? Ye(t) : t } function WE(t) { let n = {}; return t.forEach(e => { n = null != e ? { ...n, ...e } : n }), 0 === Object.keys(n).length ? null : n } function YE(t, n) { return n.map(e => e(t)) } function ZE(t) { return t.map(n => function d$(t) { return !t.validate }(n) ? n : e => n.validate(e)) } function XE(t) { if (!t) return null; const n = t.filter(GE); return 0 == n.length ? null : function (e) { return WE(YE(e, n)) } } function Cm(t) { return null != t ? XE(ZE(t)) : null } function KE(t) { if (!t) return null; const n = t.filter(GE); return 0 == n.length ? null : function (e) { return kE(YE(e, n).map(qE)).pipe(X(WE)) } } function Dm(t) { return null != t ? KE(ZE(t)) : null } function QE(t, n) { return null === t ? [n] : Array.isArray(t) ? [...t, n] : [t, n] } function JE(t) { return t._rawValidators } function eS(t) { return t._rawAsyncValidators } function Em(t) { return t ? Array.isArray(t) ? t : [t] : [] } function xd(t, n) { return Array.isArray(t) ? t.includes(n) : t === n } function tS(t, n) { const e = Em(n); return Em(t).forEach(o => { xd(e, o) || e.push(o) }), e } function nS(t, n) { return Em(n).filter(e => !xd(t, e)) } class iS { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(n) { this._rawValidators = n || [], this._composedValidatorFn = Cm(this._rawValidators) } _setAsyncValidators(n) { this._rawAsyncValidators = n || [], this._composedAsyncValidatorFn = Dm(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(n) { this._onDestroyCallbacks.push(n) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(n => n()), this._onDestroyCallbacks = [] } reset(n = void 0) { this.control && this.control.reset(n) } hasError(n, e) { return !!this.control && this.control.hasError(n, e) } getError(n, e) { return this.control ? this.control.getError(n, e) : null } } class It extends iS { get formDirective() { return null } get path() { return null } } class ui extends iS { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class oS { constructor(n) { this._cd = n } get isTouched() { return !!this._cd?.control?.touched } get isUntouched() { return !!this._cd?.control?.untouched } get isPristine() { return !!this._cd?.control?.pristine } get isDirty() { return !!this._cd?.control?.dirty } get isValid() { return !!this._cd?.control?.valid } get isInvalid() { return !!this._cd?.control?.invalid } get isPending() { return !!this._cd?.control?.pending } get isSubmitted() { return !!this._cd?.submitted } } let La = (() => { class t extends oS { constructor(e) { super(e) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(ui, 2)) }; static #t = this.\u0275dir = P({ type: t, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (i, o) { 2 & i && Je("ng-untouched", o.isUntouched)("ng-touched", o.isTouched)("ng-pristine", o.isPristine)("ng-dirty", o.isDirty)("ng-valid", o.isValid)("ng-invalid", o.isInvalid)("ng-pending", o.isPending) }, features: [K] }) } return t })(), Sm = (() => { class t extends oS { constructor(e) { super(e) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(It, 10)) }; static #t = this.\u0275dir = P({ type: t, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 16, hostBindings: function (i, o) { 2 & i && Je("ng-untouched", o.isUntouched)("ng-touched", o.isTouched)("ng-pristine", o.isPristine)("ng-dirty", o.isDirty)("ng-valid", o.isValid)("ng-invalid", o.isInvalid)("ng-pending", o.isPending)("ng-submitted", o.isSubmitted) }, features: [K] }) } return t })(); const Va = "VALID", Dd = "INVALID", Zr = "PENDING", Ba = "DISABLED"; function Am(t) { return (Ed(t) ? t.validators : t) || null } function Tm(t, n) { return (Ed(n) ? n.asyncValidators : t) || null } function Ed(t) { return null != t && !Array.isArray(t) && "object" == typeof t } function sS(t, n, e) { const i = t.controls; if (!(n ? Object.keys(i) : i).length) throw new b(1e3, ""); if (!i[e]) throw new b(1001, "") } function aS(t, n, e) { t._forEachChild((i, o) => { if (void 0 === e[o]) throw new b(1002, "") }) } class Sd { constructor(n, e) { this._pendingDirty = !1, this._hasOwnPendingAsyncValidator = !1, this._pendingTouched = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._assignValidators(n), this._assignAsyncValidators(e) } get validator() { return this._composedValidatorFn } set validator(n) { this._rawValidators = this._composedValidatorFn = n } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(n) { this._rawAsyncValidators = this._composedAsyncValidatorFn = n } get parent() { return this._parent } get valid() { return this.status === Va } get invalid() { return this.status === Dd } get pending() { return this.status == Zr } get disabled() { return this.status === Ba } get enabled() { return this.status !== Ba } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(n) { this._assignValidators(n) } setAsyncValidators(n) { this._assignAsyncValidators(n) } addValidators(n) { this.setValidators(tS(n, this._rawValidators)) } addAsyncValidators(n) { this.setAsyncValidators(tS(n, this._rawAsyncValidators)) } removeValidators(n) { this.setValidators(nS(n, this._rawValidators)) } removeAsyncValidators(n) { this.setAsyncValidators(nS(n, this._rawAsyncValidators)) } hasValidator(n) { return xd(this._rawValidators, n) } hasAsyncValidator(n) { return xd(this._rawAsyncValidators, n) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(n = {}) { this.touched = !0, this._parent && !n.onlySelf && this._parent.markAsTouched(n) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(n => n.markAllAsTouched()) } markAsUntouched(n = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(e => { e.markAsUntouched({ onlySelf: !0 }) }), this._parent && !n.onlySelf && this._parent._updateTouched(n) } markAsDirty(n = {}) { this.pristine = !1, this._parent && !n.onlySelf && this._parent.markAsDirty(n) } markAsPristine(n = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(e => { e.markAsPristine({ onlySelf: !0 }) }), this._parent && !n.onlySelf && this._parent._updatePristine(n) } markAsPending(n = {}) { this.status = Zr, !1 !== n.emitEvent && this.statusChanges.emit(this.status), this._parent && !n.onlySelf && this._parent.markAsPending(n) } disable(n = {}) { const e = this._parentMarkedDirty(n.onlySelf); this.status = Ba, this.errors = null, this._forEachChild(i => { i.disable({ ...n, onlySelf: !0 }) }), this._updateValue(), !1 !== n.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors({ ...n, skipPristineCheck: e }), this._onDisabledChange.forEach(i => i(!0)) } enable(n = {}) { const e = this._parentMarkedDirty(n.onlySelf); this.status = Va, this._forEachChild(i => { i.enable({ ...n, onlySelf: !0 }) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: n.emitEvent }), this._updateAncestors({ ...n, skipPristineCheck: e }), this._onDisabledChange.forEach(i => i(!1)) } _updateAncestors(n) { this._parent && !n.onlySelf && (this._parent.updateValueAndValidity(n), n.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(n) { this._parent = n } getRawValue() { return this.value } updateValueAndValidity(n = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === Va || this.status === Zr) && this._runAsyncValidator(n.emitEvent)), !1 !== n.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !n.onlySelf && this._parent.updateValueAndValidity(n) } _updateTreeValidity(n = { emitEvent: !0 }) { this._forEachChild(e => e._updateTreeValidity(n)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: n.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? Ba : Va } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(n) { if (this.asyncValidator) { this.status = Zr, this._hasOwnPendingAsyncValidator = !0; const e = qE(this.asyncValidator(this)); this._asyncValidationSubscription = e.subscribe(i => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(i, { emitEvent: n }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(n, e = {}) { this.errors = n, this._updateControlsErrors(!1 !== e.emitEvent) } get(n) { let e = n; return null == e || (Array.isArray(e) || (e = e.split(".")), 0 === e.length) ? null : e.reduce((i, o) => i && i._find(o), this) } getError(n, e) { const i = e ? this.get(e) : this; return i && i.errors ? i.errors[n] : null } hasError(n, e) { return !!this.getError(n, e) } get root() { let n = this; for (; n._parent;)n = n._parent; return n } _updateControlsErrors(n) { this.status = this._calculateStatus(), n && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(n) } _initObservables() { this.valueChanges = new ue, this.statusChanges = new ue } _calculateStatus() { return this._allControlsDisabled() ? Ba : this.errors ? Dd : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(Zr) ? Zr : this._anyControlsHaveStatus(Dd) ? Dd : Va } _anyControlsHaveStatus(n) { return this._anyControls(e => e.status === n) } _anyControlsDirty() { return this._anyControls(n => n.dirty) } _anyControlsTouched() { return this._anyControls(n => n.touched) } _updatePristine(n = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !n.onlySelf && this._parent._updatePristine(n) } _updateTouched(n = {}) { this.touched = this._anyControlsTouched(), this._parent && !n.onlySelf && this._parent._updateTouched(n) } _registerOnCollectionChange(n) { this._onCollectionChange = n } _setUpdateStrategy(n) { Ed(n) && null != n.updateOn && (this._updateOn = n.updateOn) } _parentMarkedDirty(n) { return !n && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } _find(n) { return null } _assignValidators(n) { this._rawValidators = Array.isArray(n) ? n.slice() : n, this._composedValidatorFn = function p$(t) { return Array.isArray(t) ? Cm(t) : t || null }(this._rawValidators) } _assignAsyncValidators(n) { this._rawAsyncValidators = Array.isArray(n) ? n.slice() : n, this._composedAsyncValidatorFn = function m$(t) { return Array.isArray(t) ? Dm(t) : t || null }(this._rawAsyncValidators) } } class bo extends Sd { constructor(n, e, i) { super(Am(e), Tm(i, e)), this.controls = n, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(n, e) { return this.controls[n] ? this.controls[n] : (this.controls[n] = e, e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange), e) } addControl(n, e, i = {}) { this.registerControl(n, e), this.updateValueAndValidity({ emitEvent: i.emitEvent }), this._onCollectionChange() } removeControl(n, e = {}) { this.controls[n] && this.controls[n]._registerOnCollectionChange(() => { }), delete this.controls[n], this.updateValueAndValidity({ emitEvent: e.emitEvent }), this._onCollectionChange() } setControl(n, e, i = {}) { this.controls[n] && this.controls[n]._registerOnCollectionChange(() => { }), delete this.controls[n], e && this.registerControl(n, e), this.updateValueAndValidity({ emitEvent: i.emitEvent }), this._onCollectionChange() } contains(n) { return this.controls.hasOwnProperty(n) && this.controls[n].enabled } setValue(n, e = {}) { aS(this, 0, n), Object.keys(n).forEach(i => { sS(this, !0, i), this.controls[i].setValue(n[i], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(n, e = {}) { null != n && (Object.keys(n).forEach(i => { const o = this.controls[i]; o && o.patchValue(n[i], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e)) } reset(n = {}, e = {}) { this._forEachChild((i, o) => { i.reset(n ? n[o] : null, { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this._reduceChildren({}, (n, e, i) => (n[i] = e.getRawValue(), n)) } _syncPendingControls() { let n = this._reduceChildren(!1, (e, i) => !!i._syncPendingControls() || e); return n && this.updateValueAndValidity({ onlySelf: !0 }), n } _forEachChild(n) { Object.keys(this.controls).forEach(e => { const i = this.controls[e]; i && n(i, e) }) } _setUpControls() { this._forEachChild(n => { n.setParent(this), n._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(n) { for (const [e, i] of Object.entries(this.controls)) if (this.contains(e) && n(i)) return !0; return !1 } _reduceValue() { return this._reduceChildren({}, (e, i, o) => ((i.enabled || this.disabled) && (e[o] = i.value), e)) } _reduceChildren(n, e) { let i = n; return this._forEachChild((o, r) => { i = e(i, o, r) }), i } _allControlsDisabled() { for (const n of Object.keys(this.controls)) if (this.controls[n].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _find(n) { return this.controls.hasOwnProperty(n) ? this.controls[n] : null } } class lS extends bo { } const Xr = new E("CallSetDisabledState", { providedIn: "root", factory: () => Md }), Md = "always"; function ja(t, n, e = Md) { Rm(t, n), n.valueAccessor.writeValue(t.value), (t.disabled || "always" === e) && n.valueAccessor.setDisabledState?.(t.disabled), function _$(t, n) { n.valueAccessor.registerOnChange(e => { t._pendingValue = e, t._pendingChange = !0, t._pendingDirty = !0, "change" === t.updateOn && cS(t, n) }) }(t, n), function b$(t, n) { const e = (i, o) => { n.valueAccessor.writeValue(i), o && n.viewToModelUpdate(i) }; t.registerOnChange(e), n._registerOnDestroy(() => { t._unregisterOnChange(e) }) }(t, n), function v$(t, n) { n.valueAccessor.registerOnTouched(() => { t._pendingTouched = !0, "blur" === t.updateOn && t._pendingChange && cS(t, n), "submit" !== t.updateOn && t.markAsTouched() }) }(t, n), function g$(t, n) { if (n.valueAccessor.setDisabledState) { const e = i => { n.valueAccessor.setDisabledState(i) }; t.registerOnDisabledChange(e), n._registerOnDestroy(() => { t._unregisterOnDisabledChange(e) }) } }(t, n) } function Ad(t, n, e = !0) { const i = () => { }; n.valueAccessor && (n.valueAccessor.registerOnChange(i), n.valueAccessor.registerOnTouched(i)), Rd(t, n), t && (n._invokeOnDestroyCallbacks(), t._registerOnCollectionChange(() => { })) } function Td(t, n) { t.forEach(e => { e.registerOnValidatorChange && e.registerOnValidatorChange(n) }) } function Rm(t, n) { const e = JE(t); null !== n.validator ? t.setValidators(QE(e, n.validator)) : "function" == typeof e && t.setValidators([e]); const i = eS(t); null !== n.asyncValidator ? t.setAsyncValidators(QE(i, n.asyncValidator)) : "function" == typeof i && t.setAsyncValidators([i]); const o = () => t.updateValueAndValidity(); Td(n._rawValidators, o), Td(n._rawAsyncValidators, o) } function Rd(t, n) { let e = !1; if (null !== t) { if (null !== n.validator) { const o = JE(t); if (Array.isArray(o) && o.length > 0) { const r = o.filter(s => s !== n.validator); r.length !== o.length && (e = !0, t.setValidators(r)) } } if (null !== n.asyncValidator) { const o = eS(t); if (Array.isArray(o) && o.length > 0) { const r = o.filter(s => s !== n.asyncValidator); r.length !== o.length && (e = !0, t.setAsyncValidators(r)) } } } const i = () => { }; return Td(n._rawValidators, i), Td(n._rawAsyncValidators, i), e } function cS(t, n) { t._pendingDirty && t.markAsDirty(), t.setValue(t._pendingValue, { emitModelToViewChange: !1 }), n.viewToModelUpdate(t._pendingValue), t._pendingChange = !1 } function dS(t, n) { Rm(t, n) } function km(t, n) { if (!t.hasOwnProperty("model")) return !1; const e = t.model; return !!e.isFirstChange() || !Object.is(n, e.currentValue) } function uS(t, n) { t._syncPendingControls(), n.forEach(e => { const i = e.control; "submit" === i.updateOn && i._pendingChange && (e.viewToModelUpdate(i._pendingValue), i._pendingChange = !1) }) } function Fm(t, n) { if (!n) return null; let e, i, o; return Array.isArray(n), n.forEach(r => { r.constructor === vo ? e = r : function x$(t) { return Object.getPrototypeOf(t.constructor) === _o }(r) ? i = r : o = r }), o || i || e || null } const D$ = { provide: It, useExisting: be(() => Od) }, Ha = (() => Promise.resolve())(); let Od = (() => { class t extends It { constructor(e, i, o) { super(), this.callSetDisabledState = o, this.submitted = !1, this._directives = new Set, this.ngSubmit = new ue, this.form = new bo({}, Cm(e), Dm(i)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(e) { Ha.then(() => { const i = this._findContainer(e.path); e.control = i.registerControl(e.name, e.control), ja(e.control, e, this.callSetDisabledState), e.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.add(e) }) } getControl(e) { return this.form.get(e.path) } removeControl(e) { Ha.then(() => { const i = this._findContainer(e.path); i && i.removeControl(e.name), this._directives.delete(e) }) } addFormGroup(e) { Ha.then(() => { const i = this._findContainer(e.path), o = new bo({}); dS(o, e), i.registerControl(e.name, o), o.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(e) { Ha.then(() => { const i = this._findContainer(e.path); i && i.removeControl(e.name) }) } getFormGroup(e) { return this.form.get(e.path) } updateModel(e, i) { Ha.then(() => { this.form.get(e.path).setValue(i) }) } setValue(e) { this.control.setValue(e) } onSubmit(e) { return this.submitted = !0, uS(this.form, this._directives), this.ngSubmit.emit(e), "dialog" === e?.target?.method } onReset() { this.resetForm() } resetForm(e = void 0) { this.form.reset(e), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(e) { return e.pop(), e.length ? this.form.get(e) : this.form } static #e = this.\u0275fac = function (i) { return new (i || t)(g(gt, 10), g(Vi, 10), g(Xr, 8)) }; static #t = this.\u0275dir = P({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function (i, o) { 1 & i && se("submit", function (s) { return o.onSubmit(s) })("reset", function () { return o.onReset() }) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [ge([D$]), K] }) } return t })(); function hS(t, n) { const e = t.indexOf(n); e > -1 && t.splice(e, 1) } function fS(t) { return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t } const Ht = class extends Sd { constructor(n = null, e, i) { super(Am(e), Tm(i, e)), this.defaultValue = null, this._onChange = [], this._pendingChange = !1, this._applyFormState(n), this._setUpdateStrategy(e), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }), Ed(e) && (e.nonNullable || e.initialValueIsDefault) && (this.defaultValue = fS(n) ? n.value : n) } setValue(n, e = {}) { this.value = this._pendingValue = n, this._onChange.length && !1 !== e.emitModelToViewChange && this._onChange.forEach(i => i(this.value, !1 !== e.emitViewToModelChange)), this.updateValueAndValidity(e) } patchValue(n, e = {}) { this.setValue(n, e) } reset(n = this.defaultValue, e = {}) { this._applyFormState(n), this.markAsPristine(e), this.markAsUntouched(e), this.setValue(this.value, e), this._pendingChange = !1 } _updateValue() { } _anyControls(n) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(n) { this._onChange.push(n) } _unregisterOnChange(n) { hS(this._onChange, n) } registerOnDisabledChange(n) { this._onDisabledChange.push(n) } _unregisterOnDisabledChange(n) { hS(this._onDisabledChange, n) } _forEachChild(n) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(n) { fS(n) ? (this.value = this._pendingValue = n.value, n.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = n } }; let Pm = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275dir = P({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }) } return t })(), bS = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({}) } return t })(); const Nm = new E("NgModelWithFormControlWarning"), O$ = { provide: ui, useExisting: be(() => Ua) }; let Ua = (() => { class t extends ui { set isDisabled(e) { } static #e = this._ngModelWarningSentOnce = !1; constructor(e, i, o, r, s) { super(), this._ngModelWarningConfig = r, this.callSetDisabledState = s, this.update = new ue, this._ngModelWarningSent = !1, this._setValidators(e), this._setAsyncValidators(i), this.valueAccessor = Fm(0, o) } ngOnChanges(e) { if (this._isControlChanged(e)) { const i = e.form.previousValue; i && Ad(i, this, !1), ja(this.form, this, this.callSetDisabledState), this.form.updateValueAndValidity({ emitEvent: !1 }) } km(e, this.viewModel) && (this.form.setValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.form && Ad(this.form, this, !1) } get path() { return [] } get control() { return this.form } viewToModelUpdate(e) { this.viewModel = e, this.update.emit(e) } _isControlChanged(e) { return e.hasOwnProperty("form") } static #t = this.\u0275fac = function (i) { return new (i || t)(g(gt, 10), g(Vi, 10), g(mn, 10), g(Nm, 8), g(Xr, 8)) }; static #n = this.\u0275dir = P({ type: t, selectors: [["", "formControl", ""]], inputs: { form: ["formControl", "form"], isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngForm"], features: [ge([O$]), K, Ft] }) } return t })(); const k$ = { provide: It, useExisting: be(() => Kr) }; let Kr = (() => { class t extends It { constructor(e, i, o) { super(), this.callSetDisabledState = o, this.submitted = !1, this._onCollectionChange = () => this._updateDomValue(), this.directives = [], this.form = null, this.ngSubmit = new ue, this._setValidators(e), this._setAsyncValidators(i) } ngOnChanges(e) { this._checkFormPresent(), e.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form) } ngOnDestroy() { this.form && (Rd(this.form, this), this.form._onCollectionChange === this._onCollectionChange && this.form._registerOnCollectionChange(() => { })) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl(e) { const i = this.form.get(e.path); return ja(i, e, this.callSetDisabledState), i.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(e), i } getControl(e) { return this.form.get(e.path) } removeControl(e) { Ad(e.control || null, e, !1), function C$(t, n) { const e = t.indexOf(n); e > -1 && t.splice(e, 1) }(this.directives, e) } addFormGroup(e) { this._setUpFormContainer(e) } removeFormGroup(e) { this._cleanUpFormContainer(e) } getFormGroup(e) { return this.form.get(e.path) } addFormArray(e) { this._setUpFormContainer(e) } removeFormArray(e) { this._cleanUpFormContainer(e) } getFormArray(e) { return this.form.get(e.path) } updateModel(e, i) { this.form.get(e.path).setValue(i) } onSubmit(e) { return this.submitted = !0, uS(this.form, this.directives), this.ngSubmit.emit(e), "dialog" === e?.target?.method } onReset() { this.resetForm() } resetForm(e = void 0) { this.form.reset(e), this.submitted = !1 } _updateDomValue() { this.directives.forEach(e => { const i = e.control, o = this.form.get(e.path); i !== o && (Ad(i || null, e), (t => t instanceof Ht)(o) && (ja(o, e, this.callSetDisabledState), e.control = o)) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _setUpFormContainer(e) { const i = this.form.get(e.path); dS(i, e), i.updateValueAndValidity({ emitEvent: !1 }) } _cleanUpFormContainer(e) { if (this.form) { const i = this.form.get(e.path); i && function y$(t, n) { return Rd(t, n) }(i, e) && i.updateValueAndValidity({ emitEvent: !1 }) } } _updateRegistrations() { this.form._registerOnCollectionChange(this._onCollectionChange), this._oldForm && this._oldForm._registerOnCollectionChange(() => { }) } _updateValidators() { Rm(this.form, this), this._oldForm && Rd(this._oldForm, this) } _checkFormPresent() { } static #e = this.\u0275fac = function (i) { return new (i || t)(g(gt, 10), g(Vi, 10), g(Xr, 8)) }; static #t = this.\u0275dir = P({ type: t, selectors: [["", "formGroup", ""]], hostBindings: function (i, o) { 1 & i && se("submit", function (s) { return o.onSubmit(s) })("reset", function () { return o.onReset() }) }, inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [ge([k$]), K, Ft] }) } return t })(); const N$ = { provide: ui, useExisting: be(() => Bm) }; let Bm = (() => { class t extends ui { set isDisabled(e) { } static #e = this._ngModelWarningSentOnce = !1; constructor(e, i, o, r, s) { super(), this._ngModelWarningConfig = s, this._added = !1, this.name = null, this.update = new ue, this._ngModelWarningSent = !1, this._parent = e, this._setValidators(i), this._setAsyncValidators(o), this.valueAccessor = Fm(0, r) } ngOnChanges(e) { this._added || this._setUpControl(), km(e, this.viewModel) && (this.viewModel = this.model, this.formDirective.updateModel(this, this.model)) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } viewToModelUpdate(e) { this.viewModel = e, this.update.emit(e) } get path() { return function Id(t, n) { return [...n.path, t] }(null == this.name ? this.name : this.name.toString(), this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } _checkParentType() { } _setUpControl() { this._checkParentType(), this.control = this.formDirective.addControl(this), this._added = !0 } static #t = this.\u0275fac = function (i) { return new (i || t)(g(It, 13), g(gt, 10), g(Vi, 10), g(mn, 10), g(Nm, 8)) }; static #n = this.\u0275dir = P({ type: t, selectors: [["", "formControlName", ""]], inputs: { name: ["formControlName", "name"], isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, features: [ge([N$]), K, Ft] }) } return t })(), yo = (() => { class t { constructor() { this._validator = wd } ngOnChanges(e) { if (this.inputName in e) { const i = this.normalizeInput(e[this.inputName].currentValue); this._enabled = this.enabled(i), this._validator = this._enabled ? this.createValidator(i) : wd, this._onChange && this._onChange() } } validate(e) { return this._validator(e) } registerOnValidatorChange(e) { this._onChange = e } enabled(e) { return null != e } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275dir = P({ type: t, features: [Ft] }) } return t })(); const G$ = { provide: gt, useExisting: be(() => kd), multi: !0 }; let kd = (() => { class t extends yo { constructor() { super(...arguments), this.inputName = "required", this.normalizeInput = Sr, this.createValidator = e => BE } enabled(e) { return e } static #e = this.\u0275fac = function () { let e; return function (o) { return (e || (e = ze(t)))(o || t) } }(); static #t = this.\u0275dir = P({ type: t, selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]], hostVars: 1, hostBindings: function (i, o) { 2 & i && Ke("required", o._enabled ? "" : null) }, inputs: { required: "required" }, features: [ge([G$]), K] }) } return t })(), K$ = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ imports: [bS] }) } return t })(); class FS extends Sd { constructor(n, e, i) { super(Am(e), Tm(i, e)), this.controls = n, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } at(n) { return this.controls[this._adjustIndex(n)] } push(n, e = {}) { this.controls.push(n), this._registerControl(n), this.updateValueAndValidity({ emitEvent: e.emitEvent }), this._onCollectionChange() } insert(n, e, i = {}) { this.controls.splice(n, 0, e), this._registerControl(e), this.updateValueAndValidity({ emitEvent: i.emitEvent }) } removeAt(n, e = {}) { let i = this._adjustIndex(n); i < 0 && (i = 0), this.controls[i] && this.controls[i]._registerOnCollectionChange(() => { }), this.controls.splice(i, 1), this.updateValueAndValidity({ emitEvent: e.emitEvent }) } setControl(n, e, i = {}) { let o = this._adjustIndex(n); o < 0 && (o = 0), this.controls[o] && this.controls[o]._registerOnCollectionChange(() => { }), this.controls.splice(o, 1), e && (this.controls.splice(o, 0, e), this._registerControl(e)), this.updateValueAndValidity({ emitEvent: i.emitEvent }), this._onCollectionChange() } get length() { return this.controls.length } setValue(n, e = {}) { aS(this, 0, n), n.forEach((i, o) => { sS(this, !1, o), this.at(o).setValue(i, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(n, e = {}) { null != n && (n.forEach((i, o) => { this.at(o) && this.at(o).patchValue(i, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e)) } reset(n = [], e = {}) { this._forEachChild((i, o) => { i.reset(n[o], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this.controls.map(n => n.getRawValue()) } clear(n = {}) { this.controls.length < 1 || (this._forEachChild(e => e._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity({ emitEvent: n.emitEvent })) } _adjustIndex(n) { return n < 0 ? n + this.length : n } _syncPendingControls() { let n = this.controls.reduce((e, i) => !!i._syncPendingControls() || e, !1); return n && this.updateValueAndValidity({ onlySelf: !0 }), n } _forEachChild(n) { this.controls.forEach((e, i) => { n(e, i) }) } _updateValue() { this.value = this.controls.filter(n => n.enabled || this.disabled).map(n => n.value) } _anyControls(n) { return this.controls.some(e => e.enabled && n(e)) } _setUpControls() { this._forEachChild(n => this._registerControl(n)) } _allControlsDisabled() { for (const n of this.controls) if (n.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(n) { n.setParent(this), n._registerOnCollectionChange(this._onCollectionChange) } _find(n) { return this.at(n) ?? null } } function PS(t) { return !!t && (void 0 !== t.asyncValidators || void 0 !== t.validators || void 0 !== t.updateOn) } let Q$ = (() => { class t { constructor() { this.useNonNullable = !1 } get nonNullable() { const e = new t; return e.useNonNullable = !0, e } group(e, i = null) { const o = this._reduceControls(e); let r = {}; return PS(i) ? r = i : null !== i && (r.validators = i.validator, r.asyncValidators = i.asyncValidator), new bo(o, r) } record(e, i = null) { const o = this._reduceControls(e); return new lS(o, i) } control(e, i, o) { let r = {}; return this.useNonNullable ? (PS(i) ? r = i : (r.validators = i, r.asyncValidators = o), new Ht(e, { ...r, nonNullable: !0 })) : new Ht(e, i, o) } array(e, i, o) { const r = e.map(s => this._createControl(s)); return new FS(r, i, o) } _reduceControls(e) { const i = {}; return Object.keys(e).forEach(o => { i[o] = this._createControl(e[o]) }), i } _createControl(e) { return e instanceof Ht || e instanceof Sd ? e : Array.isArray(e) ? this.control(e[0], e.length > 1 ? e[1] : null, e.length > 2 ? e[2] : null) : this.control(e) } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), J$ = (() => { class t { static withConfig(e) { return { ngModule: t, providers: [{ provide: Nm, useValue: e.warnOnNgModelWithFormControl ?? "always" }, { provide: Xr, useValue: e.callSetDisabledState ?? Md }] } } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ imports: [K$] }) } return t })(); const e3 = ["*"]; let Fd; function za(t) { return function t3() { if (void 0 === Fd && (Fd = null, typeof window < "u")) { const t = window; void 0 !== t.trustedTypes && (Fd = t.trustedTypes.createPolicy("angular#components", { createHTML: n => n })) } return Fd }()?.createHTML(t) || t } function NS(t) { return Error(`Unable to find icon with the name "${t}"`) } function LS(t) { return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${t}".`) } function VS(t) { return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${t}".`) } class wo { constructor(n, e, i) { this.url = n, this.svgText = e, this.options = i } } let Pd = (() => { class t { constructor(e, i, o, r) { this._httpClient = e, this._sanitizer = i, this._errorHandler = r, this._svgIconConfigs = new Map, this._iconSetConfigs = new Map, this._cachedIconsByUrl = new Map, this._inProgressUrlFetches = new Map, this._fontCssClassesByAlias = new Map, this._resolvers = [], this._defaultFontSetClass = ["material-icons", "mat-ligature-font"], this._document = o } addSvgIcon(e, i, o) { return this.addSvgIconInNamespace("", e, i, o) } addSvgIconLiteral(e, i, o) { return this.addSvgIconLiteralInNamespace("", e, i, o) } addSvgIconInNamespace(e, i, o, r) { return this._addSvgIconConfig(e, i, new wo(o, null, r)) } addSvgIconResolver(e) { return this._resolvers.push(e), this } addSvgIconLiteralInNamespace(e, i, o, r) { const s = this._sanitizer.sanitize(st.HTML, o); if (!s) throw VS(o); const a = za(s); return this._addSvgIconConfig(e, i, new wo("", a, r)) } addSvgIconSet(e, i) { return this.addSvgIconSetInNamespace("", e, i) } addSvgIconSetLiteral(e, i) { return this.addSvgIconSetLiteralInNamespace("", e, i) } addSvgIconSetInNamespace(e, i, o) { return this._addSvgIconSetConfig(e, new wo(i, null, o)) } addSvgIconSetLiteralInNamespace(e, i, o) { const r = this._sanitizer.sanitize(st.HTML, i); if (!r) throw VS(i); const s = za(r); return this._addSvgIconSetConfig(e, new wo("", s, o)) } registerFontClassAlias(e, i = e) { return this._fontCssClassesByAlias.set(e, i), this } classNameForFontAlias(e) { return this._fontCssClassesByAlias.get(e) || e } setDefaultFontSetClass(...e) { return this._defaultFontSetClass = e, this } getDefaultFontSetClass() { return this._defaultFontSetClass } getSvgIconFromUrl(e) { const i = this._sanitizer.sanitize(st.RESOURCE_URL, e); if (!i) throw LS(e); const o = this._cachedIconsByUrl.get(i); return o ? N(Nd(o)) : this._loadSvgIconFromConfig(new wo(e, null)).pipe(Ue(r => this._cachedIconsByUrl.set(i, r)), X(r => Nd(r))) } getNamedSvgIcon(e, i = "") { const o = BS(i, e); let r = this._svgIconConfigs.get(o); if (r) return this._getSvgFromConfig(r); if (r = this._getIconConfigFromResolvers(i, e), r) return this._svgIconConfigs.set(o, r), this._getSvgFromConfig(r); const s = this._iconSetConfigs.get(i); return s ? this._getSvgFromIconSetConfigs(e, s) : kr(NS(o)) } ngOnDestroy() { this._resolvers = [], this._svgIconConfigs.clear(), this._iconSetConfigs.clear(), this._cachedIconsByUrl.clear() } _getSvgFromConfig(e) { return e.svgText ? N(Nd(this._svgElementFromConfig(e))) : this._loadSvgIconFromConfig(e).pipe(X(i => Nd(i))) } _getSvgFromIconSetConfigs(e, i) { const o = this._extractIconWithNameFromAnySet(e, i); return o ? N(o) : kE(i.filter(s => !s.svgText).map(s => this._loadSvgIconSetFromConfig(s).pipe(Oi(a => { const c = `Loading icon set URL: ${this._sanitizer.sanitize(st.RESOURCE_URL, s.url)} failed: ${a.message}`; return this._errorHandler.handleError(new Error(c)), N(null) })))).pipe(X(() => { const s = this._extractIconWithNameFromAnySet(e, i); if (!s) throw NS(e); return s })) } _extractIconWithNameFromAnySet(e, i) { for (let o = i.length - 1; o >= 0; o--) { const r = i[o]; if (r.svgText && r.svgText.toString().indexOf(e) > -1) { const s = this._svgElementFromConfig(r), a = this._extractSvgIconFromSet(s, e, r.options); if (a) return a } } return null } _loadSvgIconFromConfig(e) { return this._fetchIcon(e).pipe(Ue(i => e.svgText = i), X(() => this._svgElementFromConfig(e))) } _loadSvgIconSetFromConfig(e) { return e.svgText ? N(null) : this._fetchIcon(e).pipe(Ue(i => e.svgText = i)) } _extractSvgIconFromSet(e, i, o) { const r = e.querySelector(`[id="${i}"]`); if (!r) return null; const s = r.cloneNode(!0); if (s.removeAttribute("id"), "svg" === s.nodeName.toLowerCase()) return this._setSvgAttributes(s, o); if ("symbol" === s.nodeName.toLowerCase()) return this._setSvgAttributes(this._toSvgElement(s), o); const a = this._svgElementFromString(za("<svg></svg>")); return a.appendChild(s), this._setSvgAttributes(a, o) } _svgElementFromString(e) { const i = this._document.createElement("DIV"); i.innerHTML = e; const o = i.querySelector("svg"); if (!o) throw Error("<svg> tag not found"); return o } _toSvgElement(e) { const i = this._svgElementFromString(za("<svg></svg>")), o = e.attributes; for (let r = 0; r < o.length; r++) { const { name: s, value: a } = o[r]; "id" !== s && i.setAttribute(s, a) } for (let r = 0; r < e.childNodes.length; r++)e.childNodes[r].nodeType === this._document.ELEMENT_NODE && i.appendChild(e.childNodes[r].cloneNode(!0)); return i } _setSvgAttributes(e, i) { return e.setAttribute("fit", ""), e.setAttribute("height", "100%"), e.setAttribute("width", "100%"), e.setAttribute("preserveAspectRatio", "xMidYMid meet"), e.setAttribute("focusable", "false"), i && i.viewBox && e.setAttribute("viewBox", i.viewBox), e } _fetchIcon(e) { const { url: i, options: o } = e, r = o?.withCredentials ?? !1; if (!this._httpClient) throw function n3() { return Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.") }(); if (null == i) throw Error(`Cannot fetch icon from URL "${i}".`); const s = this._sanitizer.sanitize(st.RESOURCE_URL, i); if (!s) throw LS(i); const a = this._inProgressUrlFetches.get(s); if (a) return a; const l = this._httpClient.get(s, { responseType: "text", withCredentials: r }).pipe(X(c => za(c)), Pr(() => this._inProgressUrlFetches.delete(s)), ol()); return this._inProgressUrlFetches.set(s, l), l } _addSvgIconConfig(e, i, o) { return this._svgIconConfigs.set(BS(e, i), o), this } _addSvgIconSetConfig(e, i) { const o = this._iconSetConfigs.get(e); return o ? o.push(i) : this._iconSetConfigs.set(e, [i]), this } _svgElementFromConfig(e) { if (!e.svgElement) { const i = this._svgElementFromString(e.svgText); this._setSvgAttributes(i, e.options), e.svgElement = i } return e.svgElement } _getIconConfigFromResolvers(e, i) { for (let o = 0; o < this._resolvers.length; o++) { const r = this._resolvers[o](i, e); if (r) return r3(r) ? new wo(r.url, null, r.options) : new wo(r, null) } } static #e = this.\u0275fac = function (i) { return new (i || t)(w(Pa, 8), w(Pp), w(te, 8), w(sn)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); function Nd(t) { return t.cloneNode(!0) } function BS(t, n) { return t + ":" + n } function r3(t) { return !(!t.url || !t.options) } const s3 = Gj(class { constructor(t) { this._elementRef = t } }), a3 = new E("MAT_ICON_DEFAULT_OPTIONS"), l3 = new E("mat-icon-location", { providedIn: "root", factory: function c3() { const t = T(te), n = t ? t.location : null; return { getPathname: () => n ? n.pathname + n.search : "" } } }), jS = ["clip-path", "color-profile", "src", "cursor", "fill", "filter", "marker", "marker-start", "marker-mid", "marker-end", "mask", "stroke"], d3 = jS.map(t => `[${t}]`).join(", "), u3 = /^url\(['"]?#(.*?)['"]?\)$/; let Um = (() => { class t extends s3 { get inline() { return this._inline } set inline(e) { this._inline = lt(e) } get svgIcon() { return this._svgIcon } set svgIcon(e) { e !== this._svgIcon && (e ? this._updateSvgIcon(e) : this._svgIcon && this._clearSvgElement(), this._svgIcon = e) } get fontSet() { return this._fontSet } set fontSet(e) { const i = this._cleanupFontValue(e); i !== this._fontSet && (this._fontSet = i, this._updateFontIconClasses()) } get fontIcon() { return this._fontIcon } set fontIcon(e) { const i = this._cleanupFontValue(e); i !== this._fontIcon && (this._fontIcon = i, this._updateFontIconClasses()) } constructor(e, i, o, r, s, a) { super(e), this._iconRegistry = i, this._location = r, this._errorHandler = s, this._inline = !1, this._previousFontSetClass = [], this._currentIconFetch = Fe.EMPTY, a && (a.color && (this.color = this.defaultColor = a.color), a.fontSet && (this.fontSet = a.fontSet)), o || e.nativeElement.setAttribute("aria-hidden", "true") } _splitIconName(e) { if (!e) return ["", ""]; const i = e.split(":"); switch (i.length) { case 1: return ["", i[0]]; case 2: return i; default: throw Error(`Invalid icon name: "${e}"`) } } ngOnInit() { this._updateFontIconClasses() } ngAfterViewChecked() { const e = this._elementsWithExternalReferences; if (e && e.size) { const i = this._location.getPathname(); i !== this._previousPath && (this._previousPath = i, this._prependPathToReferences(i)) } } ngOnDestroy() { this._currentIconFetch.unsubscribe(), this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear() } _usingFontIcon() { return !this.svgIcon } _setSvgElement(e) { this._clearSvgElement(); const i = this._location.getPathname(); this._previousPath = i, this._cacheChildrenWithExternalReferences(e), this._prependPathToReferences(i), this._elementRef.nativeElement.appendChild(e) } _clearSvgElement() { const e = this._elementRef.nativeElement; let i = e.childNodes.length; for (this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear(); i--;) { const o = e.childNodes[i]; (1 !== o.nodeType || "svg" === o.nodeName.toLowerCase()) && o.remove() } } _updateFontIconClasses() { if (!this._usingFontIcon()) return; const e = this._elementRef.nativeElement, i = (this.fontSet ? this._iconRegistry.classNameForFontAlias(this.fontSet).split(/ +/) : this._iconRegistry.getDefaultFontSetClass()).filter(o => o.length > 0); this._previousFontSetClass.forEach(o => e.classList.remove(o)), i.forEach(o => e.classList.add(o)), this._previousFontSetClass = i, this.fontIcon !== this._previousFontIconClass && !i.includes("mat-ligature-font") && (this._previousFontIconClass && e.classList.remove(this._previousFontIconClass), this.fontIcon && e.classList.add(this.fontIcon), this._previousFontIconClass = this.fontIcon) } _cleanupFontValue(e) { return "string" == typeof e ? e.trim().split(" ")[0] : e } _prependPathToReferences(e) { const i = this._elementsWithExternalReferences; i && i.forEach((o, r) => { o.forEach(s => { r.setAttribute(s.name, `url('${e}#${s.value}')`) }) }) } _cacheChildrenWithExternalReferences(e) { const i = e.querySelectorAll(d3), o = this._elementsWithExternalReferences = this._elementsWithExternalReferences || new Map; for (let r = 0; r < i.length; r++)jS.forEach(s => { const a = i[r], l = a.getAttribute(s), c = l ? l.match(u3) : null; if (c) { let d = o.get(a); d || (d = [], o.set(a, d)), d.push({ name: s, value: c[1] }) } }) } _updateSvgIcon(e) { if (this._svgNamespace = null, this._svgName = null, this._currentIconFetch.unsubscribe(), e) { const [i, o] = this._splitIconName(e); i && (this._svgNamespace = i), o && (this._svgName = o), this._currentIconFetch = this._iconRegistry.getNamedSvgIcon(o, i).pipe(St(1)).subscribe(r => this._setSvgElement(r), r => { this._errorHandler.handleError(new Error(`Error retrieving icon ${i}:${o}! ${r.message}`)) }) } } static #e = this.\u0275fac = function (i) { return new (i || t)(g(ye), g(Pd), Uo("aria-hidden"), g(l3), g(sn), g(a3, 8)) }; static #t = this.\u0275cmp = tt({ type: t, selectors: [["mat-icon"]], hostAttrs: ["role", "img", 1, "mat-icon", "notranslate"], hostVars: 8, hostBindings: function (i, o) { 2 & i && (Ke("data-mat-icon-type", o._usingFontIcon() ? "font" : "svg")("data-mat-icon-name", o._svgName || o.fontIcon)("data-mat-icon-namespace", o._svgNamespace || o.fontSet)("fontIcon", o._usingFontIcon() ? o.fontIcon : null), Je("mat-icon-inline", o.inline)("mat-icon-no-color", "primary" !== o.color && "accent" !== o.color && "warn" !== o.color)) }, inputs: { color: "color", inline: "inline", svgIcon: "svgIcon", fontSet: "fontSet", fontIcon: "fontIcon" }, exportAs: ["matIcon"], features: [K], ngContentSelectors: e3, decls: 1, vars: 0, template: function (i, o) { 1 & i && (io(), mt(0)) }, styles: ["mat-icon,mat-icon.mat-primary,mat-icon.mat-accent,mat-icon.mat-warn{color:var(--mat-icon-color)}.mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}"], encapsulation: 2, changeDetection: 0 }) } return t })(), h3 = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ imports: [qe, qe] }) } return t })(); const HS = Rr({ passive: !0 }); let f3 = (() => { class t { constructor(e, i) { this._platform = e, this._ngZone = i, this._monitoredElements = new Map } monitor(e) { if (!this._platform.isBrowser) return vn; const i = Ri(e), o = this._monitoredElements.get(i); if (o) return o.subject; const r = new ie, s = "cdk-text-field-autofilled", a = l => { "cdk-text-field-autofill-start" !== l.animationName || i.classList.contains(s) ? "cdk-text-field-autofill-end" === l.animationName && i.classList.contains(s) && (i.classList.remove(s), this._ngZone.run(() => r.next({ target: l.target, isAutofilled: !1 }))) : (i.classList.add(s), this._ngZone.run(() => r.next({ target: l.target, isAutofilled: !0 }))) }; return this._ngZone.runOutsideAngular(() => { i.addEventListener("animationstart", a, HS), i.classList.add("cdk-text-field-autofill-monitored") }), this._monitoredElements.set(i, { subject: r, unlisten: () => { i.removeEventListener("animationstart", a, HS) } }), r } stopMonitoring(e) { const i = Ri(e), o = this._monitoredElements.get(i); o && (o.unlisten(), o.subject.complete(), i.classList.remove("cdk-text-field-autofill-monitored"), i.classList.remove("cdk-text-field-autofilled"), this._monitoredElements.delete(i)) } ngOnDestroy() { this._monitoredElements.forEach((e, i) => this.stopMonitoring(i)) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(Bt), w(z)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), p3 = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({}) } return t })(); class m3 extends ie { constructor(n = 1 / 0, e = 1 / 0, i = Hp) { super(), this._bufferSize = n, this._windowTime = e, this._timestampProvider = i, this._buffer = [], this._infiniteTimeWindow = !0, this._infiniteTimeWindow = e === 1 / 0, this._bufferSize = Math.max(1, n), this._windowTime = Math.max(1, e) } next(n) { const { isStopped: e, _buffer: i, _infiniteTimeWindow: o, _timestampProvider: r, _windowTime: s } = this; e || (i.push(n), !o && i.push(r.now() + s)), this._trimBuffer(), super.next(n) } _subscribe(n) { this._throwIfClosed(), this._trimBuffer(); const e = this._innerSubscribe(n), { _infiniteTimeWindow: i, _buffer: o } = this, r = o.slice(); for (let s = 0; s < r.length && !n.closed; s += i ? 1 : 2)n.next(r[s]); return this._checkFinalizedStatuses(n), e } _trimBuffer() { const { _bufferSize: n, _timestampProvider: e, _buffer: i, _infiniteTimeWindow: o } = this, r = (o ? 1 : 2) * n; if (n < 1 / 0 && r < i.length && i.splice(0, i.length - r), !o) { const s = e.now(); let a = 0; for (let l = 1; l < i.length && i[l] <= s; l += 2)a = l; a && i.splice(0, a + 1) } } } class _3 { constructor(n) { this._box = n, this._destroyed = new ie, this._resizeSubject = new ie, this._elementObservables = new Map, typeof ResizeObserver < "u" && (this._resizeObserver = new ResizeObserver(e => this._resizeSubject.next(e))) } observe(n) { return this._elementObservables.has(n) || this._elementObservables.set(n, new xe(e => { const i = this._resizeSubject.subscribe(e); return this._resizeObserver?.observe(n, { box: this._box }), () => { this._resizeObserver?.unobserve(n), i.unsubscribe(), this._elementObservables.delete(n) } }).pipe(at(e => e.some(i => i.target === n)), function g3(t, n, e) { let i, o = !1; return t && "object" == typeof t ? ({ bufferSize: i = 1 / 0, windowTime: n = 1 / 0, refCount: o = !1, scheduler: e } = t) : i = t ?? 1 / 0, ol({ connector: () => new m3(i, n, e), resetOnError: !0, resetOnComplete: !1, resetOnRefCountZero: o }) }({ bufferSize: 1, refCount: !0 }), Ti(this._destroyed))), this._elementObservables.get(n) } destroy() { this._destroyed.next(), this._destroyed.complete(), this._resizeSubject.complete(), this._elementObservables.clear() } } let v3 = (() => { class t { constructor() { this._observers = new Map, this._ngZone = T(z) } ngOnDestroy() { for (const [, e] of this._observers) e.destroy(); this._observers.clear() } observe(e, i) { const o = i?.box || "content-box"; return this._observers.has(o) || this._observers.set(o, new _3(o)), this._observers.get(o).observe(e) } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); class US { } class b3 { } const hi = "*"; function zm(t, n) { return { type: 7, name: t, definitions: n, options: {} } } function Qr(t, n = null) { return { type: 4, styles: n, timings: t } } function y3(t, n = null) { return { type: 3, steps: t, options: n } } function zS(t, n = null) { return { type: 2, steps: t, options: n } } function qn(t) { return { type: 6, styles: t, offset: null } } function Ld(t, n, e) { return { type: 0, name: t, styles: n, options: e } } function $a(t, n, e = null) { return { type: 1, expr: t, animation: n, options: e } } class Ga { constructor(n = 0, e = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._originalOnDoneFns = [], this._originalOnStartFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = n + e } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(n => n()), this._onDoneFns = []) } onStart(n) { this._originalOnStartFns.push(n), this._onStartFns.push(n) } onDone(n) { this._originalOnDoneFns.push(n), this._onDoneFns.push(n) } onDestroy(n) { this._onDestroyFns.push(n) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { queueMicrotask(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(n => n()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(n => n()), this._onDestroyFns = []) } reset() { this._started = !1, this._finished = !1, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns } setPosition(n) { this._position = this.totalTime ? n * this.totalTime : 1 } getPosition() { return this.totalTime ? this._position / this.totalTime : 1 } triggerCallback(n) { const e = "start" == n ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } } class $S { constructor(n) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = n; let e = 0, i = 0, o = 0; const r = this.players.length; 0 == r ? queueMicrotask(() => this._onFinish()) : this.players.forEach(s => { s.onDone(() => { ++e == r && this._onFinish() }), s.onDestroy(() => { ++i == r && this._onDestroy() }), s.onStart(() => { ++o == r && this._onStart() }) }), this.totalTime = this.players.reduce((s, a) => Math.max(s, a.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(n => n()), this._onDoneFns = []) } init() { this.players.forEach(n => n.init()) } onStart(n) { this._onStartFns.push(n) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(n => n()), this._onStartFns = []) } onDone(n) { this._onDoneFns.push(n) } onDestroy(n) { this._onDestroyFns.push(n) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(n => n.play()) } pause() { this.players.forEach(n => n.pause()) } restart() { this.players.forEach(n => n.restart()) } finish() { this._onFinish(), this.players.forEach(n => n.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(n => n.destroy()), this._onDestroyFns.forEach(n => n()), this._onDestroyFns = []) } reset() { this.players.forEach(n => n.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(n) { const e = n * this.totalTime; this.players.forEach(i => { const o = i.totalTime ? Math.min(1, e / i.totalTime) : 1; i.setPosition(o) }) } getPosition() { const n = this.players.reduce((e, i) => null === e || i.totalTime > e.totalTime ? i : e, null); return null != n ? n.getPosition() : 0 } beforeDestroy() { this.players.forEach(n => { n.beforeDestroy && n.beforeDestroy() }) } triggerCallback(n) { const e = "start" == n ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } } const w3 = ["notch"], x3 = ["matFormFieldNotchedOutline", ""], C3 = ["*"], D3 = ["textField"], E3 = ["iconPrefixContainer"], S3 = ["textPrefixContainer"]; function M3(t, n) { 1 & t && U(0, "span", 19) } function I3(t, n) { if (1 & t && (x(0, "label", 17), mt(1, 1), Q(2, M3, 1, 0, "span", 18), y()), 2 & t) { const e = Le(2); k("floating", e._shouldLabelFloat())("monitorResize", e._hasOutline())("id", e._labelId), Ke("for", e._control.id), S(2), k("ngIf", !e.hideRequiredMarker && e._control.required) } } function A3(t, n) { 1 & t && Q(0, I3, 3, 5, "label", 16), 2 & t && k("ngIf", Le()._hasFloatingLabel()) } function T3(t, n) { 1 & t && U(0, "div", 20) } function R3(t, n) { } function O3(t, n) { 1 & t && Q(0, R3, 0, 0, "ng-template", 22), 2 & t && (Le(2), k("ngTemplateOutlet", Ws(1))) } function k3(t, n) { if (1 & t && (x(0, "div", 21), Q(1, O3, 1, 1, "ng-template", 9), y()), 2 & t) { const e = Le(); k("matFormFieldNotchedOutlineOpen", e._shouldLabelFloat()), S(1), k("ngIf", !e._forceDisplayInfixLabel()) } } function F3(t, n) { 1 & t && (x(0, "div", 23, 24), mt(2, 2), y()) } function P3(t, n) { 1 & t && (x(0, "div", 25, 26), mt(2, 3), y()) } function N3(t, n) { } function L3(t, n) { 1 & t && Q(0, N3, 0, 0, "ng-template", 22), 2 & t && (Le(), k("ngTemplateOutlet", Ws(1))) } function V3(t, n) { 1 & t && (x(0, "div", 27), mt(1, 4), y()) } function B3(t, n) { 1 & t && (x(0, "div", 28), mt(1, 5), y()) } function j3(t, n) { 1 & t && U(0, "div", 29) } function H3(t, n) { 1 & t && (x(0, "div", 30), mt(1, 6), y()), 2 & t && k("@transitionMessages", Le()._subscriptAnimationState) } function U3(t, n) { if (1 & t && (x(0, "mat-hint", 34), A(1), y()), 2 & t) { const e = Le(2); k("id", e._hintLabelId), S(1), Zt(e.hintLabel) } } function z3(t, n) { if (1 & t && (x(0, "div", 31), Q(1, U3, 2, 2, "mat-hint", 32), mt(2, 7), U(3, "div", 33), mt(4, 8), y()), 2 & t) { const e = Le(); k("@transitionMessages", e._subscriptAnimationState), S(1), k("ngIf", e.hintLabel) } } const $3 = ["*", [["mat-label"]], [["", "matPrefix", ""], ["", "matIconPrefix", ""]], [["", "matTextPrefix", ""]], [["", "matTextSuffix", ""]], [["", "matSuffix", ""], ["", "matIconSuffix", ""]], [["mat-error"], ["", "matError", ""]], [["mat-hint", 3, "align", "end"]], [["mat-hint", "align", "end"]]], G3 = ["*", "mat-label", "[matPrefix], [matIconPrefix]", "[matTextPrefix]", "[matTextSuffix]", "[matSuffix], [matIconSuffix]", "mat-error, [matError]", "mat-hint:not([align='end'])", "mat-hint[align='end']"]; let Gm = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275dir = P({ type: t, selectors: [["mat-label"]] }) } return t })(); const q3 = new E("MatError"); let W3 = 0, GS = (() => { class t { constructor() { this.align = "start", this.id = "mat-mdc-hint-" + W3++ } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275dir = P({ type: t, selectors: [["mat-hint"]], hostAttrs: [1, "mat-mdc-form-field-hint", "mat-mdc-form-field-bottom-align"], hostVars: 4, hostBindings: function (i, o) { 2 & i && (Ks("id", o.id), Ke("align", null), Je("mat-mdc-form-field-hint-end", "end" === o.align)) }, inputs: { align: "align", id: "id" } }) } return t })(); const Y3 = new E("MatPrefix"), Z3 = new E("MatSuffix"), qS = new E("FloatingLabelParent"); let WS = (() => { class t { get floating() { return this._floating } set floating(e) { this._floating = e, this.monitorResize && this._handleResize() } get monitorResize() { return this._monitorResize } set monitorResize(e) { this._monitorResize = e, this._monitorResize ? this._subscribeToResize() : this._resizeSubscription.unsubscribe() } constructor(e) { this._elementRef = e, this._floating = !1, this._monitorResize = !1, this._resizeObserver = T(v3), this._ngZone = T(z), this._parent = T(qS), this._resizeSubscription = new Fe } ngOnDestroy() { this._resizeSubscription.unsubscribe() } getWidth() { return function X3(t) { if (null !== t.offsetParent) return t.scrollWidth; const e = t.cloneNode(!0); e.style.setProperty("position", "absolute"), e.style.setProperty("transform", "translate(-9999px, -9999px)"), document.documentElement.appendChild(e); const i = e.scrollWidth; return e.remove(), i }(this._elementRef.nativeElement) } get element() { return this._elementRef.nativeElement } _handleResize() { setTimeout(() => this._parent._handleLabelResized()) } _subscribeToResize() { this._resizeSubscription.unsubscribe(), this._ngZone.runOutsideAngular(() => { this._resizeSubscription = this._resizeObserver.observe(this._elementRef.nativeElement, { box: "border-box" }).subscribe(() => this._handleResize()) }) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(ye)) }; static #t = this.\u0275dir = P({ type: t, selectors: [["label", "matFormFieldFloatingLabel", ""]], hostAttrs: [1, "mdc-floating-label", "mat-mdc-floating-label"], hostVars: 2, hostBindings: function (i, o) { 2 & i && Je("mdc-floating-label--float-above", o.floating) }, inputs: { floating: "floating", monitorResize: "monitorResize" } }) } return t })(); const YS = "mdc-line-ripple--active", Vd = "mdc-line-ripple--deactivating"; let ZS = (() => { class t { constructor(e, i) { this._elementRef = e, this._handleTransitionEnd = o => { const r = this._elementRef.nativeElement.classList, s = r.contains(Vd); "opacity" === o.propertyName && s && r.remove(YS, Vd) }, i.runOutsideAngular(() => { e.nativeElement.addEventListener("transitionend", this._handleTransitionEnd) }) } activate() { const e = this._elementRef.nativeElement.classList; e.remove(Vd), e.add(YS) } deactivate() { this._elementRef.nativeElement.classList.add(Vd) } ngOnDestroy() { this._elementRef.nativeElement.removeEventListener("transitionend", this._handleTransitionEnd) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(ye), g(z)) }; static #t = this.\u0275dir = P({ type: t, selectors: [["div", "matFormFieldLineRipple", ""]], hostAttrs: [1, "mdc-line-ripple"] }) } return t })(), XS = (() => { class t { constructor(e, i) { this._elementRef = e, this._ngZone = i, this.open = !1 } ngAfterViewInit() { const e = this._elementRef.nativeElement.querySelector(".mdc-floating-label"); e ? (this._elementRef.nativeElement.classList.add("mdc-notched-outline--upgraded"), "function" == typeof requestAnimationFrame && (e.style.transitionDuration = "0s", this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => e.style.transitionDuration = "") }))) : this._elementRef.nativeElement.classList.add("mdc-notched-outline--no-label") } _setNotchWidth(e) { this._notch.nativeElement.style.width = this.open && e ? `calc(${e}px * var(--mat-mdc-form-field-floating-label-scale, 0.75) + 9px)` : "" } static #e = this.\u0275fac = function (i) { return new (i || t)(g(ye), g(z)) }; static #t = this.\u0275cmp = tt({ type: t, selectors: [["div", "matFormFieldNotchedOutline", ""]], viewQuery: function (i, o) { if (1 & i && dn(w3, 5), 2 & i) { let r; Re(r = Oe()) && (o._notch = r.first) } }, hostAttrs: [1, "mdc-notched-outline"], hostVars: 2, hostBindings: function (i, o) { 2 & i && Je("mdc-notched-outline--notched", o.open) }, inputs: { open: ["matFormFieldNotchedOutlineOpen", "open"] }, attrs: x3, ngContentSelectors: C3, decls: 5, vars: 0, consts: [[1, "mdc-notched-outline__leading"], [1, "mdc-notched-outline__notch"], ["notch", ""], [1, "mdc-notched-outline__trailing"]], template: function (i, o) { 1 & i && (io(), U(0, "div", 0), x(1, "div", 1, 2), mt(3), y(), U(4, "div", 3)) }, encapsulation: 2, changeDetection: 0 }) } return t })(); const K3 = { transitionMessages: zm("transitionMessages", [Ld("enter", qn({ opacity: 1, transform: "translateY(0%)" })), $a("void => enter", [qn({ opacity: 0, transform: "translateY(-5px)" }), Qr("300ms cubic-bezier(0.55, 0, 0.55, 0.2)")])]) }; let KS = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275dir = P({ type: t }) } return t })(); const qm = new E("MatFormField"), Q3 = new E("MAT_FORM_FIELD_DEFAULT_OPTIONS"); let QS = 0, tM = (() => { class t { get hideRequiredMarker() { return this._hideRequiredMarker } set hideRequiredMarker(e) { this._hideRequiredMarker = lt(e) } get floatLabel() { return this._floatLabel || this._defaults?.floatLabel || "auto" } set floatLabel(e) { e !== this._floatLabel && (this._floatLabel = e, this._changeDetectorRef.markForCheck()) } get appearance() { return this._appearance } set appearance(e) { const i = this._appearance; this._appearance = e || this._defaults?.appearance || "fill", "outline" === this._appearance && this._appearance !== i && (this._needsOutlineLabelOffsetUpdateOnStable = !0) } get subscriptSizing() { return this._subscriptSizing || this._defaults?.subscriptSizing || "fixed" } set subscriptSizing(e) { this._subscriptSizing = e || this._defaults?.subscriptSizing || "fixed" } get hintLabel() { return this._hintLabel } set hintLabel(e) { this._hintLabel = e, this._processHints() } get _control() { return this._explicitFormFieldControl || this._formFieldControl } set _control(e) { this._explicitFormFieldControl = e } constructor(e, i, o, r, s, a, l, c) { this._elementRef = e, this._changeDetectorRef = i, this._ngZone = o, this._dir = r, this._platform = s, this._defaults = a, this._animationMode = l, this._hideRequiredMarker = !1, this.color = "primary", this._appearance = "fill", this._subscriptSizing = null, this._hintLabel = "", this._hasIconPrefix = !1, this._hasTextPrefix = !1, this._hasIconSuffix = !1, this._hasTextSuffix = !1, this._labelId = "mat-mdc-form-field-label-" + QS++, this._hintLabelId = "mat-mdc-hint-" + QS++, this._subscriptAnimationState = "", this._destroyed = new ie, this._isFocused = null, this._needsOutlineLabelOffsetUpdateOnStable = !1, a && (a.appearance && (this.appearance = a.appearance), this._hideRequiredMarker = !!a?.hideRequiredMarker, a.color && (this.color = a.color)) } ngAfterViewInit() { this._updateFocusState(), this._subscriptAnimationState = "enter", this._changeDetectorRef.detectChanges() } ngAfterContentInit() { this._assertFormFieldControl(), this._initializeControl(), this._initializeSubscript(), this._initializePrefixAndSuffix(), this._initializeOutlineLabelOffsetSubscriptions() } ngAfterContentChecked() { this._assertFormFieldControl() } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete() } getLabelId() { return this._hasFloatingLabel() ? this._labelId : null } getConnectedOverlayOrigin() { return this._textField || this._elementRef } _animateAndLockLabel() { this._hasFloatingLabel() && (this.floatLabel = "always") } _initializeControl() { const e = this._control; e.controlType && this._elementRef.nativeElement.classList.add(`mat-mdc-form-field-type-${e.controlType}`), e.stateChanges.subscribe(() => { this._updateFocusState(), this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), e.ngControl && e.ngControl.valueChanges && e.ngControl.valueChanges.pipe(Ti(this._destroyed)).subscribe(() => this._changeDetectorRef.markForCheck()) } _checkPrefixAndSuffixTypes() { this._hasIconPrefix = !!this._prefixChildren.find(e => !e._isText), this._hasTextPrefix = !!this._prefixChildren.find(e => e._isText), this._hasIconSuffix = !!this._suffixChildren.find(e => !e._isText), this._hasTextSuffix = !!this._suffixChildren.find(e => e._isText) } _initializePrefixAndSuffix() { this._checkPrefixAndSuffixTypes(), $i(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => { this._checkPrefixAndSuffixTypes(), this._changeDetectorRef.markForCheck() }) } _initializeSubscript() { this._hintChildren.changes.subscribe(() => { this._processHints(), this._changeDetectorRef.markForCheck() }), this._errorChildren.changes.subscribe(() => { this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), this._validateHints(), this._syncDescribedByIds() } _assertFormFieldControl() { } _updateFocusState() { this._control.focused && !this._isFocused ? (this._isFocused = !0, this._lineRipple?.activate()) : !this._control.focused && (this._isFocused || null === this._isFocused) && (this._isFocused = !1, this._lineRipple?.deactivate()), this._textField?.nativeElement.classList.toggle("mdc-text-field--focused", this._control.focused) } _initializeOutlineLabelOffsetSubscriptions() { this._prefixChildren.changes.subscribe(() => this._needsOutlineLabelOffsetUpdateOnStable = !0), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.pipe(Ti(this._destroyed)).subscribe(() => { this._needsOutlineLabelOffsetUpdateOnStable && (this._needsOutlineLabelOffsetUpdateOnStable = !1, this._updateOutlineLabelOffset()) }) }), this._dir.change.pipe(Ti(this._destroyed)).subscribe(() => this._needsOutlineLabelOffsetUpdateOnStable = !0) } _shouldAlwaysFloat() { return "always" === this.floatLabel } _hasOutline() { return "outline" === this.appearance } _forceDisplayInfixLabel() { return !this._platform.isBrowser && this._prefixChildren.length && !this._shouldLabelFloat() } _hasFloatingLabel() { return !!this._labelChildNonStatic || !!this._labelChildStatic } _shouldLabelFloat() { return this._control.shouldLabelFloat || this._shouldAlwaysFloat() } _shouldForward(e) { const i = this._control ? this._control.ngControl : null; return i && i[e] } _getDisplayedMessages() { return this._errorChildren && this._errorChildren.length > 0 && this._control.errorState ? "error" : "hint" } _handleLabelResized() { this._refreshOutlineNotchWidth() } _refreshOutlineNotchWidth() { this._hasOutline() && this._floatingLabel && this._shouldLabelFloat() ? this._notchedOutline?._setNotchWidth(this._floatingLabel.getWidth()) : this._notchedOutline?._setNotchWidth(0) } _processHints() { this._validateHints(), this._syncDescribedByIds() } _validateHints() { } _syncDescribedByIds() { if (this._control) { let e = []; if (this._control.userAriaDescribedBy && "string" == typeof this._control.userAriaDescribedBy && e.push(...this._control.userAriaDescribedBy.split(" ")), "hint" === this._getDisplayedMessages()) { const i = this._hintChildren ? this._hintChildren.find(r => "start" === r.align) : null, o = this._hintChildren ? this._hintChildren.find(r => "end" === r.align) : null; i ? e.push(i.id) : this._hintLabel && e.push(this._hintLabelId), o && e.push(o.id) } else this._errorChildren && e.push(...this._errorChildren.map(i => i.id)); this._control.setDescribedByIds(e) } } _updateOutlineLabelOffset() { if (!this._platform.isBrowser || !this._hasOutline() || !this._floatingLabel) return; const e = this._floatingLabel.element; if (!this._iconPrefixContainer && !this._textPrefixContainer) return void (e.style.transform = ""); if (!this._isAttachedToDom()) return void (this._needsOutlineLabelOffsetUpdateOnStable = !0); const i = this._iconPrefixContainer?.nativeElement, o = this._textPrefixContainer?.nativeElement, r = i?.getBoundingClientRect().width ?? 0, s = o?.getBoundingClientRect().width ?? 0; e.style.transform = `var(\n        --mat-mdc-form-field-label-transform,\n        translateY(-50%) translateX(calc(${"rtl" === this._dir.value ? "-1" : "1"} * (${r + s}px + var(--mat-mdc-form-field-label-offset-x, 0px))))\n    )` } _isAttachedToDom() { const e = this._elementRef.nativeElement; if (e.getRootNode) { const i = e.getRootNode(); return i && i !== e } return document.documentElement.contains(e) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(ye), g(Un), g(z), g(Wp), g(Bt), g(Q3, 8), g(eo, 8), g(te)) }; static #t = this.\u0275cmp = tt({ type: t, selectors: [["mat-form-field"]], contentQueries: function (i, o, r) { if (1 & i && (un(r, Gm, 5), un(r, Gm, 7), un(r, KS, 5), un(r, Y3, 5), un(r, Z3, 5), un(r, q3, 5), un(r, GS, 5)), 2 & i) { let s; Re(s = Oe()) && (o._labelChildNonStatic = s.first), Re(s = Oe()) && (o._labelChildStatic = s.first), Re(s = Oe()) && (o._formFieldControl = s.first), Re(s = Oe()) && (o._prefixChildren = s), Re(s = Oe()) && (o._suffixChildren = s), Re(s = Oe()) && (o._errorChildren = s), Re(s = Oe()) && (o._hintChildren = s) } }, viewQuery: function (i, o) { if (1 & i && (dn(D3, 5), dn(E3, 5), dn(S3, 5), dn(WS, 5), dn(XS, 5), dn(ZS, 5)), 2 & i) { let r; Re(r = Oe()) && (o._textField = r.first), Re(r = Oe()) && (o._iconPrefixContainer = r.first), Re(r = Oe()) && (o._textPrefixContainer = r.first), Re(r = Oe()) && (o._floatingLabel = r.first), Re(r = Oe()) && (o._notchedOutline = r.first), Re(r = Oe()) && (o._lineRipple = r.first) } }, hostAttrs: [1, "mat-mdc-form-field"], hostVars: 42, hostBindings: function (i, o) { 2 & i && Je("mat-mdc-form-field-label-always-float", o._shouldAlwaysFloat())("mat-mdc-form-field-has-icon-prefix", o._hasIconPrefix)("mat-mdc-form-field-has-icon-suffix", o._hasIconSuffix)("mat-form-field-invalid", o._control.errorState)("mat-form-field-disabled", o._control.disabled)("mat-form-field-autofilled", o._control.autofilled)("mat-form-field-no-animations", "NoopAnimations" === o._animationMode)("mat-form-field-appearance-fill", "fill" == o.appearance)("mat-form-field-appearance-outline", "outline" == o.appearance)("mat-form-field-hide-placeholder", o._hasFloatingLabel() && !o._shouldLabelFloat())("mat-focused", o._control.focused)("mat-primary", "accent" !== o.color && "warn" !== o.color)("mat-accent", "accent" === o.color)("mat-warn", "warn" === o.color)("ng-untouched", o._shouldForward("untouched"))("ng-touched", o._shouldForward("touched"))("ng-pristine", o._shouldForward("pristine"))("ng-dirty", o._shouldForward("dirty"))("ng-valid", o._shouldForward("valid"))("ng-invalid", o._shouldForward("invalid"))("ng-pending", o._shouldForward("pending")) }, inputs: { hideRequiredMarker: "hideRequiredMarker", color: "color", floatLabel: "floatLabel", appearance: "appearance", subscriptSizing: "subscriptSizing", hintLabel: "hintLabel" }, exportAs: ["matFormField"], features: [ge([{ provide: qm, useExisting: t }, { provide: qS, useExisting: t }])], ngContentSelectors: G3, decls: 18, vars: 23, consts: [["labelTemplate", ""], [1, "mat-mdc-text-field-wrapper", "mdc-text-field", 3, "click"], ["textField", ""], ["class", "mat-mdc-form-field-focus-overlay", 4, "ngIf"], [1, "mat-mdc-form-field-flex"], ["matFormFieldNotchedOutline", "", 3, "matFormFieldNotchedOutlineOpen", 4, "ngIf"], ["class", "mat-mdc-form-field-icon-prefix", 4, "ngIf"], ["class", "mat-mdc-form-field-text-prefix", 4, "ngIf"], [1, "mat-mdc-form-field-infix"], [3, "ngIf"], ["class", "mat-mdc-form-field-text-suffix", 4, "ngIf"], ["class", "mat-mdc-form-field-icon-suffix", 4, "ngIf"], ["matFormFieldLineRipple", "", 4, "ngIf"], [1, "mat-mdc-form-field-subscript-wrapper", "mat-mdc-form-field-bottom-align", 3, "ngSwitch"], ["class", "mat-mdc-form-field-error-wrapper", 4, "ngSwitchCase"], ["class", "mat-mdc-form-field-hint-wrapper", 4, "ngSwitchCase"], ["matFormFieldFloatingLabel", "", 3, "floating", "monitorResize", "id", 4, "ngIf"], ["matFormFieldFloatingLabel", "", 3, "floating", "monitorResize", "id"], ["aria-hidden", "true", "class", "mat-mdc-form-field-required-marker mdc-floating-label--required", 4, "ngIf"], ["aria-hidden", "true", 1, "mat-mdc-form-field-required-marker", "mdc-floating-label--required"], [1, "mat-mdc-form-field-focus-overlay"], ["matFormFieldNotchedOutline", "", 3, "matFormFieldNotchedOutlineOpen"], [3, "ngTemplateOutlet"], [1, "mat-mdc-form-field-icon-prefix"], ["iconPrefixContainer", ""], [1, "mat-mdc-form-field-text-prefix"], ["textPrefixContainer", ""], [1, "mat-mdc-form-field-text-suffix"], [1, "mat-mdc-form-field-icon-suffix"], ["matFormFieldLineRipple", ""], [1, "mat-mdc-form-field-error-wrapper"], [1, "mat-mdc-form-field-hint-wrapper"], [3, "id", 4, "ngIf"], [1, "mat-mdc-form-field-hint-spacer"], [3, "id"]], template: function (i, o) { 1 & i && (io($3), Q(0, A3, 1, 1, "ng-template", null, 0, Fw), x(2, "div", 1, 2), se("click", function (s) { return o._control.onContainerClick(s) }), Q(4, T3, 1, 0, "div", 3), x(5, "div", 4), Q(6, k3, 2, 2, "div", 5), Q(7, F3, 3, 0, "div", 6), Q(8, P3, 3, 0, "div", 7), x(9, "div", 8), Q(10, L3, 1, 1, "ng-template", 9), mt(11), y(), Q(12, V3, 2, 0, "div", 10), Q(13, B3, 2, 0, "div", 11), y(), Q(14, j3, 1, 0, "div", 12), y(), x(15, "div", 13), Q(16, H3, 2, 1, "div", 14), Q(17, z3, 5, 2, "div", 15), y()), 2 & i && (S(2), Je("mdc-text-field--filled", !o._hasOutline())("mdc-text-field--outlined", o._hasOutline())("mdc-text-field--no-label", !o._hasFloatingLabel())("mdc-text-field--disabled", o._control.disabled)("mdc-text-field--invalid", o._control.errorState), S(2), k("ngIf", !o._hasOutline() && !o._control.disabled), S(2), k("ngIf", o._hasOutline()), S(1), k("ngIf", o._hasIconPrefix), S(1), k("ngIf", o._hasTextPrefix), S(2), k("ngIf", !o._hasOutline() || o._forceDisplayInfixLabel()), S(2), k("ngIf", o._hasTextSuffix), S(1), k("ngIf", o._hasIconSuffix), S(1), k("ngIf", !o._hasOutline()), S(1), Je("mat-mdc-form-field-subscript-dynamic-size", "dynamic" === o.subscriptSizing), k("ngSwitch", o._getDisplayedMessages()), S(1), k("ngSwitchCase", "error"), S(1), k("ngSwitchCase", "hint")) }, dependencies: [Ii, Jx, Uc, Kx, GS, WS, XS, ZS], styles: ['.mdc-text-field{border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:0;border-bottom-left-radius:0;display:inline-flex;align-items:baseline;padding:0 16px;position:relative;box-sizing:border-box;overflow:hidden;will-change:opacity,transform,color}.mdc-text-field .mdc-floating-label{top:50%;transform:translateY(-50%);pointer-events:none}.mdc-text-field__input{height:28px;width:100%;min-width:0;border:none;border-radius:0;background:none;appearance:none;padding:0}.mdc-text-field__input::-ms-clear{display:none}.mdc-text-field__input::-webkit-calendar-picker-indicator{display:none}.mdc-text-field__input:focus{outline:none}.mdc-text-field__input:invalid{box-shadow:none}@media all{.mdc-text-field__input::placeholder{opacity:0}}@media all{.mdc-text-field__input:-ms-input-placeholder{opacity:0}}@media all{.mdc-text-field--no-label .mdc-text-field__input::placeholder,.mdc-text-field--focused .mdc-text-field__input::placeholder{opacity:1}}@media all{.mdc-text-field--no-label .mdc-text-field__input:-ms-input-placeholder,.mdc-text-field--focused .mdc-text-field__input:-ms-input-placeholder{opacity:1}}.mdc-text-field__affix{height:28px;opacity:0;white-space:nowrap}.mdc-text-field--label-floating .mdc-text-field__affix,.mdc-text-field--no-label .mdc-text-field__affix{opacity:1}@supports(-webkit-hyphens: none){.mdc-text-field--outlined .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field__affix--prefix{padding-left:0;padding-right:2px}[dir=rtl] .mdc-text-field__affix--prefix,.mdc-text-field__affix--prefix[dir=rtl]{padding-left:2px;padding-right:0}.mdc-text-field--end-aligned .mdc-text-field__affix--prefix{padding-left:0;padding-right:12px}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__affix--prefix,.mdc-text-field--end-aligned .mdc-text-field__affix--prefix[dir=rtl]{padding-left:12px;padding-right:0}.mdc-text-field__affix--suffix{padding-left:12px;padding-right:0}[dir=rtl] .mdc-text-field__affix--suffix,.mdc-text-field__affix--suffix[dir=rtl]{padding-left:0;padding-right:12px}.mdc-text-field--end-aligned .mdc-text-field__affix--suffix{padding-left:2px;padding-right:0}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__affix--suffix,.mdc-text-field--end-aligned .mdc-text-field__affix--suffix[dir=rtl]{padding-left:0;padding-right:2px}.mdc-text-field--filled{height:56px}.mdc-text-field--filled::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}.mdc-text-field--filled .mdc-floating-label{left:16px;right:initial}[dir=rtl] .mdc-text-field--filled .mdc-floating-label,.mdc-text-field--filled .mdc-floating-label[dir=rtl]{left:initial;right:16px}.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{height:100%}.mdc-text-field--filled.mdc-text-field--no-label .mdc-floating-label{display:none}.mdc-text-field--filled.mdc-text-field--no-label::before{display:none}@supports(-webkit-hyphens: none){.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field--outlined{height:56px;overflow:visible}.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) scale(1)}.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) scale(0.75)}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--outlined .mdc-text-field__input{height:100%}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:4px;border-bottom-left-radius:var(--mdc-shape-small, 4px)}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading[dir=rtl]{border-top-left-radius:0;border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:4px;border-bottom-right-radius:var(--mdc-shape-small, 4px);border-bottom-left-radius:0}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{width:max(12px, var(--mdc-shape-small, 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__notch{max-width:calc(100% - max(12px, var(--mdc-shape-small, 4px))*2)}}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing{border-top-left-radius:0;border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:4px;border-bottom-right-radius:var(--mdc-shape-small, 4px);border-bottom-left-radius:0}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing[dir=rtl]{border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:4px;border-bottom-left-radius:var(--mdc-shape-small, 4px)}@supports(top: max(0%)){.mdc-text-field--outlined{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined{padding-right:max(16px, var(--mdc-shape-small, 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-right:max(16px, var(--mdc-shape-small, 4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-left:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-right:max(16px, var(--mdc-shape-small, 4px))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-right:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-left:max(16px, var(--mdc-shape-small, 4px))}}.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-right:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-left:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-right:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:1px}.mdc-text-field--outlined .mdc-floating-label{left:4px;right:initial}[dir=rtl] .mdc-text-field--outlined .mdc-floating-label,.mdc-text-field--outlined .mdc-floating-label[dir=rtl]{left:initial;right:4px}.mdc-text-field--outlined .mdc-text-field__input{display:flex;border:none !important;background-color:rgba(0,0,0,0)}.mdc-text-field--outlined .mdc-notched-outline{z-index:1}.mdc-text-field--textarea{flex-direction:column;align-items:center;width:auto;height:auto;padding:0}.mdc-text-field--textarea .mdc-floating-label{top:19px}.mdc-text-field--textarea .mdc-floating-label:not(.mdc-floating-label--float-above){transform:none}.mdc-text-field--textarea .mdc-text-field__input{flex-grow:1;height:auto;min-height:1.5rem;overflow-x:hidden;overflow-y:auto;box-sizing:border-box;resize:none;padding:0 16px}.mdc-text-field--textarea.mdc-text-field--filled::before{display:none}.mdc-text-field--textarea.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-10.25px) scale(0.75)}.mdc-text-field--textarea.mdc-text-field--filled .mdc-text-field__input{margin-top:23px;margin-bottom:9px}.mdc-text-field--textarea.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{margin-top:16px;margin-bottom:16px}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:0}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-27.25px) scale(1)}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--textarea.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-24.75px) scale(0.75)}.mdc-text-field--textarea.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-text-field__input{margin-top:16px;margin-bottom:16px}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label{top:18px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field__input{margin-bottom:2px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter{align-self:flex-end;padding:0 16px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter::after{display:inline-block;width:0;height:16px;content:"";vertical-align:-16px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter::before{display:none}.mdc-text-field__resizer{align-self:stretch;display:inline-flex;flex-direction:column;flex-grow:1;max-height:100%;max-width:100%;min-height:56px;min-width:fit-content;min-width:-moz-available;min-width:-webkit-fill-available;overflow:hidden;resize:both}.mdc-text-field--filled .mdc-text-field__resizer{transform:translateY(-1px)}.mdc-text-field--filled .mdc-text-field__resizer .mdc-text-field__input,.mdc-text-field--filled .mdc-text-field__resizer .mdc-text-field-character-counter{transform:translateY(1px)}.mdc-text-field--outlined .mdc-text-field__resizer{transform:translateX(-1px) translateY(-1px)}[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer,.mdc-text-field--outlined .mdc-text-field__resizer[dir=rtl]{transform:translateX(1px) translateY(-1px)}.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input,.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter{transform:translateX(1px) translateY(1px)}[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input,[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter,.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input[dir=rtl],.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter[dir=rtl]{transform:translateX(-1px) translateY(1px)}.mdc-text-field--with-leading-icon{padding-left:0;padding-right:16px}[dir=rtl] .mdc-text-field--with-leading-icon,.mdc-text-field--with-leading-icon[dir=rtl]{padding-left:16px;padding-right:0}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 48px);left:48px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label[dir=rtl]{left:initial;right:48px}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 64px / 0.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label{left:36px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label[dir=rtl]{left:initial;right:36px}.mdc-text-field--with-leading-icon.mdc-text-field--outlined :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) translateX(-32px) scale(1)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-37.25px) translateX(32px) scale(1)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) translateX(-32px) scale(0.75)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl],.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-34.75px) translateX(32px) scale(0.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--with-trailing-icon{padding-left:16px;padding-right:0}[dir=rtl] .mdc-text-field--with-trailing-icon,.mdc-text-field--with-trailing-icon[dir=rtl]{padding-left:0;padding-right:16px}.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 64px)}.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 64px / 0.75)}.mdc-text-field--with-trailing-icon.mdc-text-field--outlined :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 96px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 96px / 0.75)}.mdc-text-field-helper-line{display:flex;justify-content:space-between;box-sizing:border-box}.mdc-text-field+.mdc-text-field-helper-line{padding-right:16px;padding-left:16px}.mdc-form-field>.mdc-text-field+label{align-self:flex-start}.mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--focused .mdc-notched-outline__trailing{border-width:2px}.mdc-text-field--focused+.mdc-text-field-helper-line .mdc-text-field-helper-text:not(.mdc-text-field-helper-text--validation-msg){opacity:1}.mdc-text-field--focused.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:2px}.mdc-text-field--focused.mdc-text-field--outlined.mdc-text-field--textarea .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:0}.mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-helper-text--validation-msg{opacity:1}.mdc-text-field--disabled{pointer-events:none}@media screen and (forced-colors: active){.mdc-text-field--disabled .mdc-text-field__input{background-color:Window}.mdc-text-field--disabled .mdc-floating-label{z-index:1}}.mdc-text-field--disabled .mdc-floating-label{cursor:default}.mdc-text-field--disabled.mdc-text-field--filled .mdc-text-field__ripple{display:none}.mdc-text-field--disabled .mdc-text-field__input{pointer-events:auto}.mdc-text-field--end-aligned .mdc-text-field__input{text-align:right}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__input,.mdc-text-field--end-aligned .mdc-text-field__input[dir=rtl]{text-align:left}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__input,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__input,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix{direction:ltr}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--prefix{padding-left:0;padding-right:2px}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--suffix{padding-left:12px;padding-right:0}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__icon--leading,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__icon--leading{order:1}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--suffix{order:2}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__input,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__input{order:3}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--prefix{order:4}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__icon--trailing,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__icon--trailing{order:5}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__input,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__input{text-align:right}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__affix--prefix{padding-right:12px}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__affix--suffix{padding-left:2px}.mdc-floating-label{position:absolute;left:0;-webkit-transform-origin:left top;transform-origin:left top;line-height:1.15rem;text-align:left;text-overflow:ellipsis;white-space:nowrap;cursor:text;overflow:hidden;will-change:transform}[dir=rtl] .mdc-floating-label,.mdc-floating-label[dir=rtl]{right:0;left:auto;-webkit-transform-origin:right top;transform-origin:right top;text-align:right}.mdc-floating-label--float-above{cursor:auto}.mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)::after{margin-left:1px;margin-right:0px;content:"*"}[dir=rtl] .mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)::after,.mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)[dir=rtl]::after{margin-left:0;margin-right:1px}.mdc-notched-outline{display:flex;position:absolute;top:0;right:0;left:0;box-sizing:border-box;width:100%;max-width:100%;height:100%;text-align:left;pointer-events:none}[dir=rtl] .mdc-notched-outline,.mdc-notched-outline[dir=rtl]{text-align:right}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{box-sizing:border-box;height:100%;pointer-events:none}.mdc-notched-outline__trailing{flex-grow:1}.mdc-notched-outline__notch{flex:0 0 auto;width:auto}.mdc-notched-outline .mdc-floating-label{display:inline-block;position:relative;max-width:100%}.mdc-notched-outline .mdc-floating-label--float-above{text-overflow:clip}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:133.3333333333%}.mdc-notched-outline--notched .mdc-notched-outline__notch{padding-left:0;padding-right:8px;border-top:none}[dir=rtl] .mdc-notched-outline--notched .mdc-notched-outline__notch,.mdc-notched-outline--notched .mdc-notched-outline__notch[dir=rtl]{padding-left:8px;padding-right:0}.mdc-notched-outline--no-label .mdc-notched-outline__notch{display:none}.mdc-line-ripple::before,.mdc-line-ripple::after{position:absolute;bottom:0;left:0;width:100%;border-bottom-style:solid;content:""}.mdc-line-ripple::before{z-index:1}.mdc-line-ripple::after{transform:scaleX(0);opacity:0;z-index:2}.mdc-line-ripple--active::after{transform:scaleX(1);opacity:1}.mdc-line-ripple--deactivating::after{opacity:0}.mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{border-top:1px solid;border-bottom:1px solid}.mdc-notched-outline__leading{border-left:1px solid;border-right:none;width:12px}[dir=rtl] .mdc-notched-outline__leading,.mdc-notched-outline__leading[dir=rtl]{border-left:none;border-right:1px solid}.mdc-notched-outline__trailing{border-left:none;border-right:1px solid}[dir=rtl] .mdc-notched-outline__trailing,.mdc-notched-outline__trailing[dir=rtl]{border-left:1px solid;border-right:none}.mdc-notched-outline__notch{max-width:calc(100% - 12px * 2)}.mdc-line-ripple::before{border-bottom-width:1px}.mdc-line-ripple::after{border-bottom-width:2px}.mdc-text-field--filled{--mdc-filled-text-field-active-indicator-height:1px;--mdc-filled-text-field-focus-active-indicator-height:2px;--mdc-filled-text-field-container-shape:4px;border-top-left-radius:var(--mdc-filled-text-field-container-shape);border-top-right-radius:var(--mdc-filled-text-field-container-shape);border-bottom-right-radius:0;border-bottom-left-radius:0}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input{caret-color:var(--mdc-filled-text-field-caret-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__input{caret-color:var(--mdc-filled-text-field-error-caret-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input{color:var(--mdc-filled-text-field-input-text-color)}.mdc-text-field--filled.mdc-text-field--disabled .mdc-text-field__input{color:var(--mdc-filled-text-field-disabled-input-text-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-floating-label,.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-floating-label--float-above{color:var(--mdc-filled-text-field-label-text-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label,.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label--float-above{color:var(--mdc-filled-text-field-focus-label-text-color)}.mdc-text-field--filled.mdc-text-field--disabled .mdc-floating-label,.mdc-text-field--filled.mdc-text-field--disabled .mdc-floating-label--float-above{color:var(--mdc-filled-text-field-disabled-label-text-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-floating-label,.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-floating-label--float-above{color:var(--mdc-filled-text-field-error-label-text-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label,.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label--float-above{color:var(--mdc-filled-text-field-error-focus-label-text-color)}.mdc-text-field--filled .mdc-floating-label{font-family:var(--mdc-filled-text-field-label-text-font);font-size:var(--mdc-filled-text-field-label-text-size);font-weight:var(--mdc-filled-text-field-label-text-weight);letter-spacing:var(--mdc-filled-text-field-label-text-tracking)}@media all{.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input::placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color)}}@media all{.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input:-ms-input-placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color)}}.mdc-text-field--filled:not(.mdc-text-field--disabled){background-color:var(--mdc-filled-text-field-container-color)}.mdc-text-field--filled.mdc-text-field--disabled{background-color:var(--mdc-filled-text-field-disabled-container-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-active-indicator-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-hover-active-indicator-color)}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-line-ripple::after{border-bottom-color:var(--mdc-filled-text-field-focus-active-indicator-color)}.mdc-text-field--filled.mdc-text-field--disabled .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-disabled-active-indicator-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-error-active-indicator-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-error-hover-active-indicator-color)}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-line-ripple::after{border-bottom-color:var(--mdc-filled-text-field-error-focus-active-indicator-color)}.mdc-text-field--filled .mdc-line-ripple::before{border-bottom-width:var(--mdc-filled-text-field-active-indicator-height)}.mdc-text-field--filled .mdc-line-ripple::after{border-bottom-width:var(--mdc-filled-text-field-focus-active-indicator-height)}.mdc-text-field--outlined{--mdc-outlined-text-field-outline-width:1px;--mdc-outlined-text-field-focus-outline-width:2px;--mdc-outlined-text-field-container-shape:4px}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input{caret-color:var(--mdc-outlined-text-field-caret-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__input{caret-color:var(--mdc-outlined-text-field-error-caret-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input{color:var(--mdc-outlined-text-field-input-text-color)}.mdc-text-field--outlined.mdc-text-field--disabled .mdc-text-field__input{color:var(--mdc-outlined-text-field-disabled-input-text-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-floating-label,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-floating-label--float-above{color:var(--mdc-outlined-text-field-label-text-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label--float-above{color:var(--mdc-outlined-text-field-focus-label-text-color)}.mdc-text-field--outlined.mdc-text-field--disabled .mdc-floating-label,.mdc-text-field--outlined.mdc-text-field--disabled .mdc-floating-label--float-above{color:var(--mdc-outlined-text-field-disabled-label-text-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-floating-label,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-floating-label--float-above{color:var(--mdc-outlined-text-field-error-label-text-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label--float-above{color:var(--mdc-outlined-text-field-error-focus-label-text-color)}.mdc-text-field--outlined .mdc-floating-label{font-family:var(--mdc-outlined-text-field-label-text-font);font-size:var(--mdc-outlined-text-field-label-text-size);font-weight:var(--mdc-outlined-text-field-label-text-weight);letter-spacing:var(--mdc-outlined-text-field-label-text-tracking)}@media all{.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input::placeholder{color:var(--mdc-outlined-text-field-input-text-placeholder-color)}}@media all{.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input:-ms-input-placeholder{color:var(--mdc-outlined-text-field-input-text-placeholder-color)}}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{border-top-left-radius:var(--mdc-outlined-text-field-container-shape);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:var(--mdc-outlined-text-field-container-shape)}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading[dir=rtl]{border-top-left-radius:0;border-top-right-radius:var(--mdc-outlined-text-field-container-shape);border-bottom-right-radius:var(--mdc-outlined-text-field-container-shape);border-bottom-left-radius:0}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{width:max(12px, var(--mdc-outlined-text-field-container-shape))}}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__notch{max-width:calc(100% - max(12px, var(--mdc-outlined-text-field-container-shape))*2)}}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing{border-top-left-radius:0;border-top-right-radius:var(--mdc-outlined-text-field-container-shape);border-bottom-right-radius:var(--mdc-outlined-text-field-container-shape);border-bottom-left-radius:0}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing[dir=rtl]{border-top-left-radius:var(--mdc-outlined-text-field-container-shape);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:var(--mdc-outlined-text-field-container-shape)}@supports(top: max(0%)){.mdc-text-field--outlined{padding-left:max(16px, calc(var(--mdc-outlined-text-field-container-shape) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined{padding-right:max(16px, var(--mdc-outlined-text-field-container-shape))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-left:max(16px, calc(var(--mdc-outlined-text-field-container-shape) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-right:max(16px, var(--mdc-outlined-text-field-container-shape))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-left:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-right:max(16px, var(--mdc-outlined-text-field-container-shape))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-right:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-left:max(16px, var(--mdc-outlined-text-field-container-shape))}}.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-right:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-left:max(16px, calc(var(--mdc-outlined-text-field-container-shape) + 4px))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-left:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-right:max(16px, calc(var(--mdc-outlined-text-field-container-shape) + 4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-outline-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-hover-outline-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-focus-outline-color)}.mdc-text-field--outlined.mdc-text-field--disabled .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--disabled .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--disabled .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-disabled-outline-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-error-outline-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-error-hover-outline-color)}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:var(--mdc-outlined-text-field-error-focus-outline-color)}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline .mdc-notched-outline__trailing{border-width:var(--mdc-outlined-text-field-outline-width)}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline .mdc-notched-outline__trailing{border-width:var(--mdc-outlined-text-field-focus-outline-width)}.mat-mdc-form-field-textarea-control{vertical-align:middle;resize:vertical;box-sizing:border-box;height:auto;margin:0;padding:0;border:none;overflow:auto}.mat-mdc-form-field-input-control.mat-mdc-form-field-input-control{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font:inherit;letter-spacing:inherit;text-decoration:inherit;text-transform:inherit;border:none}.mat-mdc-form-field .mat-mdc-floating-label.mdc-floating-label{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;line-height:normal;pointer-events:all}.mat-mdc-form-field:not(.mat-form-field-disabled) .mat-mdc-floating-label.mdc-floating-label{cursor:inherit}.mdc-text-field--no-label:not(.mdc-text-field--textarea) .mat-mdc-form-field-input-control.mdc-text-field__input,.mat-mdc-text-field-wrapper .mat-mdc-form-field-input-control{height:auto}.mat-mdc-text-field-wrapper .mat-mdc-form-field-input-control.mdc-text-field__input[type=color]{height:23px}.mat-mdc-text-field-wrapper{height:auto;flex:auto}.mat-mdc-form-field-has-icon-prefix .mat-mdc-text-field-wrapper{padding-left:0;--mat-mdc-form-field-label-offset-x: -16px}.mat-mdc-form-field-has-icon-suffix .mat-mdc-text-field-wrapper{padding-right:0}[dir=rtl] .mat-mdc-text-field-wrapper{padding-left:16px;padding-right:16px}[dir=rtl] .mat-mdc-form-field-has-icon-suffix .mat-mdc-text-field-wrapper{padding-left:0}[dir=rtl] .mat-mdc-form-field-has-icon-prefix .mat-mdc-text-field-wrapper{padding-right:0}.mat-form-field-disabled .mdc-text-field__input::placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color)}.mat-form-field-disabled .mdc-text-field__input::-moz-placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color)}.mat-form-field-disabled .mdc-text-field__input::-webkit-input-placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color)}.mat-form-field-disabled .mdc-text-field__input:-ms-input-placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color)}.mat-mdc-form-field-label-always-float .mdc-text-field__input::placeholder{transition-delay:40ms;transition-duration:110ms;opacity:1}.mat-mdc-text-field-wrapper .mat-mdc-form-field-infix .mat-mdc-floating-label{left:auto;right:auto}.mat-mdc-text-field-wrapper.mdc-text-field--outlined .mdc-text-field__input{display:inline-block}.mat-mdc-form-field .mat-mdc-text-field-wrapper.mdc-text-field .mdc-notched-outline__notch{padding-top:0}.mat-mdc-text-field-wrapper::before{content:none}.mat-mdc-form-field-subscript-wrapper{box-sizing:border-box;width:100%;position:relative}.mat-mdc-form-field-hint-wrapper,.mat-mdc-form-field-error-wrapper{position:absolute;top:0;left:0;right:0;padding:0 16px}.mat-mdc-form-field-subscript-dynamic-size .mat-mdc-form-field-hint-wrapper,.mat-mdc-form-field-subscript-dynamic-size .mat-mdc-form-field-error-wrapper{position:static}.mat-mdc-form-field-bottom-align::before{content:"";display:inline-block;height:16px}.mat-mdc-form-field-bottom-align.mat-mdc-form-field-subscript-dynamic-size::before{content:unset}.mat-mdc-form-field-hint-end{order:1}.mat-mdc-form-field-hint-wrapper{display:flex}.mat-mdc-form-field-hint-spacer{flex:1 0 1em}.mat-mdc-form-field-error{display:block}.mat-mdc-form-field-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;opacity:0;pointer-events:none}select.mat-mdc-form-field-input-control{-moz-appearance:none;-webkit-appearance:none;background-color:rgba(0,0,0,0);display:inline-flex;box-sizing:border-box}select.mat-mdc-form-field-input-control:not(:disabled){cursor:pointer}.mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-infix::after{content:"";width:0;height:0;border-left:5px solid rgba(0,0,0,0);border-right:5px solid rgba(0,0,0,0);border-top:5px solid;position:absolute;right:0;top:50%;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-infix::after{right:auto;left:0}.mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-input-control{padding-right:15px}[dir=rtl] .mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-input-control{padding-right:0;padding-left:15px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-mdc-text-field-wrapper{outline:solid 1px}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-form-field-disabled .mat-mdc-text-field-wrapper{outline-color:GrayText}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-focused .mat-mdc-text-field-wrapper{outline:dashed 3px}.cdk-high-contrast-active .mat-mdc-form-field.mat-focused .mdc-notched-outline{border:dashed 3px}.mat-mdc-form-field-input-control[type=date],.mat-mdc-form-field-input-control[type=datetime],.mat-mdc-form-field-input-control[type=datetime-local],.mat-mdc-form-field-input-control[type=month],.mat-mdc-form-field-input-control[type=week],.mat-mdc-form-field-input-control[type=time]{line-height:1}.mat-mdc-form-field-input-control::-webkit-datetime-edit{line-height:1;padding:0;margin-bottom:-2px}.mat-mdc-form-field{--mat-mdc-form-field-floating-label-scale: 0.75;display:inline-flex;flex-direction:column;min-width:0;text-align:left;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--mat-form-field-container-text-font);line-height:var(--mat-form-field-container-text-line-height);font-size:var(--mat-form-field-container-text-size);letter-spacing:var(--mat-form-field-container-text-tracking);font-weight:var(--mat-form-field-container-text-weight)}[dir=rtl] .mat-mdc-form-field{text-align:right}.mat-mdc-form-field .mdc-text-field--outlined .mdc-floating-label--float-above{font-size:calc(var(--mat-form-field-outlined-label-text-populated-size) * var(--mat-mdc-form-field-floating-label-scale))}.mat-mdc-form-field .mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:var(--mat-form-field-outlined-label-text-populated-size)}.mat-mdc-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-mdc-text-field-wrapper{width:100%}.mat-mdc-form-field-icon-prefix,.mat-mdc-form-field-icon-suffix{align-self:center;line-height:0;pointer-events:auto;position:relative;z-index:1}.mat-mdc-form-field-icon-prefix,[dir=rtl] .mat-mdc-form-field-icon-suffix{padding:0 4px 0 0}.mat-mdc-form-field-icon-suffix,[dir=rtl] .mat-mdc-form-field-icon-prefix{padding:0 0 0 4px}.mat-mdc-form-field-icon-prefix>.mat-icon,.mat-mdc-form-field-icon-suffix>.mat-icon{padding:12px;box-sizing:content-box}.mat-mdc-form-field-subscript-wrapper .mat-icon,.mat-mdc-form-field label .mat-icon{width:1em;height:1em;font-size:inherit}.mat-mdc-form-field-infix{flex:auto;min-width:0;width:180px;position:relative;box-sizing:border-box}.mat-mdc-form-field .mdc-notched-outline__notch{margin-left:-1px;-webkit-clip-path:inset(-9em -999em -9em 1px);clip-path:inset(-9em -999em -9em 1px)}[dir=rtl] .mat-mdc-form-field .mdc-notched-outline__notch{margin-left:0;margin-right:-1px;-webkit-clip-path:inset(-9em 1px -9em -999em);clip-path:inset(-9em 1px -9em -999em)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input{transition:opacity 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}@media all{.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::placeholder{transition:opacity 67ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}}@media all{.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input:-ms-input-placeholder{transition:opacity 67ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}}@media all{.mdc-text-field--no-label .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::placeholder,.mdc-text-field--focused .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::placeholder{transition-delay:40ms;transition-duration:110ms}}@media all{.mdc-text-field--no-label .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input:-ms-input-placeholder,.mdc-text-field--focused .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input:-ms-input-placeholder{transition-delay:40ms;transition-duration:110ms}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__affix{transition:opacity 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--filled.mdc-ripple-upgraded--background-focused .mdc-text-field__ripple::before,.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--filled:not(.mdc-ripple-upgraded):focus .mdc-text-field__ripple::before{transition-duration:75ms}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--textarea{transition:none}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--textarea.mdc-text-field--filled .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea-filled 250ms 1}@keyframes mdc-floating-label-shake-float-above-textarea-filled{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea-outlined 250ms 1}@keyframes mdc-floating-label-shake-float-above-textarea-outlined{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon{0%{transform:translateX(calc(0% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}100%{transform:translateX(calc(0% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}}[dir=rtl] .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake,.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--with-leading-icon.mdc-text-field--outlined[dir=rtl] .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-rtl{0%{transform:translateX(calc(0% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}100%{transform:translateX(calc(0% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-floating-label{transition:transform 150ms cubic-bezier(0.4, 0, 0.2, 1),color 150ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-standard 250ms 1}@keyframes mdc-floating-label-shake-float-above-standard{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-line-ripple::after{transition:transform 180ms cubic-bezier(0.4, 0, 0.2, 1),opacity 180ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-notched-outline .mdc-floating-label{max-width:calc(100% + 1px)}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:calc(133.3333333333% + 1px)}'], encapsulation: 2, data: { animation: [K3.transitionMessages] }, changeDetection: 0 }) } return t })(), nM = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ imports: [qe, Ar, PC, qe] }) } return t })(); const t4 = new E("MAT_INPUT_VALUE_ACCESSOR"), n4 = ["button", "checkbox", "file", "hidden", "image", "radio", "range", "reset", "submit"]; let o4 = 0; const r4 = Wj(class { constructor(t, n, e, i) { this._defaultErrorStateMatcher = t, this._parentForm = n, this._parentFormGroup = e, this.ngControl = i, this.stateChanges = new ie } }); let iM = (() => { class t extends r4 { get disabled() { return this._disabled } set disabled(e) { this._disabled = lt(e), this.focused && (this.focused = !1, this.stateChanges.next()) } get id() { return this._id } set id(e) { this._id = e || this._uid } get required() { return this._required ?? this.ngControl?.control?.hasValidator(jt.required) ?? !1 } set required(e) { this._required = lt(e) } get type() { return this._type } set type(e) { this._type = e || "text", this._validateType(), !this._isTextarea && MC().has(this._type) && (this._elementRef.nativeElement.type = this._type) } get value() { return this._inputValueAccessor.value } set value(e) { e !== this.value && (this._inputValueAccessor.value = e, this.stateChanges.next()) } get readonly() { return this._readonly } set readonly(e) { this._readonly = lt(e) } constructor(e, i, o, r, s, a, l, c, d, u) { super(a, r, s, o), this._elementRef = e, this._platform = i, this._autofillMonitor = c, this._formField = u, this._uid = "mat-input-" + o4++, this.focused = !1, this.stateChanges = new ie, this.controlType = "mat-input", this.autofilled = !1, this._disabled = !1, this._type = "text", this._readonly = !1, this._neverEmptyInputTypes = ["date", "datetime", "datetime-local", "month", "time", "week"].filter(p => MC().has(p)), this._iOSKeyupListener = p => { const m = p.target; !m.value && 0 === m.selectionStart && 0 === m.selectionEnd && (m.setSelectionRange(1, 1), m.setSelectionRange(0, 0)) }; const h = this._elementRef.nativeElement, f = h.nodeName.toLowerCase(); this._inputValueAccessor = l || h, this._previousNativeValue = this.value, this.id = this.id, i.IOS && d.runOutsideAngular(() => { e.nativeElement.addEventListener("keyup", this._iOSKeyupListener) }), this._isServer = !this._platform.isBrowser, this._isNativeSelect = "select" === f, this._isTextarea = "textarea" === f, this._isInFormField = !!u, this._isNativeSelect && (this.controlType = h.multiple ? "mat-native-select-multiple" : "mat-native-select") } ngAfterViewInit() { this._platform.isBrowser && this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(e => { this.autofilled = e.isAutofilled, this.stateChanges.next() }) } ngOnChanges() { this.stateChanges.next() } ngOnDestroy() { this.stateChanges.complete(), this._platform.isBrowser && this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement), this._platform.IOS && this._elementRef.nativeElement.removeEventListener("keyup", this._iOSKeyupListener) } ngDoCheck() { this.ngControl && (this.updateErrorState(), null !== this.ngControl.disabled && this.ngControl.disabled !== this.disabled && (this.disabled = this.ngControl.disabled, this.stateChanges.next())), this._dirtyCheckNativeValue(), this._dirtyCheckPlaceholder() } focus(e) { this._elementRef.nativeElement.focus(e) } _focusChanged(e) { e !== this.focused && (this.focused = e, this.stateChanges.next()) } _onInput() { } _dirtyCheckNativeValue() { const e = this._elementRef.nativeElement.value; this._previousNativeValue !== e && (this._previousNativeValue = e, this.stateChanges.next()) } _dirtyCheckPlaceholder() { const e = this._getPlaceholder(); if (e !== this._previousPlaceholder) { const i = this._elementRef.nativeElement; this._previousPlaceholder = e, e ? i.setAttribute("placeholder", e) : i.removeAttribute("placeholder") } } _getPlaceholder() { return this.placeholder || null } _validateType() { n4.indexOf(this._type) } _isNeverEmpty() { return this._neverEmptyInputTypes.indexOf(this._type) > -1 } _isBadInput() { let e = this._elementRef.nativeElement.validity; return e && e.badInput } get empty() { return !(this._isNeverEmpty() || this._elementRef.nativeElement.value || this._isBadInput() || this.autofilled) } get shouldLabelFloat() { if (this._isNativeSelect) { const e = this._elementRef.nativeElement, i = e.options[0]; return this.focused || e.multiple || !this.empty || !!(e.selectedIndex > -1 && i && i.label) } return this.focused || !this.empty } setDescribedByIds(e) { e.length ? this._elementRef.nativeElement.setAttribute("aria-describedby", e.join(" ")) : this._elementRef.nativeElement.removeAttribute("aria-describedby") } onContainerClick() { this.focused || this.focus() } _isInlineSelect() { const e = this._elementRef.nativeElement; return this._isNativeSelect && (e.multiple || e.size > 1) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(ye), g(Bt), g(ui, 10), g(Od, 8), g(Kr, 8), g(Zj), g(t4, 10), g(f3), g(z), g(qm, 8)) }; static #t = this.\u0275dir = P({ type: t, selectors: [["input", "matInput", ""], ["textarea", "matInput", ""], ["select", "matNativeControl", ""], ["input", "matNativeControl", ""], ["textarea", "matNativeControl", ""]], hostAttrs: [1, "mat-mdc-input-element"], hostVars: 18, hostBindings: function (i, o) { 1 & i && se("focus", function () { return o._focusChanged(!0) })("blur", function () { return o._focusChanged(!1) })("input", function () { return o._onInput() }), 2 & i && (Ks("id", o.id)("disabled", o.disabled)("required", o.required), Ke("name", o.name || null)("readonly", o.readonly && !o._isNativeSelect || null)("aria-invalid", o.empty && o.required ? null : o.errorState)("aria-required", o.required)("id", o.id), Je("mat-input-server", o._isServer)("mat-mdc-form-field-textarea-control", o._isInFormField && o._isTextarea)("mat-mdc-form-field-input-control", o._isInFormField)("mdc-text-field__input", o._isInFormField)("mat-mdc-native-select-inline", o._isInlineSelect())) }, inputs: { disabled: "disabled", id: "id", placeholder: "placeholder", name: "name", required: "required", type: "type", errorStateMatcher: "errorStateMatcher", userAriaDescribedBy: ["aria-describedby", "userAriaDescribedBy"], value: "value", readonly: "readonly" }, exportAs: ["matInput"], features: [ge([{ provide: KS, useExisting: t }]), K, Ft] }) } return t })(), s4 = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ imports: [qe, nM, nM, p3, qe] }) } return t })(); function a4(t, n) { if (1 & t && (x(0, "div", 9)(1, "div", 10), A(2), y(), x(3, "div", 11)(4, "div", 12), A(5), y(), A(6), y()()), 2 & t) { const e = Le().$implicit; S(2), Zt(e.name[0].toUpperCase()), S(3), Zt(e.name), S(1), ln(" ", e.comment, " ") } } function l4(t, n) { if (1 & t && (x(0, "li", 7), Q(1, a4, 7, 3, "div", 8), y()), 2 & t) { const e = n.$implicit; S(1), k("ngIf", "" != e.name) } } let c4 = (() => { class t { ngOnInit() { console.log("hii", this.id), this.api.getComments(this.id).subscribe(e => { this.comments = e }) } constructor(e, i) { this.api = e, this.auth = i, this.comment = new Ht("", jt.required) } submit() { var e = this; return Wr(function* () { if (e.comment.valid) { let i = yield e.auth.getUser(); e.api.sendComment(e.comment.value, e.id, i.name), console.log(e.comment.value), e.api.getComments(e.id).subscribe(o => { e.comments = o }) } })() } static #e = this.\u0275fac = function (i) { return new (i || t)(g(go), g(Yr)) }; static #t = this.\u0275cmp = tt({ type: t, selectors: [["app-comment"]], inputs: { id: "id" }, decls: 9, vars: 2, consts: [[1, "comments"], [1, "example-form", "w-100"], [1, "example-full-width", "w-100", "position-relative"], ["matInput", "", "placeholder", "Leave your review ", 1, "w-50", 3, "formControl", "change"], [1, "send-btn", 3, "click"], [1, "list-group", "list-group-flush"], ["class", "list-group-item d-flex justify-content-between align-items-start", 4, "ngFor", "ngForOf"], [1, "list-group-item", "d-flex", "justify-content-between", "align-items-start"], ["class", "d-flex align-items-center", 4, "ngIf"], [1, "d-flex", "align-items-center"], [1, "avatar"], [1, "ms-2", "me-auto"], [1, "fw-bold"]], template: function (i, o) { 1 & i && (x(0, "div", 0)(1, "div", 1)(2, "mat-form-field", 2)(3, "input", 3), se("change", function () { return o.submit() }), y(), x(4, "button", 4), se("click", function () { return o.submit() }), x(5, "mat-icon"), A(6, "send"), y()()()()(), x(7, "ul", 5), Q(8, l4, 2, 1, "li", 6), y()), 2 & i && (S(3), k("formControl", o.comment), S(5), k("ngForOf", o.comments.comments)) }, dependencies: [Ir, Ii, Um, iM, tM, vo, La, Ua], styles: [".send-btn[_ngcontent-%COMP%]{position:absolute;right:10px;z-index:100;background-color:transparent;border:0cap;outline:none;color:#aaa}.send-btn[_ngcontent-%COMP%]:hover{color:#000}.avatar[_ngcontent-%COMP%]{height:100%;text-align:center;border-radius:50%;background:#565151;padding:10px;color:#f0f8ff;width:40px}"] }) } return t })(); function d4(t, n) { 1 & t && (x(0, "p", 26), A(1, "Currently Out of Stock"), y()) } function u4(t, n) { 1 & t && (x(0, "div", 27), A(1, " Successfully added "), y()) } let h4 = (() => { class t { constructor(e, i, o) { this.bookservice = e, this.router = i, this.auth = o, this.success = !1, this.id = this.router.snapshot.paramMap.get("id"), this.bookservice.getBookDetails(this.id).subscribe(r => { this.data = r }) } add() { let e; this.auth.getUser().then(o => { e = o.id }), this.bookservice.addItemToShopcart({ id: e, product: this.data.title, price: this.data.rate }).subscribe(o => { console.log(o) }), this.success = !0 } static #e = this.\u0275fac = function (i) { return new (i || t)(g(go), g(Gn), g(Yr)) }; static #t = this.\u0275cmp = tt({ type: t, selectors: [["app-book-deatile"]], decls: 61, vars: 14, consts: [[1, "container", 2, "background-color", "#fff"], [1, "row", "py-5", "px-3"], [1, "col-lg-4"], ["id", "carouselExampleIndicators", 1, "carousel", "slide", "sticky-img"], [1, "carousel-inner"], [1, "carousel-item", "active"], ["alt", "...", 1, "d-block", "w-100", 3, "src"], [1, "carousel-item"], ["type", "button", "data-bs-target", "#carouselExampleIndicators", "data-bs-slide", "prev", 1, "carousel-control-prev"], ["aria-hidden", "true", 1, "pre-btn", "carousel-control-prev-icon"], [1, "visually-hidden"], ["type", "button", "data-bs-target", "#carouselExampleIndicators", "data-bs-slide", "next", 1, "carousel-control-next"], ["aria-hidden", "true", 1, "nex-btn", "carousel-control-next-icon"], [1, "book-content", "col-lg-6", "mx-auto"], [2, "color", "green", "margin-top", "0"], [1, "fw-bold"], [3, "click"], ["style", "color: red", 4, "ngIf"], ["class", "alert alert-success my-3", "role", "alert", 4, "ngIf"], ["id", "accordionExample", 1, "accordion"], [1, "accordion-item", "my-5"], [1, "accordion-header"], ["type", "button", "data-bs-toggle", "collapse", "data-bs-target", "#collapseOne", "aria-expanded", "true", "aria-controls", "collapseOne", 1, "accordion-button"], ["id", "collapseOne", "data-bs-parent", "#accordionExample", 1, "accordion-collapse", "collapse", "show", "my-2"], [1, "accordion-body"], [3, "id"], [2, "color", "red"], ["role", "alert", 1, "alert", "alert-success", "my-3"]], template: function (i, o) { 1 & i && (x(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "div", 3)(4, "div", 4)(5, "div", 5), U(6, "img", 6), y(), x(7, "div", 7), U(8, "img", 6), y(), x(9, "div", 7), U(10, "img", 6), y()(), x(11, "button", 8), U(12, "span", 9), x(13, "span", 10), A(14, "Previous"), y()(), x(15, "button", 11), U(16, "span", 12), x(17, "span", 10), A(18, "Next"), y()()()(), x(19, "div", 13)(20, "h1"), A(21), y(), x(22, "p", 14), A(23, "Special price"), y(), x(24, "h1", 15), A(25), y(), x(26, "p"), A(27, "Available offer"), y(), x(28, "ul")(29, "li"), A(30, " Bank Offer10% off on Axis Bank Credit Card EMI Transactions, up to \u20b91,500 on orders of \u20b95,000 and aboveT&C "), y(), x(31, "li"), A(32, " Bank Offer10% off on Flipkart Axis Bank Credit Card EMI Transactions, up to \u20b91500 on orders of \u20b95000 and aboveT&C "), y(), x(33, "li"), A(34, " Bank Offer10% off on Citi Credit Card EMI Transactions, up to \u20b91,500 on orders of \u20b95,000 and aboveT&C "), y(), x(35, "li"), A(36, " Special PriceGet extra 29% off (price inclusive of cashback/coupon)T&C "), y()(), x(37, "button", 16), se("click", function () { return o.add() }), A(38, " Add to Cart "), y(), Q(39, d4, 2, 0, "p", 17), Q(40, u4, 2, 0, "div", 18), x(41, "div", 19)(42, "div", 20)(43, "h2", 21)(44, "button", 22), A(45, " About Book "), y()(), x(46, "div", 23)(47, "div", 24)(48, "p")(49, "strong"), A(50, "Author :"), y(), A(51), y(), x(52, "p")(53, "strong"), A(54, "Pages :"), y(), A(55), y(), x(56, "p")(57, "strong"), A(58, "Language :"), y(), A(59), y()()()()(), U(60, "app-comment", 25), y()()()), 2 & i && (S(6), br("src", o.data.img1, tr), S(2), br("src", o.data.img2, tr), S(2), br("src", o.data.img3, tr), S(11), Zt(o.data.title), S(4), ln("\u20b9", o.data.rate, ""), S(12), Ef("", o.data.outOfStock ? "disabled" : "", " btn btn-success"), S(2), k("ngIf", o.data.outOfStock), S(1), k("ngIf", o.success), S(11), ln(" ", o.data.author, ""), S(4), ln(" ", o.data.Pages, ""), S(4), ln(" ", o.data.Language, ""), S(1), k("id", o.id)) }, dependencies: [Ii, c4], styles: [".nex-btn[_ngcontent-%COMP%], .pre-btn[_ngcontent-%COMP%]{background-color:#000;height:60px}.nex-btn[_ngcontent-%COMP%]{border-radius:5px 0 0 5px}.pre-btn[_ngcontent-%COMP%]{border-radius:0 5px 5px 0}.sticky-img[_ngcontent-%COMP%]{position:sticky;top:6em}"] }) } return t })(); function f4(t, n) { if (1 & t && (x(0, "p", 20), A(1), y()), 2 & t) { const e = Le(); S(1), Zt(e.message) } } function p4(t, n) { if (1 & t && (x(0, "p", 20), A(1), y()), 2 & t) { const e = Le(); S(1), Zt(e.message) } } let m4 = (() => { class t { ngOnInit() { } signup() { this.class = "right-panel-active", console.log("hi") } sigin() { this.class = "" } constructor(e, i) { this.api = e, this.router = i, this.class = "", this.registerForm = new bo({ name: new Ht("", jt.required), username: new Ht("", jt.required), password: new Ht("", jt.required), address: new Ht("", jt.required), phone: new Ht("", jt.required) }), this.loginForm = new bo({ username: new Ht("", jt.required), password: new Ht("", jt.required) }); const o = localStorage.getItem("user"); console.log(o) } newUserSubmit() { this.registerForm.valid ? this.api.userRegister(this.registerForm.value).then(e => { console.log(e), e.flag ? this.router.navigate(["/"]) : (this.flag = !0, this.message = e.message) }).catch(e => { confirm(e) }) : (this.flag = !0, this.message = "Please fill all the fields") } login() { this.loginForm.valid ? this.api.userLogin(this.loginForm.value).then(e => { console.log(e), e.flag ? this.router.navigate(["/"]) : (this.flag = !0, this.message = e.message) }) : (this.flag = !0, this.message = "Please enter username and password") } static #e = this.\u0275fac = function (i) { return new (i || t)(g(Yr), g(Mt)) }; static #t = this.\u0275cmp = tt({ type: t, selectors: [["app-login"]], decls: 45, vars: 14, consts: [["rel", "stylesheet", "href", "https://use.fontawesome.com/releases/v5.8.1/css/all.css", "integrity", "sha384-50oBUHEmvpQ+1lW4y57PTFmhCaXp0ML5d60M1M7uH2+nqUivzIebhndOJK28anvf", "crossorigin", "anonymous"], ["id", "container"], [1, "form-container", "sign-up-container"], [3, "formGroup", "submit"], ["type", "text", "placeholder", "Name", "required", "", 3, "formControl"], ["type", "text", "placeholder", "Phone number", "required", "", 3, "formControl"], ["type", "text", "placeholder", "Address", "required", "", 3, "formControl"], ["type", "email", "placeholder", "Email", "required", "", 3, "formControl"], ["type", "password", "placeholder", "Password", "required", "", 3, "formControl"], ["style", "color: red", 4, "ngIf"], [1, "form-container", "sign-in-container"], [3, "formGroup"], ["href", "#"], [3, "click"], [1, "overlay-container"], [1, "overlay"], [1, "overlay-panel", "overlay-left"], ["id", "signIn", 1, "ghost", 3, "click"], [1, "overlay-panel", "overlay-right"], ["id", "signUp", 1, "ghost", 3, "click"], [2, "color", "red"]], template: function (i, o) { 1 & i && (U(0, "link", 0), x(1, "div", 1)(2, "div", 2)(3, "form", 3), se("submit", function () { return o.newUserSubmit() }), x(4, "h1"), A(5, "Create Account"), y(), x(6, "span"), A(7, "or use your email for registration"), y(), U(8, "input", 4)(9, "input", 5)(10, "input", 6)(11, "input", 7)(12, "input", 8), x(13, "button"), A(14, "Sign Up"), y(), Q(15, f4, 2, 1, "p", 9), y()(), x(16, "div", 10)(17, "form", 11)(18, "h1"), A(19, "Sign in"), y(), x(20, "span"), A(21, "or use your account"), y(), U(22, "input", 7)(23, "input", 8), x(24, "a", 12), A(25, "Forgot your password?"), y(), x(26, "button", 13), se("click", function () { return o.login() }), A(27, "Sign In"), y(), Q(28, p4, 2, 1, "p", 9), y()(), x(29, "div", 14)(30, "div", 15)(31, "div", 16)(32, "h1"), A(33, "Welcome Back!"), y(), x(34, "p"), A(35, "To keep connected with us please login with your personal info"), y(), x(36, "button", 17), se("click", function () { return o.sigin() }), A(37, "Sign In"), y()(), x(38, "div", 18)(39, "h1"), A(40, "Hello, Friend!"), y(), x(41, "p"), A(42, "Enter your personal details and start journey with us"), y(), x(43, "button", 19), se("click", function () { return o.signup() }), A(44, "Sign Up"), y()()()()()), 2 & i && (S(1), Ef("container ", o.class, " my-5"), S(2), k("formGroup", o.registerForm), S(5), k("formControl", o.registerForm.controls.name), S(1), k("formControl", o.registerForm.controls.phone), S(1), k("formControl", o.registerForm.controls.address), S(1), k("formControl", o.registerForm.controls.username), S(1), k("formControl", o.registerForm.controls.password), S(3), k("ngIf", o.flag), S(2), k("formGroup", o.loginForm), S(5), k("formControl", o.loginForm.controls.username), S(1), k("formControl", o.loginForm.controls.password), S(5), k("ngIf", o.flag)) }, dependencies: [Ii, Pm, vo, La, Sm, kd, Ua, Kr], styles: ['@import"https://fonts.googleapis.com/css?family=Montserrat:400,800";*[_ngcontent-%COMP%]{box-sizing:border-box}body[_ngcontent-%COMP%]{font-family:Montserrat,sans-serif;background:#f6f5f7;display:flex;flex-direction:column;justify-content:center;align-items:center;height:100vh;margin:20px 0 50px}h1[_ngcontent-%COMP%]{font-weight:700;margin:0}p[_ngcontent-%COMP%]{font-size:14px;font-weight:100;line-height:20px;letter-spacing:.5px;margin:20px 0 30px}span[_ngcontent-%COMP%]{font-size:12px}a[_ngcontent-%COMP%]{color:#333;font-size:14px;text-decoration:none;margin:15px 0}.container[_ngcontent-%COMP%]{background:#fff;border-radius:10px;box-shadow:0 14px 28px #0003,0 10px 10px #0003;position:relative;overflow:hidden;width:768px;max-width:100%;min-height:480px}.form-container[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{background:#fff;display:flex;flex-direction:column;padding:0 50px;height:100%;justify-content:center;align-items:center;text-align:center}.social-container[_ngcontent-%COMP%]{margin:20px 0}.social-container[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{border:1px solid #ddd;border-radius:50%;display:inline-flex;justify-content:center;align-items:center;margin:0 5px;height:40px;width:40px}.form-container[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{background:#eee;border:none;padding:12px 15px;margin:8px 0;width:100%}button[_ngcontent-%COMP%]{border-radius:20px;border:1px solid #ff4b2b;background:#ff445c;color:#fff;font-size:12px;font-weight:700;padding:12px 45px;letter-spacing:1px;text-transform:uppercase;transition:transform 80ms ease-in}button[_ngcontent-%COMP%]:active{transform:scale(.95)}button[_ngcontent-%COMP%]:focus{outline:none}button.ghost[_ngcontent-%COMP%]{background:transparent;border-color:#fff}.form-container[_ngcontent-%COMP%]{position:absolute;top:0;height:100%;transition:all .6s ease-in-out}.sign-in-container[_ngcontent-%COMP%]{left:0;width:50%;z-index:2}.sign-up-container[_ngcontent-%COMP%]{left:0;width:50%;z-index:1;opacity:0}.overlay-container[_ngcontent-%COMP%]{position:absolute;top:0;left:50%;width:50%;height:100%;overflow:hidden;transition:transform .6s ease-in-out;z-index:100}.overlay[_ngcontent-%COMP%]{background:#ff416c;background:linear-gradient(to right,#ff4b2b,#ff416c) no-repeat 0 0 / cover;color:#fff;position:relative;left:-100%;height:100%;width:200%;transform:translateY(0);transition:transform .6s ease-in-out}.overlay-panel[_ngcontent-%COMP%]{position:absolute;top:0;display:flex;flex-direction:column;justify-content:center;align-items:center;padding:0 40px;height:100%;width:50%;text-align:center;transform:translateY(0);transition:transform .6s ease-in-out}.overlay-right[_ngcontent-%COMP%]{right:0;transform:translateY(0)}.overlay-left[_ngcontent-%COMP%]{transform:translateY(-20%)}.container.right-panel-active[_ngcontent-%COMP%]   .sign-in-container[_ngcontent-%COMP%]{transform:translateY(100%)}.container.right-panel-active[_ngcontent-%COMP%]   .overlay-container[_ngcontent-%COMP%]{transform:translate(-100%)}.container.right-panel-active[_ngcontent-%COMP%]   .sign-up-container[_ngcontent-%COMP%]{transform:translate(100%);opacity:1;z-index:5}.container.right-panel-active[_ngcontent-%COMP%]   .overlay[_ngcontent-%COMP%]{transform:translate(50%)}.container.right-panel-active[_ngcontent-%COMP%]   .overlay-left[_ngcontent-%COMP%]{transform:translateY(0)}.container.right-panel-active[_ngcontent-%COMP%]   .overlay-right[_ngcontent-%COMP%]{transform:translateY(20%)}.footer[_ngcontent-%COMP%]{margin-top:25px;text-align:center}.icons[_ngcontent-%COMP%]{display:flex;width:30px;height:30px;letter-spacing:15px;align-items:center}'] }) } return t })(); function g4(t, n) { if (1 & t) { const e = Ys(); x(0, "li", 7)(1, "div", 8)(2, "div", 9), A(3), y(), x(4, "div", 10)(5, "div", 9), A(6), y(), x(7, "div")(8, "button", 11), se("click", function () { const r = gs(e).index; return _s(Le().delete(r)) }), x(9, "mat-icon", 12), A(10, "delete"), y()()()()()() } if (2 & t) { const e = n.$implicit, i = Le(); S(3), Zt(e.product), S(3), Df("\u20b9", e.price, " ", i.calculateTotals(e.price), "") } } let _4 = (() => { class t { ngOnInit() { this.totalPrice = 0, this.id = this.router.snapshot.paramMap.get("id"), this.api.getUserShopdetails(this.id).subscribe(e => { this.data = e }) } constructor(e, i) { this.api = e, this.router = i, this.totalPrice = 0 } calculateTotals(e) { return this.totalPrice += e, " " } delete(e) { this.api.delShopcarItem({ id: this.id, index: e }).subscribe(o => { console.log(o) }, o => { console.log(o) }), window.location.reload() } static #e = this.\u0275fac = function (i) { return new (i || t)(g(go), g(Gn)) }; static #t = this.\u0275cmp = tt({ type: t, selectors: [["app-shop-crt"]], decls: 14, vars: 3, consts: [[1, "container", 2, "background-color", "#fff", "font-size", "18px"], [1, "text-center", "py-5"], [1, "list-group", "p-5"], ["class", "list-group-item ", 4, "ngFor", "ngForOf"], [1, "mx-5", "pb-2", 2, "text-align", "end"], [1, "d-flex", "justify-content-between"], [1, "btn", "btn-primary", "mx-4", "mb-5", "px-4", 2, "color", "#fff", 3, "routerLink"], [1, "list-group-item"], [1, "d-flex", "justify-content-between", "algin-items-center"], [1, ""], [1, "d-flex", "justify-content-around"], [2, "background", "transparent", "border", "0", 3, "click"], [2, "color", "red"]], template: function (i, o) { 1 & i && (x(0, "div", 0)(1, "h1", 1), A(2, "Shop Cart"), y(), x(3, "ul", 2), Q(4, g4, 11, 3, "li", 3), y(), x(5, "div", 4)(6, "p")(7, "strong"), A(8, "Total :"), y(), A(9), y()(), x(10, "div", 5), U(11, "div"), x(12, "a", 6), A(13, " Pay now\n"), y()()()), 2 & i && (S(4), k("ngForOf", o.data), S(5), ln(" \u20b9", o.totalPrice, ""), S(3), yr("routerLink", "/shopping/", o.totalPrice, "")) }, dependencies: [Ir, $r, Um] }) } return t })(), v4 = (() => { class t { constructor() { this._listeners = [] } notify(e, i) { for (let o of this._listeners) o(e, i) } listen(e) { return this._listeners.push(e), () => { this._listeners = this._listeners.filter(i => e !== i) } } ngOnDestroy() { this._listeners = [] } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); const b4 = ["input"], y4 = ["*"]; let oM = 0; class rM { constructor(n, e) { this.source = n, this.value = e } } const w4 = { provide: mn, useExisting: be(() => aM), multi: !0 }, sM = new E("MatRadioGroup"), x4 = new E("mat-radio-default-options", { providedIn: "root", factory: function C4() { return { color: "accent" } } }); let D4 = (() => { class t { get name() { return this._name } set name(e) { this._name = e, this._updateRadioButtonNames() } get labelPosition() { return this._labelPosition } set labelPosition(e) { this._labelPosition = "before" === e ? "before" : "after", this._markRadiosForCheck() } get value() { return this._value } set value(e) { this._value !== e && (this._value = e, this._updateSelectedRadioFromValue(), this._checkSelectedRadioButton()) } _checkSelectedRadioButton() { this._selected && !this._selected.checked && (this._selected.checked = !0) } get selected() { return this._selected } set selected(e) { this._selected = e, this.value = e ? e.value : null, this._checkSelectedRadioButton() } get disabled() { return this._disabled } set disabled(e) { this._disabled = lt(e), this._markRadiosForCheck() } get required() { return this._required } set required(e) { this._required = lt(e), this._markRadiosForCheck() } constructor(e) { this._changeDetector = e, this._value = null, this._name = "mat-radio-group-" + oM++, this._selected = null, this._isInitialized = !1, this._labelPosition = "after", this._disabled = !1, this._required = !1, this._controlValueAccessorChangeFn = () => { }, this.onTouched = () => { }, this.change = new ue } ngAfterContentInit() { this._isInitialized = !0, this._buttonChanges = this._radios.changes.subscribe(() => { this.selected && !this._radios.find(e => e === this.selected) && (this._selected = null) }) } ngOnDestroy() { this._buttonChanges?.unsubscribe() } _touch() { this.onTouched && this.onTouched() } _updateRadioButtonNames() { this._radios && this._radios.forEach(e => { e.name = this.name, e._markForCheck() }) } _updateSelectedRadioFromValue() { this._radios && (null === this._selected || this._selected.value !== this._value) && (this._selected = null, this._radios.forEach(i => { i.checked = this.value === i.value, i.checked && (this._selected = i) })) } _emitChangeEvent() { this._isInitialized && this.change.emit(new rM(this._selected, this._value)) } _markRadiosForCheck() { this._radios && this._radios.forEach(e => e._markForCheck()) } writeValue(e) { this.value = e, this._changeDetector.markForCheck() } registerOnChange(e) { this._controlValueAccessorChangeFn = e } registerOnTouched(e) { this.onTouched = e } setDisabledState(e) { this.disabled = e, this._changeDetector.markForCheck() } static #e = this.\u0275fac = function (i) { return new (i || t)(g(Un)) }; static #t = this.\u0275dir = P({ type: t, inputs: { color: "color", name: "name", labelPosition: "labelPosition", value: "value", selected: "selected", disabled: "disabled", required: "required" }, outputs: { change: "change" } }) } return t })(); class E4 { constructor(n) { this._elementRef = n } } const S4 = JC(qj(E4)); let M4 = (() => { class t extends S4 { get checked() { return this._checked } set checked(e) { const i = lt(e); this._checked !== i && (this._checked = i, i && this.radioGroup && this.radioGroup.value !== this.value ? this.radioGroup.selected = this : !i && this.radioGroup && this.radioGroup.value === this.value && (this.radioGroup.selected = null), i && this._radioDispatcher.notify(this.id, this.name), this._changeDetector.markForCheck()) } get value() { return this._value } set value(e) { this._value !== e && (this._value = e, null !== this.radioGroup && (this.checked || (this.checked = this.radioGroup.value === e), this.checked && (this.radioGroup.selected = this))) } get labelPosition() { return this._labelPosition || this.radioGroup && this.radioGroup.labelPosition || "after" } set labelPosition(e) { this._labelPosition = e } get disabled() { return this._disabled || null !== this.radioGroup && this.radioGroup.disabled } set disabled(e) { this._setDisabled(lt(e)) } get required() { return this._required || this.radioGroup && this.radioGroup.required } set required(e) { this._required = lt(e) } get color() { return this._color || this.radioGroup && this.radioGroup.color || this._providerOverride && this._providerOverride.color || "accent" } set color(e) { this._color = e } get inputId() { return `${this.id || this._uniqueId}-input` } constructor(e, i, o, r, s, a, l, c) { super(i), this._changeDetector = o, this._focusMonitor = r, this._radioDispatcher = s, this._providerOverride = l, this._uniqueId = "mat-radio-" + ++oM, this.id = this._uniqueId, this.change = new ue, this._checked = !1, this._value = null, this._removeUniqueSelectionListener = () => { }, this.radioGroup = e, this._noopAnimations = "NoopAnimations" === a, c && (this.tabIndex = FC(c, 0)) } focus(e, i) { i ? this._focusMonitor.focusVia(this._inputElement, i, e) : this._inputElement.nativeElement.focus(e) } _markForCheck() { this._changeDetector.markForCheck() } ngOnInit() { this.radioGroup && (this.checked = this.radioGroup.value === this._value, this.checked && (this.radioGroup.selected = this), this.name = this.radioGroup.name), this._removeUniqueSelectionListener = this._radioDispatcher.listen((e, i) => { e !== this.id && i === this.name && (this.checked = !1) }) } ngDoCheck() { this._updateTabIndex() } ngAfterViewInit() { this._updateTabIndex(), this._focusMonitor.monitor(this._elementRef, !0).subscribe(e => { !e && this.radioGroup && this.radioGroup._touch() }) } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef), this._removeUniqueSelectionListener() } _emitChangeEvent() { this.change.emit(new rM(this, this._value)) } _isRippleDisabled() { return this.disableRipple || this.disabled } _onInputClick(e) { e.stopPropagation() } _onInputInteraction(e) { if (e.stopPropagation(), !this.checked && !this.disabled) { const i = this.radioGroup && this.value !== this.radioGroup.value; this.checked = !0, this._emitChangeEvent(), this.radioGroup && (this.radioGroup._controlValueAccessorChangeFn(this.value), i && this.radioGroup._emitChangeEvent()) } } _onTouchTargetClick(e) { this._onInputInteraction(e), this.disabled || this._inputElement.nativeElement.focus() } _setDisabled(e) { this._disabled !== e && (this._disabled = e, this._changeDetector.markForCheck()) } _updateTabIndex() { const e = this.radioGroup; let i; if (i = e && e.selected && !this.disabled ? e.selected === this ? this.tabIndex : -1 : this.tabIndex, i !== this._previousTabIndex) { const o = this._inputElement?.nativeElement; o && (o.setAttribute("tabindex", i + ""), this._previousTabIndex = i) } } static #e = this.\u0275fac = function (i) { ic() }; static #t = this.\u0275dir = P({ type: t, viewQuery: function (i, o) { if (1 & i && dn(b4, 5), 2 & i) { let r; Re(r = Oe()) && (o._inputElement = r.first) } }, inputs: { id: "id", name: "name", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedby: ["aria-describedby", "ariaDescribedby"], checked: "checked", value: "value", labelPosition: "labelPosition", disabled: "disabled", required: "required", color: "color" }, outputs: { change: "change" }, features: [K] }) } return t })(), aM = (() => { class t extends D4 { static #e = this.\u0275fac = function () { let e; return function (o) { return (e || (e = ze(t)))(o || t) } }(); static #t = this.\u0275dir = P({ type: t, selectors: [["mat-radio-group"]], contentQueries: function (i, o, r) { if (1 & i && un(r, lM, 5), 2 & i) { let s; Re(s = Oe()) && (o._radios = s) } }, hostAttrs: ["role", "radiogroup", 1, "mat-mdc-radio-group"], exportAs: ["matRadioGroup"], features: [ge([w4, { provide: sM, useExisting: t }]), K] }) } return t })(), lM = (() => { class t extends M4 { constructor(e, i, o, r, s, a, l, c) { super(e, i, o, r, s, a, l, c) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(sM, 8), g(ye), g(Un), g(Rj), g(v4), g(eo, 8), g(x4, 8), Uo("tabindex")) }; static #t = this.\u0275cmp = tt({ type: t, selectors: [["mat-radio-button"]], hostAttrs: [1, "mat-mdc-radio-button"], hostVars: 15, hostBindings: function (i, o) { 1 & i && se("focus", function () { return o._inputElement.nativeElement.focus() }), 2 & i && (Ke("id", o.id)("tabindex", null)("aria-label", null)("aria-labelledby", null)("aria-describedby", null), Je("mat-primary", "primary" === o.color)("mat-accent", "accent" === o.color)("mat-warn", "warn" === o.color)("mat-mdc-radio-checked", o.checked)("_mat-animation-noopable", o._noopAnimations)) }, inputs: { disableRipple: "disableRipple", tabIndex: "tabIndex" }, exportAs: ["matRadioButton"], features: [K], ngContentSelectors: y4, decls: 13, vars: 17, consts: [[1, "mdc-form-field"], ["formField", ""], [1, "mdc-radio"], [1, "mat-mdc-radio-touch-target", 3, "click"], ["type", "radio", 1, "mdc-radio__native-control", 3, "id", "checked", "disabled", "required", "change"], ["input", ""], [1, "mdc-radio__background"], [1, "mdc-radio__outer-circle"], [1, "mdc-radio__inner-circle"], ["mat-ripple", "", 1, "mat-radio-ripple", "mat-mdc-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled", "matRippleCentered"], [1, "mat-ripple-element", "mat-radio-persistent-ripple"], [1, "mdc-label", 3, "for"]], template: function (i, o) { if (1 & i && (io(), x(0, "div", 0, 1)(2, "div", 2)(3, "div", 3), se("click", function (s) { return o._onTouchTargetClick(s) }), y(), x(4, "input", 4, 5), se("change", function (s) { return o._onInputInteraction(s) }), y(), x(6, "div", 6), U(7, "div", 7)(8, "div", 8), y(), x(9, "div", 9), U(10, "div", 10), y()(), x(11, "label", 11), mt(12), y()()), 2 & i) { const r = Ws(1); Je("mdc-form-field--align-end", "before" == o.labelPosition), S(2), Je("mdc-radio--disabled", o.disabled), S(2), k("id", o.inputId)("checked", o.checked)("disabled", o.disabled)("required", o.required), Ke("name", o.name)("value", o.value)("aria-label", o.ariaLabel)("aria-labelledby", o.ariaLabelledby)("aria-describedby", o.ariaDescribedby), S(5), k("matRippleTrigger", r)("matRippleDisabled", o._isRippleDisabled())("matRippleCentered", !0), S(2), k("for", o.inputId) } }, dependencies: [rD], styles: ['.mdc-radio{display:inline-block;position:relative;flex:0 0 auto;box-sizing:content-box;width:20px;height:20px;cursor:pointer;will-change:opacity,transform,border-color,color}.mdc-radio[hidden]{display:none}.mdc-radio__background{display:inline-block;position:relative;box-sizing:border-box;width:20px;height:20px}.mdc-radio__background::before{position:absolute;transform:scale(0, 0);border-radius:50%;opacity:0;pointer-events:none;content:"";transition:opacity 120ms 0ms cubic-bezier(0.4, 0, 0.6, 1),transform 120ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-radio__outer-circle{position:absolute;top:0;left:0;box-sizing:border-box;width:100%;height:100%;border-width:2px;border-style:solid;border-radius:50%;transition:border-color 120ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-radio__inner-circle{position:absolute;top:0;left:0;box-sizing:border-box;width:100%;height:100%;transform:scale(0, 0);border-width:10px;border-style:solid;border-radius:50%;transition:transform 120ms 0ms cubic-bezier(0.4, 0, 0.6, 1),border-color 120ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-radio__native-control{position:absolute;margin:0;padding:0;opacity:0;cursor:inherit;z-index:1}.mdc-radio--touch{margin-top:4px;margin-bottom:4px;margin-right:4px;margin-left:4px}.mdc-radio--touch .mdc-radio__native-control{top:calc((40px - 48px) / 2);right:calc((40px - 48px) / 2);left:calc((40px - 48px) / 2);width:48px;height:48px}.mdc-radio.mdc-ripple-upgraded--background-focused .mdc-radio__focus-ring,.mdc-radio:not(.mdc-ripple-upgraded):focus .mdc-radio__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:100%;width:100%}@media screen and (forced-colors: active){.mdc-radio.mdc-ripple-upgraded--background-focused .mdc-radio__focus-ring,.mdc-radio:not(.mdc-ripple-upgraded):focus .mdc-radio__focus-ring{border-color:CanvasText}}.mdc-radio.mdc-ripple-upgraded--background-focused .mdc-radio__focus-ring::after,.mdc-radio:not(.mdc-ripple-upgraded):focus .mdc-radio__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-radio.mdc-ripple-upgraded--background-focused .mdc-radio__focus-ring::after,.mdc-radio:not(.mdc-ripple-upgraded):focus .mdc-radio__focus-ring::after{border-color:CanvasText}}.mdc-radio__native-control:checked+.mdc-radio__background,.mdc-radio__native-control:disabled+.mdc-radio__background{transition:opacity 120ms 0ms cubic-bezier(0, 0, 0.2, 1),transform 120ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__outer-circle,.mdc-radio__native-control:disabled+.mdc-radio__background .mdc-radio__outer-circle{transition:border-color 120ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__inner-circle,.mdc-radio__native-control:disabled+.mdc-radio__background .mdc-radio__inner-circle{transition:transform 120ms 0ms cubic-bezier(0, 0, 0.2, 1),border-color 120ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-radio--disabled{cursor:default;pointer-events:none}.mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__inner-circle{transform:scale(0.5);transition:transform 120ms 0ms cubic-bezier(0, 0, 0.2, 1),border-color 120ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-radio__native-control:disabled+.mdc-radio__background,[aria-disabled=true] .mdc-radio__native-control+.mdc-radio__background{cursor:default}.mdc-radio__native-control:focus+.mdc-radio__background::before{transform:scale(1);opacity:.12;transition:opacity 120ms 0ms cubic-bezier(0, 0, 0.2, 1),transform 120ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-form-field{display:inline-flex;align-items:center;vertical-align:middle}.mdc-form-field[hidden]{display:none}.mdc-form-field>label{margin-left:0;margin-right:auto;padding-left:4px;padding-right:0;order:0}[dir=rtl] .mdc-form-field>label,.mdc-form-field>label[dir=rtl]{margin-left:auto;margin-right:0}[dir=rtl] .mdc-form-field>label,.mdc-form-field>label[dir=rtl]{padding-left:0;padding-right:4px}.mdc-form-field--nowrap>label{text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.mdc-form-field--align-end>label{margin-left:auto;margin-right:0;padding-left:0;padding-right:4px;order:-1}[dir=rtl] .mdc-form-field--align-end>label,.mdc-form-field--align-end>label[dir=rtl]{margin-left:0;margin-right:auto}[dir=rtl] .mdc-form-field--align-end>label,.mdc-form-field--align-end>label[dir=rtl]{padding-left:4px;padding-right:0}.mdc-form-field--space-between{justify-content:space-between}.mdc-form-field--space-between>label{margin:0}[dir=rtl] .mdc-form-field--space-between>label,.mdc-form-field--space-between>label[dir=rtl]{margin:0}.mat-mdc-radio-button{--mdc-radio-disabled-selected-icon-opacity:0.38;--mdc-radio-disabled-unselected-icon-opacity:0.38;--mdc-radio-state-layer-size:40px;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-radio-button .mdc-radio{padding:calc((var(--mdc-radio-state-layer-size) - 20px) / 2)}.mat-mdc-radio-button .mdc-radio [aria-disabled=true] .mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__outer-circle,.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:disabled:checked+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-disabled-selected-icon-color)}.mat-mdc-radio-button .mdc-radio [aria-disabled=true] .mdc-radio__native-control+.mdc-radio__background .mdc-radio__inner-circle,.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:disabled+.mdc-radio__background .mdc-radio__inner-circle{border-color:var(--mdc-radio-disabled-selected-icon-color)}.mat-mdc-radio-button .mdc-radio [aria-disabled=true] .mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__outer-circle,.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:disabled:checked+.mdc-radio__background .mdc-radio__outer-circle{opacity:var(--mdc-radio-disabled-selected-icon-opacity)}.mat-mdc-radio-button .mdc-radio [aria-disabled=true] .mdc-radio__native-control+.mdc-radio__background .mdc-radio__inner-circle,.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:disabled+.mdc-radio__background .mdc-radio__inner-circle{opacity:var(--mdc-radio-disabled-selected-icon-opacity)}.mat-mdc-radio-button .mdc-radio [aria-disabled=true] .mdc-radio__native-control:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle,.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:disabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-disabled-unselected-icon-color)}.mat-mdc-radio-button .mdc-radio [aria-disabled=true] .mdc-radio__native-control:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle,.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:disabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{opacity:var(--mdc-radio-disabled-unselected-icon-opacity)}.mat-mdc-radio-button .mdc-radio.mdc-ripple-upgraded--background-focused .mdc-radio__native-control:enabled:checked+.mdc-radio__background .mdc-radio__outer-circle,.mat-mdc-radio-button .mdc-radio:not(.mdc-ripple-upgraded):focus .mdc-radio__native-control:enabled:checked+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-selected-focus-icon-color)}.mat-mdc-radio-button .mdc-radio.mdc-ripple-upgraded--background-focused .mdc-radio__native-control:enabled+.mdc-radio__background .mdc-radio__inner-circle,.mat-mdc-radio-button .mdc-radio:not(.mdc-ripple-upgraded):focus .mdc-radio__native-control:enabled+.mdc-radio__background .mdc-radio__inner-circle{border-color:var(--mdc-radio-selected-focus-icon-color)}.mat-mdc-radio-button .mdc-radio:hover .mdc-radio__native-control:enabled:checked+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-selected-hover-icon-color)}.mat-mdc-radio-button .mdc-radio:hover .mdc-radio__native-control:enabled+.mdc-radio__background .mdc-radio__inner-circle{border-color:var(--mdc-radio-selected-hover-icon-color)}.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:enabled:checked+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-selected-icon-color)}.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:enabled+.mdc-radio__background .mdc-radio__inner-circle{border-color:var(--mdc-radio-selected-icon-color)}.mat-mdc-radio-button .mdc-radio:not(:disabled):active .mdc-radio__native-control:enabled:checked+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-selected-pressed-icon-color)}.mat-mdc-radio-button .mdc-radio:not(:disabled):active .mdc-radio__native-control:enabled+.mdc-radio__background .mdc-radio__inner-circle{border-color:var(--mdc-radio-selected-pressed-icon-color)}.mat-mdc-radio-button .mdc-radio:hover .mdc-radio__native-control:enabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-unselected-hover-icon-color)}.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:enabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-unselected-icon-color)}.mat-mdc-radio-button .mdc-radio:not(:disabled):active .mdc-radio__native-control:enabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-unselected-pressed-icon-color)}.mat-mdc-radio-button .mdc-radio .mdc-radio__background::before{top:calc(-1 * (var(--mdc-radio-state-layer-size) - 20px) / 2);left:calc(-1 * (var(--mdc-radio-state-layer-size) - 20px) / 2);width:var(--mdc-radio-state-layer-size);height:var(--mdc-radio-state-layer-size)}.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control{top:calc((var(--mdc-radio-state-layer-size) - var(--mdc-radio-state-layer-size)) / 2);right:calc((var(--mdc-radio-state-layer-size) - var(--mdc-radio-state-layer-size)) / 2);left:calc((var(--mdc-radio-state-layer-size) - var(--mdc-radio-state-layer-size)) / 2);width:var(--mdc-radio-state-layer-size);height:var(--mdc-radio-state-layer-size)}.mat-mdc-radio-button .mdc-radio .mdc-radio__background::before{background-color:var(--mat-radio-ripple-color)}.mat-mdc-radio-button .mdc-radio:hover .mdc-radio__native-control:not([disabled]):not(:focus)~.mdc-radio__background::before{opacity:.04;transform:scale(1)}.mat-mdc-radio-button.mat-mdc-radio-checked .mdc-radio__background::before{background-color:var(--mat-radio-checked-ripple-color)}.mat-mdc-radio-button.mat-mdc-radio-checked .mat-ripple-element{background-color:var(--mat-radio-checked-ripple-color)}.mat-mdc-radio-button .mdc-radio--disabled+label{color:var(--mat-radio-disabled-label-color)}.mat-mdc-radio-button .mat-radio-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:50%}.mat-mdc-radio-button .mat-radio-ripple .mat-ripple-element{opacity:.14}.mat-mdc-radio-button .mat-radio-ripple::before{border-radius:50%}.mat-mdc-radio-button._mat-animation-noopable .mdc-radio__background::before,.mat-mdc-radio-button._mat-animation-noopable .mdc-radio__outer-circle,.mat-mdc-radio-button._mat-animation-noopable .mdc-radio__inner-circle{transition:none !important}.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:focus:enabled:not(:checked)~.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-unselected-focus-icon-color, black)}.mat-mdc-radio-button.cdk-focused .mat-mdc-focus-indicator::before{content:""}.mat-mdc-radio-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}[dir=rtl] .mat-mdc-radio-touch-target{left:0;right:50%;transform:translate(50%, -50%)}'], encapsulation: 2, changeDetection: 0 }) } return t })(), I4 = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ imports: [qe, Ar, Yp, qe] }) } return t })(); function A4(t, n) { 1 & t && (x(0, "mat-form-field", 6)(1, "mat-label"), A(2, "UPI ID"), y(), U(3, "input", 15), y()) } function T4(t, n) { 1 & t && (x(0, "mat-form-field", 6)(1, "mat-label"), A(2, "Credit card number"), y(), U(3, "input", 15), y()) } function R4(t, n) { 1 & t && (x(0, "mat-form-field", 6)(1, "mat-label"), A(2, "Debit card number"), y(), U(3, "input", 15), y()) } function k4(t, n) { if (1 & t && (x(0, "div", 6)(1, "div", 7), A(2), y(), x(3, "div", 8), A(4, "Deliveried Successfully."), y()()), 2 & t) { const e = n.$implicit; S(2), Zt(e.product) } } function F4(t, n) { if (1 & t && (x(0, "li", 4), Q(1, k4, 5, 1, "div", 5), y()), 2 & t) { const e = n.$implicit; S(1), k("ngForOf", e.products) } } const P4 = [{ path: "", component: o$ }, { path: "book/:id", component: h4 }, { path: "login", component: m4 }, { path: "shop-cart/:id", component: _4 }, { path: "shopping/:price", component: (() => { class t { constructor(e, i, o, r, s) { this.formBuilder = e, this.auth = i, this.api = o, this.router = r, this.route = s, this.auth.getUser().then(a => { this.res = a }), this.price = r.snapshot.paramMap.get("price") } ngOnInit() { this.api.getUserShopdetails(this.res.id).subscribe(e => { this.item = e }), this.shoppingForm = this.formBuilder.group({ address: ["", jt.required], payment: ["", jt.required], phone: ["", jt.required], payment_ID: ["", jt.required], total: ["\u20b9" + this.price] }) } submitShoppingForm() { if (this.shoppingForm.valid) { console.log(this.shoppingForm.value); let e = this.shoppingForm.value; e.id = this.res.id, e.product = this.item, "Cash on Delivery" == e.payment && (e.payment_ID = "Cash on Delivery"), this.api.placeOrder(e).subscribe(() => { const i = this.item.map(o => o.product); console.log(i), this.api.setOutOfStock(i), this.route.navigate(["/"]) }) } } static #e = this.\u0275fac = function (i) { return new (i || t)(g(Q$), g(Yr), g(go), g(Gn), g(Mt)) }; static #t = this.\u0275cmp = tt({ type: t, selectors: [["app-shopping"]], decls: 47, vars: 10, consts: [[1, "container", "py-5", 2, "background-color", "#fff"], [1, "row"], [1, "text-center"], [1, "col-lg-8", "mx-auto"], [1, "row", 3, "formGroup", "submit"], [1, "col-lg-6"], ["appearance", "outline"], ["matInput", "", "readonly", "", 3, "value"], ["matInput", "", "formControlName", "address"], ["matInput", "", "formControlName", "phone"], ["aria-label", "payment", "formControlName", "payment", 1, "pb-3"], [3, "value"], ["appearance", "outline", 4, "ngIf"], ["matInput", "", "readonly", "", "formControlName", "total"], ["type", "button", 1, "btn", "btn-primary", 3, "click"], ["matInput", "", "formControlName", "payment_ID"]], template: function (i, o) { 1 & i && (x(0, "div", 0)(1, "div", 1)(2, "h1", 2), A(3, "Order details"), y(), x(4, "div", 3)(5, "form", 4), se("submit", function () { return o.submitShoppingForm() }), x(6, "div", 5)(7, "mat-form-field", 6)(8, "mat-label"), A(9, "Name"), y(), U(10, "input", 7), y()(), x(11, "div", 5)(12, "mat-form-field", 6)(13, "mat-label"), A(14, "Username"), y(), U(15, "input", 7), y()(), x(16, "mat-form-field", 6)(17, "mat-label"), A(18, "Delivery Address"), y(), U(19, "textarea", 8), y(), x(20, "mat-form-field", 6)(21, "mat-label"), A(22, "Phone number"), y(), U(23, "input", 9), y(), x(24, "h2"), A(25, "Payment option :"), y(), x(26, "mat-radio-group", 10)(27, "mat-radio-button", 11), A(28, "Cash on Delivery"), y(), U(29, "br"), x(30, "mat-radio-button", 11), A(31, "Credit card"), y(), U(32, "br"), x(33, "mat-radio-button", 11), A(34, "Debit card"), y(), U(35, "br"), x(36, "mat-radio-button", 11), A(37, "UPI"), y()(), Q(38, A4, 4, 0, "mat-form-field", 12), Q(39, T4, 4, 0, "mat-form-field", 12), Q(40, R4, 4, 0, "mat-form-field", 12), x(41, "mat-form-field", 6)(42, "mat-label"), A(43, "Total"), y(), U(44, "input", 13), y(), x(45, "button", 14), se("click", function () { return o.submitShoppingForm() }), A(46, " Place Order "), y()()()()()), 2 & i && (S(5), k("formGroup", o.shoppingForm), S(5), k("value", o.res.name), S(5), k("value", o.res.username), S(12), k("value", "Cash on Delivery"), S(3), k("value", "Credit card"), S(3), k("value", "Debit card"), S(3), k("value", "Upi"), S(2), k("ngIf", "Upi" === o.shoppingForm.controls.payment.value), S(1), k("ngIf", "Credit card" === o.shoppingForm.controls.payment.value), S(1), k("ngIf", "Debit card" === o.shoppingForm.controls.payment.value)) }, dependencies: [Ii, iM, tM, Gm, Pm, vo, La, Sm, Kr, Bm, aM, lM], styles: ["form[_ngcontent-%COMP%]   mat-form-field[_ngcontent-%COMP%]{width:100%}"] }) } return t })() }, { path: "order-history/:id", component: (() => { class t { constructor(e, i, o) { this.api = e, this.auth = i, this.route = o, this.userId = o.snapshot.paramMap.get("id"), e.getOrderHistory(this.userId).subscribe(r => { this.history = r, console.log(this.history) }) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(go), g(Yr), g(Gn)) }; static #t = this.\u0275cmp = tt({ type: t, selectors: [["app-order-history"]], decls: 5, vars: 1, consts: [[1, "container", 2, "background-color", "#fff", "font-size", "18px"], [1, "text-center", "py-5"], [1, "list-group", "p-5"], ["class", "list-group-item ", 4, "ngFor", "ngForOf"], [1, "list-group-item"], ["class", "d-flex justify-content-between algin-items-center", 4, "ngFor", "ngForOf"], [1, "d-flex", "justify-content-between", "algin-items-center"], [1, ""], [2, "color", "green"]], template: function (i, o) { 1 & i && (x(0, "div", 0)(1, "h1", 1), A(2, "Order History"), y(), x(3, "ul", 2), Q(4, F4, 2, 1, "li", 3), y()()), 2 & i && (S(4), k("ngForOf", o.history)) }, dependencies: [Ir] }) } return t })() }]; let N4 = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ imports: [pE.forRoot(P4), pE] }) } return t })(); const L4 = ["addListener", "removeListener"], V4 = ["addEventListener", "removeEventListener"], B4 = ["on", "off"]; function Jr(t, n, e, i) { if (ne(e) && (i = e, e = void 0), i) return Jr(t, n, e).pipe(zp(i)); const [o, r] = function U4(t) { return ne(t.addEventListener) && ne(t.removeEventListener) }(t) ? V4.map(s => a => t[s](n, a, e)) : function j4(t) { return ne(t.addListener) && ne(t.removeListener) }(t) ? L4.map(cM(t, n)) : function H4(t) { return ne(t.on) && ne(t.off) }(t) ? B4.map(cM(t, n)) : []; if (!o && fu(t)) return We(s => Jr(s, n, e))(dt(t)); if (!o) throw new TypeError("Invalid event target"); return new xe(s => { const a = (...l) => s.next(1 < l.length ? l : l[0]); return o(a), () => r(a) }) } function cM(t, n) { return e => i => t[e](n, i) } const qa = { schedule(t) { let n = requestAnimationFrame, e = cancelAnimationFrame; const { delegate: i } = qa; i && (n = i.requestAnimationFrame, e = i.cancelAnimationFrame); const o = n(r => { e = void 0, t(r) }); return new Fe(() => e?.(o)) }, requestAnimationFrame(...t) { const { delegate: n } = qa; return (n?.requestAnimationFrame || requestAnimationFrame)(...t) }, cancelAnimationFrame(...t) { const { delegate: n } = qa; return (n?.cancelAnimationFrame || cancelAnimationFrame)(...t) }, delegate: void 0 }; new class $4 extends Up { flush(n) { this._active = !0; const e = this._scheduled; this._scheduled = void 0; const { actions: i } = this; let o; n = n || i.shift(); do { if (o = n.execute(n.state, n.delay)) break } while ((n = i[0]) && n.id === e && i.shift()); if (this._active = !1, o) { for (; (n = i[0]) && n.id === e && i.shift();)n.unsubscribe(); throw o } } }(class z4 extends jp { constructor(n, e) { super(n, e), this.scheduler = n, this.work = e } requestAsyncId(n, e, i = 0) { return null !== i && i > 0 ? super.requestAsyncId(n, e, i) : (n.actions.push(this), n._scheduled || (n._scheduled = qa.requestAnimationFrame(() => n.flush(void 0)))) } recycleAsyncId(n, e, i = 0) { var o; if (null != i ? i > 0 : this.delay > 0) return super.recycleAsyncId(n, e, i); const { actions: r } = n; null != e && (null === (o = r[r.length - 1]) || void 0 === o ? void 0 : o.id) !== e && (qa.cancelAnimationFrame(e), n._scheduled = void 0) } }); let Wm, q4 = 1; const Bd = {}; function dM(t) { return t in Bd && (delete Bd[t], !0) } const W4 = { setImmediate(t) { const n = q4++; return Bd[n] = !0, Wm || (Wm = Promise.resolve()), Wm.then(() => dM(n) && t()), n }, clearImmediate(t) { dM(t) } }, { setImmediate: Y4, clearImmediate: Z4 } = W4, jd = { setImmediate(...t) { const { delegate: n } = jd; return (n?.setImmediate || Y4)(...t) }, clearImmediate(t) { const { delegate: n } = jd; return (n?.clearImmediate || Z4)(t) }, delegate: void 0 }; new class K4 extends Up { flush(n) { this._active = !0; const e = this._scheduled; this._scheduled = void 0; const { actions: i } = this; let o; n = n || i.shift(); do { if (o = n.execute(n.state, n.delay)) break } while ((n = i[0]) && n.id === e && i.shift()); if (this._active = !1, o) { for (; (n = i[0]) && n.id === e && i.shift();)n.unsubscribe(); throw o } } }(class X4 extends jp { constructor(n, e) { super(n, e), this.scheduler = n, this.work = e } requestAsyncId(n, e, i = 0) { return null !== i && i > 0 ? super.requestAsyncId(n, e, i) : (n.actions.push(this), n._scheduled || (n._scheduled = jd.setImmediate(n.flush.bind(n, void 0)))) } recycleAsyncId(n, e, i = 0) { var o; if (null != i ? i > 0 : this.delay > 0) return super.recycleAsyncId(n, e, i); const { actions: r } = n; null != e && (null === (o = r[r.length - 1]) || void 0 === o ? void 0 : o.id) !== e && (jd.clearImmediate(e), n._scheduled === e && (n._scheduled = void 0)) } }); function uM(t = 0, n, e = ej) { let i = -1; return null != n && (Ug(n) ? e = n : i = n), new xe(o => { let r = function e5(t) { return t instanceof Date && !isNaN(t) }(t) ? +t - e.now() : t; r < 0 && (r = 0); let s = 0; return e.schedule(function () { o.closed || (o.next(s++), 0 <= i ? this.schedule(void 0, i) : o.complete()) }, r) }) } function hM(t, n = Yc) { return function J4(t) { return Pe((n, e) => { let i = !1, o = null, r = null, s = !1; const a = () => { if (r?.unsubscribe(), r = null, i) { i = !1; const c = o; o = null, e.next(c) } s && e.complete() }, l = () => { r = null, s && e.complete() }; n.subscribe(Ie(e, c => { i = !0, o = c, r || dt(t(c)).subscribe(r = Ie(e, a, l)) }, () => { s = !0, (!i || !r || r.closed) && e.complete() })) }) }(() => uM(t, n)) } let n5 = (() => { class t { constructor(e, i, o) { this._ngZone = e, this._platform = i, this._scrolled = new ie, this._globalSubscription = null, this._scrolledCount = 0, this.scrollContainers = new Map, this._document = o } register(e) { this.scrollContainers.has(e) || this.scrollContainers.set(e, e.elementScrolled().subscribe(() => this._scrolled.next(e))) } deregister(e) { const i = this.scrollContainers.get(e); i && (i.unsubscribe(), this.scrollContainers.delete(e)) } scrolled(e = 20) { return this._platform.isBrowser ? new xe(i => { this._globalSubscription || this._addGlobalListener(); const o = e > 0 ? this._scrolled.pipe(hM(e)).subscribe(i) : this._scrolled.subscribe(i); return this._scrolledCount++, () => { o.unsubscribe(), this._scrolledCount--, this._scrolledCount || this._removeGlobalListener() } }) : N() } ngOnDestroy() { this._removeGlobalListener(), this.scrollContainers.forEach((e, i) => this.deregister(i)), this._scrolled.complete() } ancestorScrolled(e, i) { const o = this.getAncestorScrollContainers(e); return this.scrolled(i).pipe(at(r => !r || o.indexOf(r) > -1)) } getAncestorScrollContainers(e) { const i = []; return this.scrollContainers.forEach((o, r) => { this._scrollableContainsElement(r, e) && i.push(r) }), i } _getWindow() { return this._document.defaultView || window } _scrollableContainsElement(e, i) { let o = Ri(i), r = e.getElementRef().nativeElement; do { if (o == r) return !0 } while (o = o.parentElement); return !1 } _addGlobalListener() { this._globalSubscription = this._ngZone.runOutsideAngular(() => Jr(this._getWindow().document, "scroll").subscribe(() => this._scrolled.next())) } _removeGlobalListener() { this._globalSubscription && (this._globalSubscription.unsubscribe(), this._globalSubscription = null) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(z), w(Bt), w(te, 8)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), Ym = (() => { class t { constructor(e, i, o) { this._platform = e, this._change = new ie, this._changeListener = r => { this._change.next(r) }, this._document = o, i.runOutsideAngular(() => { if (e.isBrowser) { const r = this._getWindow(); r.addEventListener("resize", this._changeListener), r.addEventListener("orientationchange", this._changeListener) } this.change().subscribe(() => this._viewportSize = null) }) } ngOnDestroy() { if (this._platform.isBrowser) { const e = this._getWindow(); e.removeEventListener("resize", this._changeListener), e.removeEventListener("orientationchange", this._changeListener) } this._change.complete() } getViewportSize() { this._viewportSize || this._updateViewportSize(); const e = { width: this._viewportSize.width, height: this._viewportSize.height }; return this._platform.isBrowser || (this._viewportSize = null), e } getViewportRect() { const e = this.getViewportScrollPosition(), { width: i, height: o } = this.getViewportSize(); return { top: e.top, left: e.left, bottom: e.top + o, right: e.left + i, height: o, width: i } } getViewportScrollPosition() { if (!this._platform.isBrowser) return { top: 0, left: 0 }; const e = this._document, i = this._getWindow(), o = e.documentElement, r = o.getBoundingClientRect(); return { top: -r.top || e.body.scrollTop || i.scrollY || o.scrollTop || 0, left: -r.left || e.body.scrollLeft || i.scrollX || o.scrollLeft || 0 } } change(e = 20) { return e > 0 ? this._change.pipe(hM(e)) : this._change } _getWindow() { return this._document.defaultView || window } _updateViewportSize() { const e = this._getWindow(); this._viewportSize = this._platform.isBrowser ? { width: e.innerWidth, height: e.innerHeight } : { width: 0, height: 0 } } static #e = this.\u0275fac = function (i) { return new (i || t)(w(Bt), w(z), w(te, 8)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), Hd = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({}) } return t })(), fM = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ imports: [_a, Hd, _a, Hd] }) } return t })(); class Zm { attach(n) { return this._attachedHost = n, n.attach(this) } detach() { let n = this._attachedHost; null != n && (this._attachedHost = null, n.detach()) } get isAttached() { return null != this._attachedHost } setAttachedHost(n) { this._attachedHost = n } } class r5 extends Zm { constructor(n, e, i, o, r) { super(), this.component = n, this.viewContainerRef = e, this.injector = i, this.componentFactoryResolver = o, this.projectableNodes = r } } class pM extends Zm { constructor(n, e, i, o) { super(), this.templateRef = n, this.viewContainerRef = e, this.context = i, this.injector = o } get origin() { return this.templateRef.elementRef } attach(n, e = this.context) { return this.context = e, super.attach(n) } detach() { return this.context = void 0, super.detach() } } class s5 extends Zm { constructor(n) { super(), this.element = n instanceof ye ? n.nativeElement : n } } class a5 { constructor() { this._isDisposed = !1, this.attachDomPortal = null } hasAttached() { return !!this._attachedPortal } attach(n) { return n instanceof r5 ? (this._attachedPortal = n, this.attachComponentPortal(n)) : n instanceof pM ? (this._attachedPortal = n, this.attachTemplatePortal(n)) : this.attachDomPortal && n instanceof s5 ? (this._attachedPortal = n, this.attachDomPortal(n)) : void 0 } detach() { this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn() } dispose() { this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0 } setDisposeFn(n) { this._disposeFn = n } _invokeDisposeFn() { this._disposeFn && (this._disposeFn(), this._disposeFn = null) } } class l5 extends a5 { constructor(n, e, i, o, r) { super(), this.outletElement = n, this._componentFactoryResolver = e, this._appRef = i, this._defaultInjector = o, this.attachDomPortal = s => { const a = s.element, l = this._document.createComment("dom-portal"); a.parentNode.insertBefore(l, a), this.outletElement.appendChild(a), this._attachedPortal = s, super.setDisposeFn(() => { l.parentNode && l.parentNode.replaceChild(a, l) }) }, this._document = r } attachComponentPortal(n) { const i = (n.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(n.component); let o; return n.viewContainerRef ? (o = n.viewContainerRef.createComponent(i, n.viewContainerRef.length, n.injector || n.viewContainerRef.injector, n.projectableNodes || void 0), this.setDisposeFn(() => o.destroy())) : (o = i.create(n.injector || this._defaultInjector || ft.NULL), this._appRef.attachView(o.hostView), this.setDisposeFn(() => { this._appRef.viewCount > 0 && this._appRef.detachView(o.hostView), o.destroy() })), this.outletElement.appendChild(this._getComponentRootNode(o)), this._attachedPortal = n, o } attachTemplatePortal(n) { let e = n.viewContainerRef, i = e.createEmbeddedView(n.templateRef, n.context, { injector: n.injector }); return i.rootNodes.forEach(o => this.outletElement.appendChild(o)), i.detectChanges(), this.setDisposeFn(() => { let o = e.indexOf(i); -1 !== o && e.remove(o) }), this._attachedPortal = n, i } dispose() { super.dispose(), this.outletElement.remove() } _getComponentRootNode(n) { return n.hostView.rootNodes[0] } } let c5 = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({}) } return t })(); const mM = FB(); class d5 { constructor(n, e) { this._viewportRuler = n, this._previousHTMLStyles = { top: "", left: "" }, this._isEnabled = !1, this._document = e } attach() { } enable() { if (this._canBeEnabled()) { const n = this._document.documentElement; this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition(), this._previousHTMLStyles.left = n.style.left || "", this._previousHTMLStyles.top = n.style.top || "", n.style.left = Ge(-this._previousScrollPosition.left), n.style.top = Ge(-this._previousScrollPosition.top), n.classList.add("cdk-global-scrollblock"), this._isEnabled = !0 } } disable() { if (this._isEnabled) { const n = this._document.documentElement, i = n.style, o = this._document.body.style, r = i.scrollBehavior || "", s = o.scrollBehavior || ""; this._isEnabled = !1, i.left = this._previousHTMLStyles.left, i.top = this._previousHTMLStyles.top, n.classList.remove("cdk-global-scrollblock"), mM && (i.scrollBehavior = o.scrollBehavior = "auto"), window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top), mM && (i.scrollBehavior = r, o.scrollBehavior = s) } } _canBeEnabled() { if (this._document.documentElement.classList.contains("cdk-global-scrollblock") || this._isEnabled) return !1; const e = this._document.body, i = this._viewportRuler.getViewportSize(); return e.scrollHeight > i.height || e.scrollWidth > i.width } } class u5 { constructor(n, e, i, o) { this._scrollDispatcher = n, this._ngZone = e, this._viewportRuler = i, this._config = o, this._scrollSubscription = null, this._detach = () => { this.disable(), this._overlayRef.hasAttached() && this._ngZone.run(() => this._overlayRef.detach()) } } attach(n) { this._overlayRef = n } enable() { if (this._scrollSubscription) return; const n = this._scrollDispatcher.scrolled(0).pipe(at(e => !e || !this._overlayRef.overlayElement.contains(e.getElementRef().nativeElement))); this._config && this._config.threshold && this._config.threshold > 1 ? (this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top, this._scrollSubscription = n.subscribe(() => { const e = this._viewportRuler.getViewportScrollPosition().top; Math.abs(e - this._initialScrollPosition) > this._config.threshold ? this._detach() : this._overlayRef.updatePosition() })) : this._scrollSubscription = n.subscribe(this._detach) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } class gM { enable() { } disable() { } attach() { } } function Xm(t, n) { return n.some(e => t.bottom < e.top || t.top > e.bottom || t.right < e.left || t.left > e.right) } function _M(t, n) { return n.some(e => t.top < e.top || t.bottom > e.bottom || t.left < e.left || t.right > e.right) } class h5 { constructor(n, e, i, o) { this._scrollDispatcher = n, this._viewportRuler = e, this._ngZone = i, this._config = o, this._scrollSubscription = null } attach(n) { this._overlayRef = n } enable() { this._scrollSubscription || (this._scrollSubscription = this._scrollDispatcher.scrolled(this._config ? this._config.scrollThrottle : 0).subscribe(() => { if (this._overlayRef.updatePosition(), this._config && this._config.autoClose) { const e = this._overlayRef.overlayElement.getBoundingClientRect(), { width: i, height: o } = this._viewportRuler.getViewportSize(); Xm(e, [{ width: i, height: o, bottom: o, right: i, top: 0, left: 0 }]) && (this.disable(), this._ngZone.run(() => this._overlayRef.detach())) } })) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } let f5 = (() => { class t { constructor(e, i, o, r) { this._scrollDispatcher = e, this._viewportRuler = i, this._ngZone = o, this.noop = () => new gM, this.close = s => new u5(this._scrollDispatcher, this._ngZone, this._viewportRuler, s), this.block = () => new d5(this._viewportRuler, this._document), this.reposition = s => new h5(this._scrollDispatcher, this._viewportRuler, this._ngZone, s), this._document = r } static #e = this.\u0275fac = function (i) { return new (i || t)(w(n5), w(Ym), w(z), w(te)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); class vM { constructor(n) { if (this.scrollStrategy = new gM, this.panelClass = "", this.hasBackdrop = !1, this.backdropClass = "cdk-overlay-dark-backdrop", this.disposeOnNavigation = !1, n) { const e = Object.keys(n); for (const i of e) void 0 !== n[i] && (this[i] = n[i]) } } } class p5 { constructor(n, e) { this.connectionPair = n, this.scrollableViewProperties = e } } let bM = (() => { class t { constructor(e) { this._attachedOverlays = [], this._document = e } ngOnDestroy() { this.detach() } add(e) { this.remove(e), this._attachedOverlays.push(e) } remove(e) { const i = this._attachedOverlays.indexOf(e); i > -1 && this._attachedOverlays.splice(i, 1), 0 === this._attachedOverlays.length && this.detach() } static #e = this.\u0275fac = function (i) { return new (i || t)(w(te)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), m5 = (() => { class t extends bM { constructor(e, i) { super(e), this._ngZone = i, this._keydownListener = o => { const r = this._attachedOverlays; for (let s = r.length - 1; s > -1; s--)if (r[s]._keydownEvents.observers.length > 0) { const a = r[s]._keydownEvents; this._ngZone ? this._ngZone.run(() => a.next(o)) : a.next(o); break } } } add(e) { super.add(e), this._isAttached || (this._ngZone ? this._ngZone.runOutsideAngular(() => this._document.body.addEventListener("keydown", this._keydownListener)) : this._document.body.addEventListener("keydown", this._keydownListener), this._isAttached = !0) } detach() { this._isAttached && (this._document.body.removeEventListener("keydown", this._keydownListener), this._isAttached = !1) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(te), w(z, 8)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), g5 = (() => { class t extends bM { constructor(e, i, o) { super(e), this._platform = i, this._ngZone = o, this._cursorStyleIsSet = !1, this._pointerDownListener = r => { this._pointerDownEventTarget = li(r) }, this._clickListener = r => { const s = li(r), a = "click" === r.type && this._pointerDownEventTarget ? this._pointerDownEventTarget : s; this._pointerDownEventTarget = null; const l = this._attachedOverlays.slice(); for (let c = l.length - 1; c > -1; c--) { const d = l[c]; if (d._outsidePointerEvents.observers.length < 1 || !d.hasAttached()) continue; if (d.overlayElement.contains(s) || d.overlayElement.contains(a)) break; const u = d._outsidePointerEvents; this._ngZone ? this._ngZone.run(() => u.next(r)) : u.next(r) } } } add(e) { if (super.add(e), !this._isAttached) { const i = this._document.body; this._ngZone ? this._ngZone.runOutsideAngular(() => this._addEventListeners(i)) : this._addEventListeners(i), this._platform.IOS && !this._cursorStyleIsSet && (this._cursorOriginalValue = i.style.cursor, i.style.cursor = "pointer", this._cursorStyleIsSet = !0), this._isAttached = !0 } } detach() { if (this._isAttached) { const e = this._document.body; e.removeEventListener("pointerdown", this._pointerDownListener, !0), e.removeEventListener("click", this._clickListener, !0), e.removeEventListener("auxclick", this._clickListener, !0), e.removeEventListener("contextmenu", this._clickListener, !0), this._platform.IOS && this._cursorStyleIsSet && (e.style.cursor = this._cursorOriginalValue, this._cursorStyleIsSet = !1), this._isAttached = !1 } } _addEventListeners(e) { e.addEventListener("pointerdown", this._pointerDownListener, !0), e.addEventListener("click", this._clickListener, !0), e.addEventListener("auxclick", this._clickListener, !0), e.addEventListener("contextmenu", this._clickListener, !0) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(te), w(Bt), w(z, 8)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), yM = (() => { class t { constructor(e, i) { this._platform = i, this._document = e } ngOnDestroy() { this._containerElement?.remove() } getContainerElement() { return this._containerElement || this._createContainer(), this._containerElement } _createContainer() { const e = "cdk-overlay-container"; if (this._platform.isBrowser || Vp()) { const o = this._document.querySelectorAll(`.${e}[platform="server"], .${e}[platform="test"]`); for (let r = 0; r < o.length; r++)o[r].remove() } const i = this._document.createElement("div"); i.classList.add(e), Vp() ? i.setAttribute("platform", "test") : this._platform.isBrowser || i.setAttribute("platform", "server"), this._document.body.appendChild(i), this._containerElement = i } static #e = this.\u0275fac = function (i) { return new (i || t)(w(te), w(Bt)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); class _5 { constructor(n, e, i, o, r, s, a, l, c, d = !1) { this._portalOutlet = n, this._host = e, this._pane = i, this._config = o, this._ngZone = r, this._keyboardDispatcher = s, this._document = a, this._location = l, this._outsideClickDispatcher = c, this._animationsDisabled = d, this._backdropElement = null, this._backdropClick = new ie, this._attachments = new ie, this._detachments = new ie, this._locationChanges = Fe.EMPTY, this._backdropClickHandler = u => this._backdropClick.next(u), this._backdropTransitionendHandler = u => { this._disposeBackdrop(u.target) }, this._keydownEvents = new ie, this._outsidePointerEvents = new ie, o.scrollStrategy && (this._scrollStrategy = o.scrollStrategy, this._scrollStrategy.attach(this)), this._positionStrategy = o.positionStrategy } get overlayElement() { return this._pane } get backdropElement() { return this._backdropElement } get hostElement() { return this._host } attach(n) { !this._host.parentElement && this._previousHostParent && this._previousHostParent.appendChild(this._host); const e = this._portalOutlet.attach(n); return this._positionStrategy && this._positionStrategy.attach(this), this._updateStackingOrder(), this._updateElementSize(), this._updateElementDirection(), this._scrollStrategy && this._scrollStrategy.enable(), this._ngZone.onStable.pipe(St(1)).subscribe(() => { this.hasAttached() && this.updatePosition() }), this._togglePointerEvents(!0), this._config.hasBackdrop && this._attachBackdrop(), this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !0), this._attachments.next(), this._keyboardDispatcher.add(this), this._config.disposeOnNavigation && (this._locationChanges = this._location.subscribe(() => this.dispose())), this._outsideClickDispatcher.add(this), "function" == typeof e?.onDestroy && e.onDestroy(() => { this.hasAttached() && this._ngZone.runOutsideAngular(() => Promise.resolve().then(() => this.detach())) }), e } detach() { if (!this.hasAttached()) return; this.detachBackdrop(), this._togglePointerEvents(!1), this._positionStrategy && this._positionStrategy.detach && this._positionStrategy.detach(), this._scrollStrategy && this._scrollStrategy.disable(); const n = this._portalOutlet.detach(); return this._detachments.next(), this._keyboardDispatcher.remove(this), this._detachContentWhenStable(), this._locationChanges.unsubscribe(), this._outsideClickDispatcher.remove(this), n } dispose() { const n = this.hasAttached(); this._positionStrategy && this._positionStrategy.dispose(), this._disposeScrollStrategy(), this._disposeBackdrop(this._backdropElement), this._locationChanges.unsubscribe(), this._keyboardDispatcher.remove(this), this._portalOutlet.dispose(), this._attachments.complete(), this._backdropClick.complete(), this._keydownEvents.complete(), this._outsidePointerEvents.complete(), this._outsideClickDispatcher.remove(this), this._host?.remove(), this._previousHostParent = this._pane = this._host = null, n && this._detachments.next(), this._detachments.complete() } hasAttached() { return this._portalOutlet.hasAttached() } backdropClick() { return this._backdropClick } attachments() { return this._attachments } detachments() { return this._detachments } keydownEvents() { return this._keydownEvents } outsidePointerEvents() { return this._outsidePointerEvents } getConfig() { return this._config } updatePosition() { this._positionStrategy && this._positionStrategy.apply() } updatePositionStrategy(n) { n !== this._positionStrategy && (this._positionStrategy && this._positionStrategy.dispose(), this._positionStrategy = n, this.hasAttached() && (n.attach(this), this.updatePosition())) } updateSize(n) { this._config = { ...this._config, ...n }, this._updateElementSize() } setDirection(n) { this._config = { ...this._config, direction: n }, this._updateElementDirection() } addPanelClass(n) { this._pane && this._toggleClasses(this._pane, n, !0) } removePanelClass(n) { this._pane && this._toggleClasses(this._pane, n, !1) } getDirection() { const n = this._config.direction; return n ? "string" == typeof n ? n : n.value : "ltr" } updateScrollStrategy(n) { n !== this._scrollStrategy && (this._disposeScrollStrategy(), this._scrollStrategy = n, this.hasAttached() && (n.attach(this), n.enable())) } _updateElementDirection() { this._host.setAttribute("dir", this.getDirection()) } _updateElementSize() { if (!this._pane) return; const n = this._pane.style; n.width = Ge(this._config.width), n.height = Ge(this._config.height), n.minWidth = Ge(this._config.minWidth), n.minHeight = Ge(this._config.minHeight), n.maxWidth = Ge(this._config.maxWidth), n.maxHeight = Ge(this._config.maxHeight) } _togglePointerEvents(n) { this._pane.style.pointerEvents = n ? "" : "none" } _attachBackdrop() { const n = "cdk-overlay-backdrop-showing"; this._backdropElement = this._document.createElement("div"), this._backdropElement.classList.add("cdk-overlay-backdrop"), this._animationsDisabled && this._backdropElement.classList.add("cdk-overlay-backdrop-noop-animation"), this._config.backdropClass && this._toggleClasses(this._backdropElement, this._config.backdropClass, !0), this._host.parentElement.insertBefore(this._backdropElement, this._host), this._backdropElement.addEventListener("click", this._backdropClickHandler), !this._animationsDisabled && typeof requestAnimationFrame < "u" ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => { this._backdropElement && this._backdropElement.classList.add(n) }) }) : this._backdropElement.classList.add(n) } _updateStackingOrder() { this._host.nextSibling && this._host.parentNode.appendChild(this._host) } detachBackdrop() { const n = this._backdropElement; if (n) { if (this._animationsDisabled) return void this._disposeBackdrop(n); n.classList.remove("cdk-overlay-backdrop-showing"), this._ngZone.runOutsideAngular(() => { n.addEventListener("transitionend", this._backdropTransitionendHandler) }), n.style.pointerEvents = "none", this._backdropTimeout = this._ngZone.runOutsideAngular(() => setTimeout(() => { this._disposeBackdrop(n) }, 500)) } } _toggleClasses(n, e, i) { const o = Zc(e || []).filter(r => !!r); o.length && (i ? n.classList.add(...o) : n.classList.remove(...o)) } _detachContentWhenStable() { this._ngZone.runOutsideAngular(() => { const n = this._ngZone.onStable.pipe(Ti($i(this._attachments, this._detachments))).subscribe(() => { (!this._pane || !this._host || 0 === this._pane.children.length) && (this._pane && this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !1), this._host && this._host.parentElement && (this._previousHostParent = this._host.parentElement, this._host.remove()), n.unsubscribe()) }) }) } _disposeScrollStrategy() { const n = this._scrollStrategy; n && (n.disable(), n.detach && n.detach()) } _disposeBackdrop(n) { n && (n.removeEventListener("click", this._backdropClickHandler), n.removeEventListener("transitionend", this._backdropTransitionendHandler), n.remove(), this._backdropElement === n && (this._backdropElement = null)), this._backdropTimeout && (clearTimeout(this._backdropTimeout), this._backdropTimeout = void 0) } } const wM = "cdk-overlay-connected-position-bounding-box", v5 = /([A-Za-z%]+)$/; class b5 { get positions() { return this._preferredPositions } constructor(n, e, i, o, r) { this._viewportRuler = e, this._document = i, this._platform = o, this._overlayContainer = r, this._lastBoundingBoxSize = { width: 0, height: 0 }, this._isPushed = !1, this._canPush = !0, this._growAfterOpen = !1, this._hasFlexibleDimensions = !0, this._positionLocked = !1, this._viewportMargin = 0, this._scrollables = [], this._preferredPositions = [], this._positionChanges = new ie, this._resizeSubscription = Fe.EMPTY, this._offsetX = 0, this._offsetY = 0, this._appliedPanelClasses = [], this.positionChanges = this._positionChanges, this.setOrigin(n) } attach(n) { this._validatePositions(), n.hostElement.classList.add(wM), this._overlayRef = n, this._boundingBox = n.hostElement, this._pane = n.overlayElement, this._isDisposed = !1, this._isInitialRender = !0, this._lastPosition = null, this._resizeSubscription.unsubscribe(), this._resizeSubscription = this._viewportRuler.change().subscribe(() => { this._isInitialRender = !0, this.apply() }) } apply() { if (this._isDisposed || !this._platform.isBrowser) return; if (!this._isInitialRender && this._positionLocked && this._lastPosition) return void this.reapplyLastPosition(); this._clearPanelClasses(), this._resetOverlayElementStyles(), this._resetBoundingBoxStyles(), this._viewportRect = this._getNarrowedViewportRect(), this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect(); const n = this._originRect, e = this._overlayRect, i = this._viewportRect, o = this._containerRect, r = []; let s; for (let a of this._preferredPositions) { let l = this._getOriginPoint(n, o, a), c = this._getOverlayPoint(l, e, a), d = this._getOverlayFit(c, e, i, a); if (d.isCompletelyWithinViewport) return this._isPushed = !1, void this._applyPosition(a, l); this._canFitWithFlexibleDimensions(d, c, i) ? r.push({ position: a, origin: l, overlayRect: e, boundingBoxRect: this._calculateBoundingBoxRect(l, a) }) : (!s || s.overlayFit.visibleArea < d.visibleArea) && (s = { overlayFit: d, overlayPoint: c, originPoint: l, position: a, overlayRect: e }) } if (r.length) { let a = null, l = -1; for (const c of r) { const d = c.boundingBoxRect.width * c.boundingBoxRect.height * (c.position.weight || 1); d > l && (l = d, a = c) } return this._isPushed = !1, void this._applyPosition(a.position, a.origin) } if (this._canPush) return this._isPushed = !0, void this._applyPosition(s.position, s.originPoint); this._applyPosition(s.position, s.originPoint) } detach() { this._clearPanelClasses(), this._lastPosition = null, this._previousPushAmount = null, this._resizeSubscription.unsubscribe() } dispose() { this._isDisposed || (this._boundingBox && xo(this._boundingBox.style, { top: "", left: "", right: "", bottom: "", height: "", width: "", alignItems: "", justifyContent: "" }), this._pane && this._resetOverlayElementStyles(), this._overlayRef && this._overlayRef.hostElement.classList.remove(wM), this.detach(), this._positionChanges.complete(), this._overlayRef = this._boundingBox = null, this._isDisposed = !0) } reapplyLastPosition() { if (this._isDisposed || !this._platform.isBrowser) return; const n = this._lastPosition; if (n) { this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._viewportRect = this._getNarrowedViewportRect(), this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect(); const e = this._getOriginPoint(this._originRect, this._containerRect, n); this._applyPosition(n, e) } else this.apply() } withScrollableContainers(n) { return this._scrollables = n, this } withPositions(n) { return this._preferredPositions = n, -1 === n.indexOf(this._lastPosition) && (this._lastPosition = null), this._validatePositions(), this } withViewportMargin(n) { return this._viewportMargin = n, this } withFlexibleDimensions(n = !0) { return this._hasFlexibleDimensions = n, this } withGrowAfterOpen(n = !0) { return this._growAfterOpen = n, this } withPush(n = !0) { return this._canPush = n, this } withLockedPosition(n = !0) { return this._positionLocked = n, this } setOrigin(n) { return this._origin = n, this } withDefaultOffsetX(n) { return this._offsetX = n, this } withDefaultOffsetY(n) { return this._offsetY = n, this } withTransformOriginOn(n) { return this._transformOriginSelector = n, this } _getOriginPoint(n, e, i) { let o, r; if ("center" == i.originX) o = n.left + n.width / 2; else { const s = this._isRtl() ? n.right : n.left, a = this._isRtl() ? n.left : n.right; o = "start" == i.originX ? s : a } return e.left < 0 && (o -= e.left), r = "center" == i.originY ? n.top + n.height / 2 : "top" == i.originY ? n.top : n.bottom, e.top < 0 && (r -= e.top), { x: o, y: r } } _getOverlayPoint(n, e, i) { let o, r; return o = "center" == i.overlayX ? -e.width / 2 : "start" === i.overlayX ? this._isRtl() ? -e.width : 0 : this._isRtl() ? 0 : -e.width, r = "center" == i.overlayY ? -e.height / 2 : "top" == i.overlayY ? 0 : -e.height, { x: n.x + o, y: n.y + r } } _getOverlayFit(n, e, i, o) { const r = CM(e); let { x: s, y: a } = n, l = this._getOffset(o, "x"), c = this._getOffset(o, "y"); l && (s += l), c && (a += c); let h = 0 - a, f = a + r.height - i.height, p = this._subtractOverflows(r.width, 0 - s, s + r.width - i.width), m = this._subtractOverflows(r.height, h, f), _ = p * m; return { visibleArea: _, isCompletelyWithinViewport: r.width * r.height === _, fitsInViewportVertically: m === r.height, fitsInViewportHorizontally: p == r.width } } _canFitWithFlexibleDimensions(n, e, i) { if (this._hasFlexibleDimensions) { const o = i.bottom - e.y, r = i.right - e.x, s = xM(this._overlayRef.getConfig().minHeight), a = xM(this._overlayRef.getConfig().minWidth); return (n.fitsInViewportVertically || null != s && s <= o) && (n.fitsInViewportHorizontally || null != a && a <= r) } return !1 } _pushOverlayOnScreen(n, e, i) { if (this._previousPushAmount && this._positionLocked) return { x: n.x + this._previousPushAmount.x, y: n.y + this._previousPushAmount.y }; const o = CM(e), r = this._viewportRect, s = Math.max(n.x + o.width - r.width, 0), a = Math.max(n.y + o.height - r.height, 0), l = Math.max(r.top - i.top - n.y, 0), c = Math.max(r.left - i.left - n.x, 0); let d = 0, u = 0; return d = o.width <= r.width ? c || -s : n.x < this._viewportMargin ? r.left - i.left - n.x : 0, u = o.height <= r.height ? l || -a : n.y < this._viewportMargin ? r.top - i.top - n.y : 0, this._previousPushAmount = { x: d, y: u }, { x: n.x + d, y: n.y + u } } _applyPosition(n, e) { if (this._setTransformOrigin(n), this._setOverlayElementStyles(e, n), this._setBoundingBoxStyles(e, n), n.panelClass && this._addPanelClasses(n.panelClass), this._lastPosition = n, this._positionChanges.observers.length) { const i = this._getScrollVisibility(), o = new p5(n, i); this._positionChanges.next(o) } this._isInitialRender = !1 } _setTransformOrigin(n) { if (!this._transformOriginSelector) return; const e = this._boundingBox.querySelectorAll(this._transformOriginSelector); let i, o = n.overlayY; i = "center" === n.overlayX ? "center" : this._isRtl() ? "start" === n.overlayX ? "right" : "left" : "start" === n.overlayX ? "left" : "right"; for (let r = 0; r < e.length; r++)e[r].style.transformOrigin = `${i} ${o}` } _calculateBoundingBoxRect(n, e) { const i = this._viewportRect, o = this._isRtl(); let r, s, a, d, u, h; if ("top" === e.overlayY) s = n.y, r = i.height - s + this._viewportMargin; else if ("bottom" === e.overlayY) a = i.height - n.y + 2 * this._viewportMargin, r = i.height - a + this._viewportMargin; else { const f = Math.min(i.bottom - n.y + i.top, n.y), p = this._lastBoundingBoxSize.height; r = 2 * f, s = n.y - f, r > p && !this._isInitialRender && !this._growAfterOpen && (s = n.y - p / 2) } if ("end" === e.overlayX && !o || "start" === e.overlayX && o) h = i.width - n.x + this._viewportMargin, d = n.x - this._viewportMargin; else if ("start" === e.overlayX && !o || "end" === e.overlayX && o) u = n.x, d = i.right - n.x; else { const f = Math.min(i.right - n.x + i.left, n.x), p = this._lastBoundingBoxSize.width; d = 2 * f, u = n.x - f, d > p && !this._isInitialRender && !this._growAfterOpen && (u = n.x - p / 2) } return { top: s, left: u, bottom: a, right: h, width: d, height: r } } _setBoundingBoxStyles(n, e) { const i = this._calculateBoundingBoxRect(n, e); !this._isInitialRender && !this._growAfterOpen && (i.height = Math.min(i.height, this._lastBoundingBoxSize.height), i.width = Math.min(i.width, this._lastBoundingBoxSize.width)); const o = {}; if (this._hasExactPosition()) o.top = o.left = "0", o.bottom = o.right = o.maxHeight = o.maxWidth = "", o.width = o.height = "100%"; else { const r = this._overlayRef.getConfig().maxHeight, s = this._overlayRef.getConfig().maxWidth; o.height = Ge(i.height), o.top = Ge(i.top), o.bottom = Ge(i.bottom), o.width = Ge(i.width), o.left = Ge(i.left), o.right = Ge(i.right), o.alignItems = "center" === e.overlayX ? "center" : "end" === e.overlayX ? "flex-end" : "flex-start", o.justifyContent = "center" === e.overlayY ? "center" : "bottom" === e.overlayY ? "flex-end" : "flex-start", r && (o.maxHeight = Ge(r)), s && (o.maxWidth = Ge(s)) } this._lastBoundingBoxSize = i, xo(this._boundingBox.style, o) } _resetBoundingBoxStyles() { xo(this._boundingBox.style, { top: "0", left: "0", right: "0", bottom: "0", height: "", width: "", alignItems: "", justifyContent: "" }) } _resetOverlayElementStyles() { xo(this._pane.style, { top: "", left: "", bottom: "", right: "", position: "", transform: "" }) } _setOverlayElementStyles(n, e) { const i = {}, o = this._hasExactPosition(), r = this._hasFlexibleDimensions, s = this._overlayRef.getConfig(); if (o) { const d = this._viewportRuler.getViewportScrollPosition(); xo(i, this._getExactOverlayY(e, n, d)), xo(i, this._getExactOverlayX(e, n, d)) } else i.position = "static"; let a = "", l = this._getOffset(e, "x"), c = this._getOffset(e, "y"); l && (a += `translateX(${l}px) `), c && (a += `translateY(${c}px)`), i.transform = a.trim(), s.maxHeight && (o ? i.maxHeight = Ge(s.maxHeight) : r && (i.maxHeight = "")), s.maxWidth && (o ? i.maxWidth = Ge(s.maxWidth) : r && (i.maxWidth = "")), xo(this._pane.style, i) } _getExactOverlayY(n, e, i) { let o = { top: "", bottom: "" }, r = this._getOverlayPoint(e, this._overlayRect, n); return this._isPushed && (r = this._pushOverlayOnScreen(r, this._overlayRect, i)), "bottom" === n.overlayY ? o.bottom = this._document.documentElement.clientHeight - (r.y + this._overlayRect.height) + "px" : o.top = Ge(r.y), o } _getExactOverlayX(n, e, i) { let s, o = { left: "", right: "" }, r = this._getOverlayPoint(e, this._overlayRect, n); return this._isPushed && (r = this._pushOverlayOnScreen(r, this._overlayRect, i)), s = this._isRtl() ? "end" === n.overlayX ? "left" : "right" : "end" === n.overlayX ? "right" : "left", "right" === s ? o.right = this._document.documentElement.clientWidth - (r.x + this._overlayRect.width) + "px" : o.left = Ge(r.x), o } _getScrollVisibility() { const n = this._getOriginRect(), e = this._pane.getBoundingClientRect(), i = this._scrollables.map(o => o.getElementRef().nativeElement.getBoundingClientRect()); return { isOriginClipped: _M(n, i), isOriginOutsideView: Xm(n, i), isOverlayClipped: _M(e, i), isOverlayOutsideView: Xm(e, i) } } _subtractOverflows(n, ...e) { return e.reduce((i, o) => i - Math.max(o, 0), n) } _getNarrowedViewportRect() { const n = this._document.documentElement.clientWidth, e = this._document.documentElement.clientHeight, i = this._viewportRuler.getViewportScrollPosition(); return { top: i.top + this._viewportMargin, left: i.left + this._viewportMargin, right: i.left + n - this._viewportMargin, bottom: i.top + e - this._viewportMargin, width: n - 2 * this._viewportMargin, height: e - 2 * this._viewportMargin } } _isRtl() { return "rtl" === this._overlayRef.getDirection() } _hasExactPosition() { return !this._hasFlexibleDimensions || this._isPushed } _getOffset(n, e) { return "x" === e ? null == n.offsetX ? this._offsetX : n.offsetX : null == n.offsetY ? this._offsetY : n.offsetY } _validatePositions() { } _addPanelClasses(n) { this._pane && Zc(n).forEach(e => { "" !== e && -1 === this._appliedPanelClasses.indexOf(e) && (this._appliedPanelClasses.push(e), this._pane.classList.add(e)) }) } _clearPanelClasses() { this._pane && (this._appliedPanelClasses.forEach(n => { this._pane.classList.remove(n) }), this._appliedPanelClasses = []) } _getOriginRect() { const n = this._origin; if (n instanceof ye) return n.nativeElement.getBoundingClientRect(); if (n instanceof Element) return n.getBoundingClientRect(); const e = n.width || 0, i = n.height || 0; return { top: n.y, bottom: n.y + i, left: n.x, right: n.x + e, height: i, width: e } } } function xo(t, n) { for (let e in n) n.hasOwnProperty(e) && (t[e] = n[e]); return t } function xM(t) { if ("number" != typeof t && null != t) { const [n, e] = t.split(v5); return e && "px" !== e ? null : parseFloat(n) } return t || null } function CM(t) { return { top: Math.floor(t.top), right: Math.floor(t.right), bottom: Math.floor(t.bottom), left: Math.floor(t.left), width: Math.floor(t.width), height: Math.floor(t.height) } } const DM = "cdk-global-overlay-wrapper"; class y5 { constructor() { this._cssPosition = "static", this._topOffset = "", this._bottomOffset = "", this._alignItems = "", this._xPosition = "", this._xOffset = "", this._width = "", this._height = "", this._isDisposed = !1 } attach(n) { const e = n.getConfig(); this._overlayRef = n, this._width && !e.width && n.updateSize({ width: this._width }), this._height && !e.height && n.updateSize({ height: this._height }), n.hostElement.classList.add(DM), this._isDisposed = !1 } top(n = "") { return this._bottomOffset = "", this._topOffset = n, this._alignItems = "flex-start", this } left(n = "") { return this._xOffset = n, this._xPosition = "left", this } bottom(n = "") { return this._topOffset = "", this._bottomOffset = n, this._alignItems = "flex-end", this } right(n = "") { return this._xOffset = n, this._xPosition = "right", this } start(n = "") { return this._xOffset = n, this._xPosition = "start", this } end(n = "") { return this._xOffset = n, this._xPosition = "end", this } width(n = "") { return this._overlayRef ? this._overlayRef.updateSize({ width: n }) : this._width = n, this } height(n = "") { return this._overlayRef ? this._overlayRef.updateSize({ height: n }) : this._height = n, this } centerHorizontally(n = "") { return this.left(n), this._xPosition = "center", this } centerVertically(n = "") { return this.top(n), this._alignItems = "center", this } apply() { if (!this._overlayRef || !this._overlayRef.hasAttached()) return; const n = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement.style, i = this._overlayRef.getConfig(), { width: o, height: r, maxWidth: s, maxHeight: a } = i, l = !("100%" !== o && "100vw" !== o || s && "100%" !== s && "100vw" !== s), c = !("100%" !== r && "100vh" !== r || a && "100%" !== a && "100vh" !== a), d = this._xPosition, u = this._xOffset, h = "rtl" === this._overlayRef.getConfig().direction; let f = "", p = "", m = ""; l ? m = "flex-start" : "center" === d ? (m = "center", h ? p = u : f = u) : h ? "left" === d || "end" === d ? (m = "flex-end", f = u) : ("right" === d || "start" === d) && (m = "flex-start", p = u) : "left" === d || "start" === d ? (m = "flex-start", f = u) : ("right" === d || "end" === d) && (m = "flex-end", p = u), n.position = this._cssPosition, n.marginLeft = l ? "0" : f, n.marginTop = c ? "0" : this._topOffset, n.marginBottom = this._bottomOffset, n.marginRight = l ? "0" : p, e.justifyContent = m, e.alignItems = c ? "flex-start" : this._alignItems } dispose() { if (this._isDisposed || !this._overlayRef) return; const n = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement, i = e.style; e.classList.remove(DM), i.justifyContent = i.alignItems = n.marginTop = n.marginBottom = n.marginLeft = n.marginRight = n.position = "", this._overlayRef = null, this._isDisposed = !0 } } let w5 = (() => { class t { constructor(e, i, o, r) { this._viewportRuler = e, this._document = i, this._platform = o, this._overlayContainer = r } global() { return new y5 } flexibleConnectedTo(e) { return new b5(e, this._viewportRuler, this._document, this._platform, this._overlayContainer) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(Ym), w(te), w(Bt), w(yM)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(), x5 = 0, Wa = (() => { class t { constructor(e, i, o, r, s, a, l, c, d, u, h, f) { this.scrollStrategies = e, this._overlayContainer = i, this._componentFactoryResolver = o, this._positionBuilder = r, this._keyboardDispatcher = s, this._injector = a, this._ngZone = l, this._document = c, this._directionality = d, this._location = u, this._outsideClickDispatcher = h, this._animationsModuleType = f } create(e) { const i = this._createHostElement(), o = this._createPaneElement(i), r = this._createPortalOutlet(o), s = new vM(e); return s.direction = s.direction || this._directionality.value, new _5(r, i, o, s, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher, "NoopAnimations" === this._animationsModuleType) } position() { return this._positionBuilder } _createPaneElement(e) { const i = this._document.createElement("div"); return i.id = "cdk-overlay-" + x5++, i.classList.add("cdk-overlay-pane"), e.appendChild(i), i } _createHostElement() { const e = this._document.createElement("div"); return this._overlayContainer.getContainerElement().appendChild(e), e } _createPortalOutlet(e) { return this._appRef || (this._appRef = this._injector.get(Si)), new l5(e, this._componentFactoryResolver, this._appRef, this._injector, this._document) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(f5), w(yM), w(Ns), w(w5), w(m5), w(ft), w(z), w(te), w(Wp), w(Rc), w(g5), w(eo, 8)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac, providedIn: "root" }) } return t })(); const E5 = { provide: new E("cdk-connected-overlay-scroll-strategy"), deps: [Wa], useFactory: function D5(t) { return () => t.scrollStrategies.reposition() } }; let EM = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ providers: [Wa, E5], imports: [_a, c5, fM, fM] }) } return t })(); function SM(t, n) { return n ? e => ga(n.pipe(St(1), function S5() { return Pe((t, n) => { t.subscribe(Ie(n, tl)) }) }()), e.pipe(SM(t))) : We((e, i) => dt(t(e, i)).pipe(St(1), fD(e))) } const I5 = ["panel"]; function A5(t, n) { if (1 & t) { const e = Ys(); x(0, "div", 0, 1), se("@panelAnimation.done", function (o) { return gs(e), _s(Le()._animationDone.next(o)) }), mt(2), y() } if (2 & t) { const e = n.id, i = Le(); k("id", i.id)("ngClass", i._classList)("@panelAnimation", i.isOpen ? "visible" : "hidden"), Ke("aria-label", i.ariaLabel || null)("aria-labelledby", i._getPanelAriaLabelledby(e)) } } const T5 = ["*"], R5 = zm("panelAnimation", [Ld("void, hidden", qn({ opacity: 0, transform: "scaleY(0.8)" })), $a(":enter, hidden => visible", [y3([Qr("0.03s linear", qn({ opacity: 1 })), Qr("0.12s cubic-bezier(0, 0, 0.2, 1)", qn({ transform: "scaleY(1)" }))])]), $a(":leave, visible => hidden", [Qr("0.075s linear", qn({ opacity: 0 }))])]); let O5 = 0; class k5 { constructor(n, e) { this.source = n, this.option = e } } const F5 = JC(class { }), MM = new E("mat-autocomplete-default-options", { providedIn: "root", factory: function P5() { return { autoActiveFirstOption: !1, autoSelectActiveOption: !1, hideSingleSelectionIndicator: !1, requireSelection: !1 } } }); let N5 = (() => { class t extends F5 { get isOpen() { return this._isOpen && this.showPanel } _setColor(e) { this._color = e, this._setThemeClasses(this._classList) } get autoActiveFirstOption() { return this._autoActiveFirstOption } set autoActiveFirstOption(e) { this._autoActiveFirstOption = lt(e) } get autoSelectActiveOption() { return this._autoSelectActiveOption } set autoSelectActiveOption(e) { this._autoSelectActiveOption = lt(e) } get requireSelection() { return this._requireSelection } set requireSelection(e) { this._requireSelection = lt(e) } set classList(e) { this._classList = e && e.length ? function nj(t, n = /\s+/) { const e = []; if (null != t) { const i = Array.isArray(t) ? t : `${t}`.split(n); for (const o of i) { const r = `${o}`.trim(); r && e.push(r) } } return e }(e).reduce((i, o) => (i[o] = !0, i), {}) : {}, this._setVisibilityClasses(this._classList), this._setThemeClasses(this._classList), this._elementRef.nativeElement.className = "" } constructor(e, i, o, r) { super(), this._changeDetectorRef = e, this._elementRef = i, this._defaults = o, this._activeOptionChanges = Fe.EMPTY, this.showPanel = !1, this._isOpen = !1, this.displayWith = null, this.optionSelected = new ue, this.opened = new ue, this.closed = new ue, this.optionActivated = new ue, this._classList = {}, this.id = "mat-autocomplete-" + O5++, this.inertGroups = r?.SAFARI || !1, this._autoActiveFirstOption = !!o.autoActiveFirstOption, this._autoSelectActiveOption = !!o.autoSelectActiveOption, this._requireSelection = !!o.requireSelection } ngAfterContentInit() { this._keyManager = new yj(this.options).withWrap().skipPredicate(this._skipPredicate), this._activeOptionChanges = this._keyManager.change.subscribe(e => { this.isOpen && this.optionActivated.emit({ source: this, option: this.options.toArray()[e] || null }) }), this._setVisibility() } ngOnDestroy() { this._keyManager?.destroy(), this._activeOptionChanges.unsubscribe() } _setScrollTop(e) { this.panel && (this.panel.nativeElement.scrollTop = e) } _getScrollTop() { return this.panel ? this.panel.nativeElement.scrollTop : 0 } _setVisibility() { this.showPanel = !!this.options.length, this._setVisibilityClasses(this._classList), this._changeDetectorRef.markForCheck() } _emitSelectEvent(e) { const i = new k5(this, e); this.optionSelected.emit(i) } _getPanelAriaLabelledby(e) { return this.ariaLabel ? null : this.ariaLabelledby ? (e ? e + " " : "") + this.ariaLabelledby : e } _setVisibilityClasses(e) { e[this._visibleClass] = this.showPanel, e[this._hiddenClass] = !this.showPanel } _setThemeClasses(e) { e["mat-primary"] = "primary" === this._color, e["mat-warn"] = "warn" === this._color, e["mat-accent"] = "accent" === this._color } _skipPredicate(e) { return e.disabled } static #e = this.\u0275fac = function (i) { return new (i || t)(g(Un), g(ye), g(MM), g(Bt)) }; static #t = this.\u0275dir = P({ type: t, viewQuery: function (i, o) { if (1 & i && (dn(jn, 7), dn(I5, 5)), 2 & i) { let r; Re(r = Oe()) && (o.template = r.first), Re(r = Oe()) && (o.panel = r.first) } }, inputs: { ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], displayWith: "displayWith", autoActiveFirstOption: "autoActiveFirstOption", autoSelectActiveOption: "autoSelectActiveOption", requireSelection: "requireSelection", panelWidth: "panelWidth", classList: ["class", "classList"] }, outputs: { optionSelected: "optionSelected", opened: "opened", closed: "closed", optionActivated: "optionActivated" }, features: [K] }) } return t })(), L5 = (() => { class t extends N5 { constructor() { super(...arguments), this._visibleClass = "mat-mdc-autocomplete-visible", this._hiddenClass = "mat-mdc-autocomplete-hidden", this._animationDone = new ue, this._hideSingleSelectionIndicator = this._defaults.hideSingleSelectionIndicator ?? !1 } get hideSingleSelectionIndicator() { return this._hideSingleSelectionIndicator } set hideSingleSelectionIndicator(e) { this._hideSingleSelectionIndicator = lt(e), this._syncParentProperties() } _syncParentProperties() { if (this.options) for (const e of this.options) e._changeDetectorRef.markForCheck() } ngOnDestroy() { super.ngOnDestroy(), this._animationDone.complete() } _skipPredicate(e) { return !1 } static #e = this.\u0275fac = function () { let e; return function (o) { return (e || (e = ze(t)))(o || t) } }(); static #t = this.\u0275cmp = tt({ type: t, selectors: [["mat-autocomplete"]], contentQueries: function (i, o, r) { if (1 & i && (un(r, aD, 5), un(r, cD, 5)), 2 & i) { let s; Re(s = Oe()) && (o.optionGroups = s), Re(s = Oe()) && (o.options = s) } }, hostAttrs: ["ngSkipHydration", "", 1, "mat-mdc-autocomplete"], inputs: { disableRipple: "disableRipple", hideSingleSelectionIndicator: "hideSingleSelectionIndicator" }, exportAs: ["matAutocomplete"], features: [ge([{ provide: sD, useExisting: t }]), K], ngContentSelectors: T5, decls: 1, vars: 0, consts: [["role", "listbox", 1, "mat-mdc-autocomplete-panel", "mdc-menu-surface", "mdc-menu-surface--open", 3, "id", "ngClass"], ["panel", ""]], template: function (i, o) { 1 & i && (io(), Q(0, A5, 3, 5, "ng-template")) }, dependencies: [Wx], styles: ["div.mat-mdc-autocomplete-panel{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12);width:100%;max-height:256px;visibility:hidden;transform-origin:center top;overflow:auto;padding:8px 0;border-radius:4px;box-sizing:border-box;position:static;background-color:var(--mat-autocomplete-background-color)}.cdk-high-contrast-active div.mat-mdc-autocomplete-panel{outline:solid 1px}.cdk-overlay-pane:not(.mat-mdc-autocomplete-panel-above) div.mat-mdc-autocomplete-panel{border-top-left-radius:0;border-top-right-radius:0}.mat-mdc-autocomplete-panel-above div.mat-mdc-autocomplete-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:center bottom}div.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-visible{visibility:visible}div.mat-mdc-autocomplete-panel.mat-mdc-autocomplete-hidden{visibility:hidden}mat-autocomplete{display:none}"], encapsulation: 2, data: { animation: [R5] }, changeDetection: 0 }) } return t })(); const V5 = { provide: mn, useExisting: be(() => AM), multi: !0 }, IM = new E("mat-autocomplete-scroll-strategy"), j5 = { provide: IM, deps: [Wa], useFactory: function B5(t) { return () => t.scrollStrategies.reposition() } }; let H5 = (() => { class t { get autocompleteDisabled() { return this._autocompleteDisabled } set autocompleteDisabled(e) { this._autocompleteDisabled = lt(e) } constructor(e, i, o, r, s, a, l, c, d, u, h) { this._element = e, this._overlay = i, this._viewContainerRef = o, this._zone = r, this._changeDetectorRef = s, this._dir = l, this._formField = c, this._document = d, this._viewportRuler = u, this._defaults = h, this._componentDestroyed = !1, this._autocompleteDisabled = !1, this._manuallyFloatingLabel = !1, this._viewportSubscription = Fe.EMPTY, this._canOpenOnNextFocus = !0, this._closeKeyEventStream = new ie, this._windowBlurHandler = () => { this._canOpenOnNextFocus = this._document.activeElement !== this._element.nativeElement || this.panelOpen }, this._onChange = () => { }, this._onTouched = () => { }, this.position = "auto", this.autocompleteAttribute = "off", this._overlayAttached = !1, this.optionSelections = Zp(() => { const f = this.autocomplete ? this.autocomplete.options : null; return f ? f.changes.pipe($p(f), Tt(() => $i(...f.map(p => p.onSelectionChange)))) : this._zone.onStable.pipe(St(1), Tt(() => this.optionSelections)) }), this._handlePanelKeydown = f => { (27 === f.keyCode && !pa(f) || 38 === f.keyCode && pa(f, "altKey")) && (this._pendingAutoselectedOption && (this._updateNativeInputValue(this._valueBeforeAutoSelection ?? ""), this._pendingAutoselectedOption = null), this._closeKeyEventStream.next(), this._resetActiveItem(), f.stopPropagation(), f.preventDefault()) }, this._trackedModal = null, this._scrollStrategy = a } ngAfterViewInit() { const e = this._getWindow(); typeof e < "u" && this._zone.runOutsideAngular(() => e.addEventListener("blur", this._windowBlurHandler)) } ngOnChanges(e) { e.position && this._positionStrategy && (this._setStrategyPositions(this._positionStrategy), this.panelOpen && this._overlayRef.updatePosition()) } ngOnDestroy() { const e = this._getWindow(); typeof e < "u" && e.removeEventListener("blur", this._windowBlurHandler), this._viewportSubscription.unsubscribe(), this._componentDestroyed = !0, this._destroyPanel(), this._closeKeyEventStream.complete(), this._clearFromModal() } get panelOpen() { return this._overlayAttached && this.autocomplete.showPanel } openPanel() { this._attachOverlay(), this._floatLabel(), this._trackedModal && UC(this._trackedModal, "aria-owns", this.autocomplete.id) } closePanel() { this._resetLabel(), this._overlayAttached && (this.panelOpen && this._zone.run(() => { this.autocomplete.closed.emit() }), this.autocomplete._isOpen = this._overlayAttached = !1, this._pendingAutoselectedOption = null, this._overlayRef && this._overlayRef.hasAttached() && (this._overlayRef.detach(), this._closingActionsSubscription.unsubscribe()), this._updatePanelState(), this._componentDestroyed || this._changeDetectorRef.detectChanges(), this._trackedModal) && Gp(this._trackedModal, "aria-owns", this.autocomplete.id) } updatePosition() { this._overlayAttached && this._overlayRef.updatePosition() } get panelClosingActions() { return $i(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(at(() => this._overlayAttached)), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ? this._overlayRef.detachments().pipe(at(() => this._overlayAttached)) : N()).pipe(X(e => e instanceof lD ? e : null)) } get activeOption() { return this.autocomplete && this.autocomplete._keyManager ? this.autocomplete._keyManager.activeItem : null } _getOutsideClickStream() { return $i(Jr(this._document, "click"), Jr(this._document, "auxclick"), Jr(this._document, "touchend")).pipe(at(e => { const i = li(e), o = this._formField ? this._formField._elementRef.nativeElement : null, r = this.connectedTo ? this.connectedTo.elementRef.nativeElement : null; return this._overlayAttached && i !== this._element.nativeElement && this._document.activeElement !== this._element.nativeElement && (!o || !o.contains(i)) && (!r || !r.contains(i)) && !!this._overlayRef && !this._overlayRef.overlayElement.contains(i) })) } writeValue(e) { Promise.resolve(null).then(() => this._assignOptionValue(e)) } registerOnChange(e) { this._onChange = e } registerOnTouched(e) { this._onTouched = e } setDisabledState(e) { this._element.nativeElement.disabled = e } _handleKeydown(e) { const i = e.keyCode, o = pa(e); if (27 === i && !o && e.preventDefault(), this.activeOption && 13 === i && this.panelOpen && !o) this.activeOption._selectViaInteraction(), this._resetActiveItem(), e.preventDefault(); else if (this.autocomplete) { const r = this.autocomplete._keyManager.activeItem, s = 38 === i || 40 === i; 9 === i || s && !o && this.panelOpen ? this.autocomplete._keyManager.onKeydown(e) : s && this._canOpen() && this.openPanel(), (s || this.autocomplete._keyManager.activeItem !== r) && (this._scrollToOption(this.autocomplete._keyManager.activeItemIndex || 0), this.autocomplete.autoSelectActiveOption && this.activeOption && (this._pendingAutoselectedOption || (this._valueBeforeAutoSelection = this._element.nativeElement.value), this._pendingAutoselectedOption = this.activeOption, this._assignOptionValue(this.activeOption.value))) } } _handleInput(e) { let i = e.target, o = i.value; "number" === i.type && (o = "" == o ? null : parseFloat(o)), this._previousValue !== o && (this._previousValue = o, this._pendingAutoselectedOption = null, (!this.autocomplete || !this.autocomplete.requireSelection) && this._onChange(o), o || this._clearPreviousSelectedOption(null, !1), this._canOpen() && this._document.activeElement === e.target && this.openPanel()) } _handleFocus() { this._canOpenOnNextFocus ? this._canOpen() && (this._previousValue = this._element.nativeElement.value, this._attachOverlay(), this._floatLabel(!0)) : this._canOpenOnNextFocus = !0 } _handleClick() { this._canOpen() && !this.panelOpen && this.openPanel() } _floatLabel(e = !1) { this._formField && "auto" === this._formField.floatLabel && (e ? this._formField._animateAndLockLabel() : this._formField.floatLabel = "always", this._manuallyFloatingLabel = !0) } _resetLabel() { this._manuallyFloatingLabel && (this._formField && (this._formField.floatLabel = "auto"), this._manuallyFloatingLabel = !1) } _subscribeToClosingActions() { const e = this._zone.onStable.pipe(St(1)), i = this.autocomplete.options.changes.pipe(Ue(() => this._positionStrategy.reapplyLastPosition()), function M5(t, n = Yc) { const e = uM(t, n); return SM(() => e) }(0)); return $i(e, i).pipe(Tt(() => (this._zone.run(() => { const o = this.panelOpen; this._resetActiveItem(), this._updatePanelState(), this._changeDetectorRef.detectChanges(), this.panelOpen && this._overlayRef.updatePosition(), o !== this.panelOpen && (this.panelOpen ? (this._captureValueOnAttach(), this._emitOpened()) : this.autocomplete.closed.emit()) }), this.panelClosingActions)), St(1)).subscribe(o => this._setValueAndClose(o)) } _emitOpened() { this.autocomplete.opened.emit() } _captureValueOnAttach() { this._valueOnAttach = this._element.nativeElement.value } _destroyPanel() { this._overlayRef && (this.closePanel(), this._overlayRef.dispose(), this._overlayRef = null) } _assignOptionValue(e) { const i = this.autocomplete && this.autocomplete.displayWith ? this.autocomplete.displayWith(e) : e; this._updateNativeInputValue(i ?? "") } _updateNativeInputValue(e) { this._formField ? this._formField._control.value = e : this._element.nativeElement.value = e, this._previousValue = e } _setValueAndClose(e) { const i = this.autocomplete, o = e ? e.source : this._pendingAutoselectedOption; o ? (this._clearPreviousSelectedOption(o), this._assignOptionValue(o.value), this._onChange(o.value), i._emitSelectEvent(o), this._element.nativeElement.focus()) : i.requireSelection && this._element.nativeElement.value !== this._valueOnAttach && (this._clearPreviousSelectedOption(null), this._assignOptionValue(null), i._animationDone ? i._animationDone.pipe(St(1)).subscribe(() => this._onChange(null)) : this._onChange(null)), this.closePanel() } _clearPreviousSelectedOption(e, i) { this.autocomplete?.options?.forEach(o => { o !== e && o.selected && o.deselect(i) }) } _attachOverlay() { let e = this._overlayRef; e ? (this._positionStrategy.setOrigin(this._getConnectedElement()), e.updateSize({ width: this._getPanelWidth() })) : (this._portal = new pM(this.autocomplete.template, this._viewContainerRef, { id: this._formField?.getLabelId() }), e = this._overlay.create(this._getOverlayConfig()), this._overlayRef = e, this._viewportSubscription = this._viewportRuler.change().subscribe(() => { this.panelOpen && e && e.updateSize({ width: this._getPanelWidth() }) })), e && !e.hasAttached() && (e.attach(this._portal), this._closingActionsSubscription = this._subscribeToClosingActions()); const i = this.panelOpen; this.autocomplete._isOpen = this._overlayAttached = !0, this.autocomplete._setColor(this._formField?.color), this._updatePanelState(), this._applyModalPanelOwnership(), this._captureValueOnAttach(), this.panelOpen && i !== this.panelOpen && this._emitOpened() } _updatePanelState() { if (this.autocomplete._setVisibility(), this.panelOpen) { const e = this._overlayRef; this._keydownSubscription || (this._keydownSubscription = e.keydownEvents().subscribe(this._handlePanelKeydown)), this._outsideClickSubscription || (this._outsideClickSubscription = e.outsidePointerEvents().subscribe()) } else this._keydownSubscription?.unsubscribe(), this._outsideClickSubscription?.unsubscribe(), this._keydownSubscription = this._outsideClickSubscription = null } _getOverlayConfig() { return new vM({ positionStrategy: this._getOverlayPosition(), scrollStrategy: this._scrollStrategy(), width: this._getPanelWidth(), direction: this._dir ?? void 0, panelClass: this._defaults?.overlayPanelClass }) } _getOverlayPosition() { const e = this._overlay.position().flexibleConnectedTo(this._getConnectedElement()).withFlexibleDimensions(!1).withPush(!1); return this._setStrategyPositions(e), this._positionStrategy = e, e } _setStrategyPositions(e) { const i = [{ originX: "start", originY: "bottom", overlayX: "start", overlayY: "top" }, { originX: "end", originY: "bottom", overlayX: "end", overlayY: "top" }], o = this._aboveClass, r = [{ originX: "start", originY: "top", overlayX: "start", overlayY: "bottom", panelClass: o }, { originX: "end", originY: "top", overlayX: "end", overlayY: "bottom", panelClass: o }]; let s; s = "above" === this.position ? r : "below" === this.position ? i : [...i, ...r], e.withPositions(s) } _getConnectedElement() { return this.connectedTo ? this.connectedTo.elementRef : this._formField ? this._formField.getConnectedOverlayOrigin() : this._element } _getPanelWidth() { return this.autocomplete.panelWidth || this._getHostWidth() } _getHostWidth() { return this._getConnectedElement().nativeElement.getBoundingClientRect().width } _resetActiveItem() { const e = this.autocomplete; if (e.autoActiveFirstOption) { let i = -1; for (let o = 0; o < e.options.length; o++)if (!e.options.get(o).disabled) { i = o; break } e._keyManager.setActiveItem(i) } else e._keyManager.setActiveItem(-1) } _canOpen() { const e = this._element.nativeElement; return !e.readOnly && !e.disabled && !this._autocompleteDisabled } _getWindow() { return this._document?.defaultView || window } _scrollToOption(e) { const i = this.autocomplete, o = function rH(t, n, e) { if (e.length) { let i = n.toArray(), o = e.toArray(), r = 0; for (let s = 0; s < t + 1; s++)i[s].group && i[s].group === o[r] && r++; return r } return 0 }(e, i.options, i.optionGroups); if (0 === e && 1 === o) i._setScrollTop(0); else if (i.panel) { const r = i.options.toArray()[e]; if (r) { const s = r._getHostElement(), a = function sH(t, n, e, i) { return t < e ? t : t + n > e + i ? Math.max(0, t - i + n) : e }(s.offsetTop, s.offsetHeight, i._getScrollTop(), i.panel.nativeElement.offsetHeight); i._setScrollTop(a) } } } _applyModalPanelOwnership() { const e = this._element.nativeElement.closest('body > .cdk-overlay-container [aria-modal="true"]'); if (!e) return; const i = this.autocomplete.id; this._trackedModal && Gp(this._trackedModal, "aria-owns", i), UC(e, "aria-owns", i), this._trackedModal = e } _clearFromModal() { this._trackedModal && (Gp(this._trackedModal, "aria-owns", this.autocomplete.id), this._trackedModal = null) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(ye), g(Wa), g(cn), g(z), g(Un), g(IM), g(Wp, 8), g(qm, 9), g(te, 8), g(Ym), g(MM, 8)) }; static #t = this.\u0275dir = P({ type: t, inputs: { autocomplete: ["matAutocomplete", "autocomplete"], position: ["matAutocompletePosition", "position"], connectedTo: ["matAutocompleteConnectedTo", "connectedTo"], autocompleteAttribute: ["autocomplete", "autocompleteAttribute"], autocompleteDisabled: ["matAutocompleteDisabled", "autocompleteDisabled"] }, features: [Ft] }) } return t })(), AM = (() => { class t extends H5 { constructor() { super(...arguments), this._aboveClass = "mat-mdc-autocomplete-panel-above" } static #e = this.\u0275fac = function () { let e; return function (o) { return (e || (e = ze(t)))(o || t) } }(); static #t = this.\u0275dir = P({ type: t, selectors: [["input", "matAutocomplete", ""], ["textarea", "matAutocomplete", ""]], hostAttrs: [1, "mat-mdc-autocomplete-trigger"], hostVars: 7, hostBindings: function (i, o) { 1 & i && se("focusin", function () { return o._handleFocus() })("blur", function () { return o._onTouched() })("input", function (s) { return o._handleInput(s) })("keydown", function (s) { return o._handleKeydown(s) })("click", function () { return o._handleClick() }), 2 & i && Ke("autocomplete", o.autocompleteAttribute)("role", o.autocompleteDisabled ? null : "combobox")("aria-autocomplete", o.autocompleteDisabled ? null : "list")("aria-activedescendant", o.panelOpen && o.activeOption ? o.activeOption.id : null)("aria-expanded", o.autocompleteDisabled ? null : o.panelOpen.toString())("aria-controls", o.autocompleteDisabled || !o.panelOpen || null == o.autocomplete ? null : o.autocomplete.id)("aria-haspopup", o.autocompleteDisabled ? null : "listbox") }, exportAs: ["matAutocompleteTrigger"], features: [ge([V5]), K] }) } return t })(), U5 = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ providers: [j5], imports: [EM, dD, qe, Ar, Hd, dD, qe] }) } return t })(); function z5(t, n) { if (1 & t) { const e = Ys(); x(0, "mat-option", 34), se("onSelectionChange", function () { const r = gs(e).$implicit; return _s(Le().navigate(r._id)) }), A(1), y() } if (2 & t) { const e = n.$implicit; k("value", e.title), S(1), Zt(e.title) } } function $5(t, n) { if (1 & t) { const e = Ys(); x(0, "li", 35)(1, "a", 36)(2, "mat-icon"), A(3, "person"), y(), A(4), y(), x(5, "ul", 37)(6, "li")(7, "a", 38), A(8), y()(), x(9, "li", 39)(10, "a", 40), A(11, " order history"), y()(), x(12, "li"), U(13, "hr", 41), y(), x(14, "li")(15, "button", 42), se("click", function () { return gs(e), _s(Le().logout()) }), A(16, " Logout "), y()()()() } if (2 & t) { const e = Le(); S(4), ln(" ", e.user.name, " "), S(4), Zt(e.user.username), S(2), yr("routerLink", "/order-history/", e.user.id, "") } } function G5(t, n) { 1 & t && (x(0, "li", 14)(1, "a", 43), A(2, "Login"), y()()) } let q5 = (() => { class t { constructor(e, i, o) { this.api = e, this.router = i, this.auth = o, this.title = "bookstore" } ngOnInit() { var e = this; this.auth.loggedIn.subscribe(function () { var i = Wr(function* (o) { o && setTimeout(Wr(function* () { e.user = yield e.auth.getUser(), console.log(o, e.user), e.logState = o, console.log(e.logState) }), 100) }); return function (o) { return i.apply(this, arguments) } }()), console.log(this.user), this.search_book = new Ht("", jt.required) } navigate(e) { this.search_book.setValue(""), this.router.navigateByUrl(`/book/${e}`) } search() { return Wr(function* () { })() } onChange() { var e = this; return Wr(function* () { e.api.searchBook(e.search_book.value).subscribe(i => { e.data = i.valueOf(), e.option = e.data.data }) })() } logout() { this.auth.logout(), this.logState = !1 } shopcart() { null == this.auth.getUser() ? alert("please login.") : this.router.navigateByUrl("/shop-cart/" + this.user.id) } static #e = this.\u0275fac = function (i) { return new (i || t)(g(go), g(Mt), g(Yr)) }; static #t = this.\u0275cmp = tt({ type: t, selectors: [["app-root"]], decls: 47, vars: 5, consts: [[1, "navbar", "navbar-expand-lg", "nav", "sticky-top", 2, "z-index", "1"], [1, "container"], ["routerLink", "/", 1, "navbar-brand", "w-50"], ["src", "./assets/logo/logo.jpg", "height", "55", "width", "180", "routerLink", "/"], ["type", "button", "data-bs-toggle", "collapse", "data-bs-target", "#navbarNav", "aria-controls", "navbarNav", "aria-expanded", "false", "aria-label", "Toggle navigation", 1, "navbar-toggler"], [1, "navbar-toggler-icon"], ["id", "navbarNav", 1, "collapse", "navbar-collapse", "w-100"], [1, "search-box", "w-100", "me-2"], ["type", "text", "placeholder", "Search", 1, "search-box", "mx-auto", "w-100", 3, "formControl", "matAutocomplete", "change", "input"], [1, "search-icon"], ["autoActiveFirstOption", "", 2, "z-index", "100"], ["auto", "matAutocomplete"], [3, "value", "onSelectionChange", 4, "ngFor", "ngForOf"], [1, "navbar-nav"], [1, "nav-item"], ["aria-current", "page", "href", "#", 1, "nav-link", "active", "icon-link"], ["aria-hidden", "false", "aria-label", "Example home icon", "fontIcon", "home"], [2, "font-size", "17px"], [1, "nav-link", "icon-link", 3, "click"], ["aria-hidden", "false", "aria-label", "Example home icon", "fontIcon", "shopping_cart"], ["class", "nav-item dropdown", 4, "ngIf"], ["class", "nav-item", 4, "ngIf"], [1, "bg-dark", "my-5", 2, "color", "white"], [1, "text-center"], [1, "container", "pt-4"], [1, "mb-4"], ["role", "button", "data-mdb-ripple-color", "dark", 1, "btn", "btn-link", "btn-floating", "btn-lg", "text-light", "m-1"], [1, "bi", "bi-instagram"], [1, "bi", "bi-twitter-x"], [1, "bi", "bi-google"], [1, "bi", "bi-linkedin"], [1, "bi", "bi-github"], [1, "text-center", "text-light", "p-3", 2, "background-color", "rgba(0, 0, 0, 0.2)"], ["routerLink", "/", 1, "text-light"], [3, "value", "onSelectionChange"], [1, "nav-item", "dropdown"], ["id", "navbarDropdown", "role", "button", "data-bs-toggle", "dropdown", "aria-expanded", "false", 1, "nav-link", "icon-link", "dropdown-toggle", 2, "font-size", "17px"], ["aria-labelledby", "navbarDropdown", 1, "dropdown-menu"], [1, "dropdown-item"], [1, "my-2"], [1, "dropdown-item", 3, "routerLink"], [1, "dropdown-divider"], [1, "dropdown-item", "btn", "btn-outline-danger", 3, "click"], ["routerLink", "login", 1, "btn", "btn-outline-dark"]], template: function (i, o) { if (1 & i && (x(0, "nav", 0)(1, "div", 1)(2, "a", 2), U(3, "img", 3), y(), x(4, "button", 4), U(5, "span", 5), y(), x(6, "div", 6)(7, "div", 7)(8, "input", 8), se("change", function () { return o.search() })("input", function () { return o.onChange() }), y(), x(9, "button", 9)(10, "mat-autocomplete", 10, 11), Q(12, z5, 2, 2, "mat-option", 12), y(), x(13, "mat-icon"), A(14, "search"), y()()(), x(15, "ul", 13)(16, "li", 14)(17, "a", 15), U(18, "mat-icon", 16), x(19, "span", 17), A(20, "Home"), y()()(), x(21, "li", 14)(22, "a", 18), se("click", function () { return o.shopcart() }), U(23, "mat-icon", 19), x(24, "span", 17), A(25, "Cart"), y()()(), Q(26, $5, 17, 3, "li", 20), Q(27, G5, 3, 0, "li", 21), y()()()(), U(28, "router-outlet"), x(29, "div", 22)(30, "footer", 23)(31, "div", 24)(32, "section", 25)(33, "a", 26), U(34, "i", 27), y(), x(35, "a", 26), U(36, "i", 28), y(), x(37, "a", 26), U(38, "i", 29), y(), x(39, "a", 26), U(40, "i", 30), y(), x(41, "a", 26), U(42, "i", 31), y()()(), x(43, "div", 32), A(44, " \xa9 2023 Copyright: "), x(45, "a", 33), A(46, "Life Pages"), y()()()()), 2 & i) { const r = Ws(11); S(8), k("formControl", o.search_book)("matAutocomplete", r), S(4), k("ngForOf", o.option), S(14), k("ngIf", o.logState), S(1), k("ngIf", !o.logState) } }, dependencies: [Ir, Ii, dm, $r, Um, vo, La, Ua, L5, cD, AM], styles: [".nav[_ngcontent-%COMP%]{background-color:#fff;box-shadow:1px 1px 5px #0003}.search-box[_ngcontent-%COMP%]{position:relative;height:100%}.search-box[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{background-color:#f0f8ff;border:0cap;box-shadow:0 0 5px #0003;padding:10px;font-size:17px}a[_ngcontent-%COMP%]{cursor:pointer}.search-icon[_ngcontent-%COMP%]{position:absolute;right:10px;bottom:2px;color:#999;background-color:transparent;border:0;transition:all .3s}.search-icon[_ngcontent-%COMP%]:hover{color:#000}"] }) } return t })(); function TM(t) { return new b(3e3, !1) } function Bi(t) { switch (t.length) { case 0: return new Ga; case 1: return t[0]; default: return new $S(t) } } function RM(t, n, e = new Map, i = new Map) { const o = [], r = []; let s = -1, a = null; if (n.forEach(l => { const c = l.get("offset"), d = c == s, u = d && a || new Map; l.forEach((h, f) => { let p = f, m = h; if ("offset" !== f) switch (p = t.normalizePropertyName(p, o), m) { case "!": m = e.get(f); break; case hi: m = i.get(f); break; default: m = t.normalizeStyleValue(f, p, m, o) }u.set(p, m) }), d || r.push(u), a = u, s = c }), o.length) throw function m8(t) { return new b(3502, !1) }(); return r } function Km(t, n, e, i) { switch (n) { case "start": t.onStart(() => i(e && Qm(e, "start", t))); break; case "done": t.onDone(() => i(e && Qm(e, "done", t))); break; case "destroy": t.onDestroy(() => i(e && Qm(e, "destroy", t))) } } function Qm(t, n, e) { const r = Jm(t.element, t.triggerName, t.fromState, t.toState, n || t.phaseName, e.totalTime ?? t.totalTime, !!e.disabled), s = t._data; return null != s && (r._data = s), r } function Jm(t, n, e, i, o = "", r = 0, s) { return { element: t, triggerName: n, fromState: e, toState: i, phaseName: o, totalTime: r, disabled: !!s } } function Kt(t, n, e) { let i = t.get(n); return i || t.set(n, i = e), i } function OM(t) { const n = t.indexOf(":"); return [t.substring(1, n), t.slice(n + 1)] } const M8 = (() => typeof document > "u" ? null : document.documentElement)(); function eg(t) { const n = t.parentNode || t.host || null; return n === M8 ? null : n } let Co = null, kM = !1; function FM(t, n) { for (; n;) { if (n === t) return !0; n = eg(n) } return !1 } function PM(t, n, e) { if (e) return Array.from(t.querySelectorAll(n)); const i = t.querySelector(n); return i ? [i] : [] } let NM = (() => { class t { validateStyleProperty(e) { return function A8(t) { Co || (Co = function T8() { return typeof document < "u" ? document.body : null }() || {}, kM = !!Co.style && "WebkitAppearance" in Co.style); let n = !0; return Co.style && !function I8(t) { return "ebkit" == t.substring(1, 6) }(t) && (n = t in Co.style, !n && kM && (n = "Webkit" + t.charAt(0).toUpperCase() + t.slice(1) in Co.style)), n }(e) } matchesElement(e, i) { return !1 } containsElement(e, i) { return FM(e, i) } getParentElement(e) { return eg(e) } query(e, i, o) { return PM(e, i, o) } computeStyle(e, i, o) { return o || "" } animate(e, i, o, r, s, a = [], l) { return new Ga(o, r) } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })(), tg = (() => { class t { static #e = this.NOOP = new NM } return t })(); const R8 = 1e3, ng = "ng-enter", Ud = "ng-leave", zd = "ng-trigger", $d = ".ng-trigger", VM = "ng-animating", ig = ".ng-animating"; function fi(t) { if ("number" == typeof t) return t; const n = t.match(/^(-?[\.\d]+)(m?s)/); return !n || n.length < 2 ? 0 : og(parseFloat(n[1]), n[2]) } function og(t, n) { return "s" === n ? t * R8 : t } function Gd(t, n, e) { return t.hasOwnProperty("duration") ? t : function k8(t, n, e) { let o, r = 0, s = ""; if ("string" == typeof t) { const a = t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === a) return n.push(TM()), { duration: 0, delay: 0, easing: "" }; o = og(parseFloat(a[1]), a[2]); const l = a[3]; null != l && (r = og(parseFloat(l), a[4])); const c = a[5]; c && (s = c) } else o = t; if (!e) { let a = !1, l = n.length; o < 0 && (n.push(function W5() { return new b(3100, !1) }()), a = !0), r < 0 && (n.push(function Y5() { return new b(3101, !1) }()), a = !0), a && n.splice(l, 0, TM()) } return { duration: o, delay: r, easing: s } }(t, n, e) } function Ya(t, n = {}) { return Object.keys(t).forEach(e => { n[e] = t[e] }), n } function BM(t) { const n = new Map; return Object.keys(t).forEach(e => { n.set(e, t[e]) }), n } function ji(t, n = new Map, e) { if (e) for (let [i, o] of e) n.set(i, o); for (let [i, o] of t) n.set(i, o); return n } function Wn(t, n, e) { n.forEach((i, o) => { const r = sg(o); e && !e.has(o) && e.set(o, t.style[r]), t.style[r] = i }) } function Do(t, n) { n.forEach((e, i) => { const o = sg(i); t.style[o] = "" }) } function Za(t) { return Array.isArray(t) ? 1 == t.length ? t[0] : zS(t) : t } const rg = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function HM(t) { let n = []; if ("string" == typeof t) { let e; for (; e = rg.exec(t);)n.push(e[1]); rg.lastIndex = 0 } return n } function Xa(t, n, e) { const i = t.toString(), o = i.replace(rg, (r, s) => { let a = n[s]; return null == a && (e.push(function X5(t) { return new b(3003, !1) }()), a = ""), a.toString() }); return o == i ? t : o } function qd(t) { const n = []; let e = t.next(); for (; !e.done;)n.push(e.value), e = t.next(); return n } const N8 = /-+([a-z0-9])/g; function sg(t) { return t.replace(N8, (...n) => n[1].toUpperCase()) } function Qt(t, n, e) { switch (n.type) { case 7: return t.visitTrigger(n, e); case 0: return t.visitState(n, e); case 1: return t.visitTransition(n, e); case 2: return t.visitSequence(n, e); case 3: return t.visitGroup(n, e); case 4: return t.visitAnimate(n, e); case 5: return t.visitKeyframes(n, e); case 6: return t.visitStyle(n, e); case 8: return t.visitReference(n, e); case 9: return t.visitAnimateChild(n, e); case 10: return t.visitAnimateRef(n, e); case 11: return t.visitQuery(n, e); case 12: return t.visitStagger(n, e); default: throw function K5(t) { return new b(3004, !1) }() } } function UM(t, n) { return window.getComputedStyle(t)[n] } const Wd = "*"; function B8(t, n) { const e = []; return "string" == typeof t ? t.split(/\s*,\s*/).forEach(i => function j8(t, n, e) { if (":" == t[0]) { const l = function H8(t, n) { switch (t) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (e, i) => parseFloat(i) > parseFloat(e); case ":decrement": return (e, i) => parseFloat(i) < parseFloat(e); default: return n.push(function u8(t) { return new b(3016, !1) }()), "* => *" } }(t, e); if ("function" == typeof l) return void n.push(l); t = l } const i = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == i || i.length < 4) return e.push(function d8(t) { return new b(3015, !1) }()), n; const o = i[1], r = i[2], s = i[3]; n.push(zM(o, s)); "<" == r[0] && !(o == Wd && s == Wd) && n.push(zM(s, o)) }(i, e, n)) : e.push(t), e } const Yd = new Set(["true", "1"]), Zd = new Set(["false", "0"]); function zM(t, n) { const e = Yd.has(t) || Zd.has(t), i = Yd.has(n) || Zd.has(n); return (o, r) => { let s = t == Wd || t == o, a = n == Wd || n == r; return !s && e && "boolean" == typeof o && (s = o ? Yd.has(t) : Zd.has(t)), !a && i && "boolean" == typeof r && (a = r ? Yd.has(n) : Zd.has(n)), s && a } } const U8 = new RegExp("s*:selfs*,?", "g"); function ag(t, n, e, i) { return new z8(t).build(n, e, i) } class z8 { constructor(n) { this._driver = n } build(n, e, i) { const o = new q8(e); return this._resetContextStyleTimingState(o), Qt(this, Za(n), o) } _resetContextStyleTimingState(n) { n.currentQuerySelector = "", n.collectedStyles = new Map, n.collectedStyles.set("", new Map), n.currentTime = 0 } visitTrigger(n, e) { let i = e.queryCount = 0, o = e.depCount = 0; const r = [], s = []; return "@" == n.name.charAt(0) && e.errors.push(function J5() { return new b(3006, !1) }()), n.definitions.forEach(a => { if (this._resetContextStyleTimingState(e), 0 == a.type) { const l = a, c = l.name; c.toString().split(/\s*,\s*/).forEach(d => { l.name = d, r.push(this.visitState(l, e)) }), l.name = c } else if (1 == a.type) { const l = this.visitTransition(a, e); i += l.queryCount, o += l.depCount, s.push(l) } else e.errors.push(function e8() { return new b(3007, !1) }()) }), { type: 7, name: n.name, states: r, transitions: s, queryCount: i, depCount: o, options: null } } visitState(n, e) { const i = this.visitStyle(n.styles, e), o = n.options && n.options.params || null; if (i.containsDynamicStyles) { const r = new Set, s = o || {}; i.styles.forEach(a => { a instanceof Map && a.forEach(l => { HM(l).forEach(c => { s.hasOwnProperty(c) || r.add(c) }) }) }), r.size && (qd(r.values()), e.errors.push(function t8(t, n) { return new b(3008, !1) }())) } return { type: 0, name: n.name, style: i, options: o ? { params: o } : null } } visitTransition(n, e) { e.queryCount = 0, e.depCount = 0; const i = Qt(this, Za(n.animation), e); return { type: 1, matchers: B8(n.expr, e.errors), animation: i, queryCount: e.queryCount, depCount: e.depCount, options: Eo(n.options) } } visitSequence(n, e) { return { type: 2, steps: n.steps.map(i => Qt(this, i, e)), options: Eo(n.options) } } visitGroup(n, e) { const i = e.currentTime; let o = 0; const r = n.steps.map(s => { e.currentTime = i; const a = Qt(this, s, e); return o = Math.max(o, e.currentTime), a }); return e.currentTime = o, { type: 3, steps: r, options: Eo(n.options) } } visitAnimate(n, e) { const i = function Y8(t, n) { if (t.hasOwnProperty("duration")) return t; if ("number" == typeof t) return lg(Gd(t, n).duration, 0, ""); const e = t; if (e.split(/\s+/).some(r => "{" == r.charAt(0) && "{" == r.charAt(1))) { const r = lg(0, 0, ""); return r.dynamic = !0, r.strValue = e, r } const o = Gd(e, n); return lg(o.duration, o.delay, o.easing) }(n.timings, e.errors); e.currentAnimateTimings = i; let o, r = n.styles ? n.styles : qn({}); if (5 == r.type) o = this.visitKeyframes(r, e); else { let s = n.styles, a = !1; if (!s) { a = !0; const c = {}; i.easing && (c.easing = i.easing), s = qn(c) } e.currentTime += i.duration + i.delay; const l = this.visitStyle(s, e); l.isEmptyStep = a, o = l } return e.currentAnimateTimings = null, { type: 4, timings: i, style: o, options: null } } visitStyle(n, e) { const i = this._makeStyleAst(n, e); return this._validateStyleAst(i, e), i } _makeStyleAst(n, e) { const i = [], o = Array.isArray(n.styles) ? n.styles : [n.styles]; for (let a of o) "string" == typeof a ? a === hi ? i.push(a) : e.errors.push(new b(3002, !1)) : i.push(BM(a)); let r = !1, s = null; return i.forEach(a => { if (a instanceof Map && (a.has("easing") && (s = a.get("easing"), a.delete("easing")), !r)) for (let l of a.values()) if (l.toString().indexOf("{{") >= 0) { r = !0; break } }), { type: 6, styles: i, easing: s, offset: n.offset, containsDynamicStyles: r, options: null } } _validateStyleAst(n, e) { const i = e.currentAnimateTimings; let o = e.currentTime, r = e.currentTime; i && r > 0 && (r -= i.duration + i.delay), n.styles.forEach(s => { "string" != typeof s && s.forEach((a, l) => { const c = e.collectedStyles.get(e.currentQuerySelector), d = c.get(l); let u = !0; d && (r != o && r >= d.startTime && o <= d.endTime && (e.errors.push(function i8(t, n, e, i, o) { return new b(3010, !1) }()), u = !1), r = d.startTime), u && c.set(l, { startTime: r, endTime: o }), e.options && function P8(t, n, e) { const i = n.params || {}, o = HM(t); o.length && o.forEach(r => { i.hasOwnProperty(r) || e.push(function Z5(t) { return new b(3001, !1) }()) }) }(a, e.options, e.errors) }) }) } visitKeyframes(n, e) { const i = { type: 5, styles: [], options: null }; if (!e.currentAnimateTimings) return e.errors.push(function o8() { return new b(3011, !1) }()), i; let r = 0; const s = []; let a = !1, l = !1, c = 0; const d = n.steps.map(C => { const v = this._makeStyleAst(C, e); let M = null != v.offset ? v.offset : function W8(t) { if ("string" == typeof t) return null; let n = null; if (Array.isArray(t)) t.forEach(e => { if (e instanceof Map && e.has("offset")) { const i = e; n = parseFloat(i.get("offset")), i.delete("offset") } }); else if (t instanceof Map && t.has("offset")) { const e = t; n = parseFloat(e.get("offset")), e.delete("offset") } return n }(v.styles), O = 0; return null != M && (r++, O = v.offset = M), l = l || O < 0 || O > 1, a = a || O < c, c = O, s.push(O), v }); l && e.errors.push(function r8() { return new b(3012, !1) }()), a && e.errors.push(function s8() { return new b(3200, !1) }()); const u = n.steps.length; let h = 0; r > 0 && r < u ? e.errors.push(function a8() { return new b(3202, !1) }()) : 0 == r && (h = 1 / (u - 1)); const f = u - 1, p = e.currentTime, m = e.currentAnimateTimings, _ = m.duration; return d.forEach((C, v) => { const M = h > 0 ? v == f ? 1 : h * v : s[v], O = M * _; e.currentTime = p + m.delay + O, m.duration = O, this._validateStyleAst(C, e), C.offset = M, i.styles.push(C) }), i } visitReference(n, e) { return { type: 8, animation: Qt(this, Za(n.animation), e), options: Eo(n.options) } } visitAnimateChild(n, e) { return e.depCount++, { type: 9, options: Eo(n.options) } } visitAnimateRef(n, e) { return { type: 10, animation: this.visitReference(n.animation, e), options: Eo(n.options) } } visitQuery(n, e) { const i = e.currentQuerySelector, o = n.options || {}; e.queryCount++, e.currentQuery = n; const [r, s] = function $8(t) { const n = !!t.split(/\s*,\s*/).find(e => ":self" == e); return n && (t = t.replace(U8, "")), t = t.replace(/@\*/g, $d).replace(/@\w+/g, e => $d + "-" + e.slice(1)).replace(/:animating/g, ig), [t, n] }(n.selector); e.currentQuerySelector = i.length ? i + " " + r : r, Kt(e.collectedStyles, e.currentQuerySelector, new Map); const a = Qt(this, Za(n.animation), e); return e.currentQuery = null, e.currentQuerySelector = i, { type: 11, selector: r, limit: o.limit || 0, optional: !!o.optional, includeSelf: s, animation: a, originalSelector: n.selector, options: Eo(n.options) } } visitStagger(n, e) { e.currentQuery || e.errors.push(function l8() { return new b(3013, !1) }()); const i = "full" === n.timings ? { duration: 0, delay: 0, easing: "full" } : Gd(n.timings, e.errors, !0); return { type: 12, animation: Qt(this, Za(n.animation), e), timings: i, options: null } } } class q8 { constructor(n) { this.errors = n, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = new Map, this.options = null, this.unsupportedCSSPropertiesFound = new Set } } function Eo(t) { return t ? (t = Ya(t)).params && (t.params = function G8(t) { return t ? Ya(t) : null }(t.params)) : t = {}, t } function lg(t, n, e) { return { duration: t, delay: n, easing: e } } function cg(t, n, e, i, o, r, s = null, a = !1) { return { type: 1, element: t, keyframes: n, preStyleProps: e, postStyleProps: i, duration: o, delay: r, totalTime: o + r, easing: s, subTimeline: a } } class Xd { constructor() { this._map = new Map } get(n) { return this._map.get(n) || [] } append(n, e) { let i = this._map.get(n); i || this._map.set(n, i = []), i.push(...e) } has(n) { return this._map.has(n) } clear() { this._map.clear() } } const K8 = new RegExp(":enter", "g"), J8 = new RegExp(":leave", "g"); function dg(t, n, e, i, o, r = new Map, s = new Map, a, l, c = []) { return (new eG).buildKeyframes(t, n, e, i, o, r, s, a, l, c) } class eG { buildKeyframes(n, e, i, o, r, s, a, l, c, d = []) { c = c || new Xd; const u = new ug(n, e, c, o, r, d, []); u.options = l; const h = l.delay ? fi(l.delay) : 0; u.currentTimeline.delayNextStep(h), u.currentTimeline.setStyles([s], null, u.errors, l), Qt(this, i, u); const f = u.timelines.filter(p => p.containsAnimation()); if (f.length && a.size) { let p; for (let m = f.length - 1; m >= 0; m--) { const _ = f[m]; if (_.element === e) { p = _; break } } p && !p.allowOnlyTimelineStyles() && p.setStyles([a], null, u.errors, l) } return f.length ? f.map(p => p.buildKeyframes()) : [cg(e, [], [], [], 0, h, "", !1)] } visitTrigger(n, e) { } visitState(n, e) { } visitTransition(n, e) { } visitAnimateChild(n, e) { const i = e.subInstructions.get(e.element); if (i) { const o = e.createSubContext(n.options), r = e.currentTimeline.currentTime, s = this._visitSubInstructions(i, o, o.options); r != s && e.transformIntoNewTimeline(s) } e.previousNode = n } visitAnimateRef(n, e) { const i = e.createSubContext(n.options); i.transformIntoNewTimeline(), this._applyAnimationRefDelays([n.options, n.animation.options], e, i), this.visitReference(n.animation, i), e.transformIntoNewTimeline(i.currentTimeline.currentTime), e.previousNode = n } _applyAnimationRefDelays(n, e, i) { for (const o of n) { const r = o?.delay; if (r) { const s = "number" == typeof r ? r : fi(Xa(r, o?.params ?? {}, e.errors)); i.delayNextStep(s) } } } _visitSubInstructions(n, e, i) { let r = e.currentTimeline.currentTime; const s = null != i.duration ? fi(i.duration) : null, a = null != i.delay ? fi(i.delay) : null; return 0 !== s && n.forEach(l => { const c = e.appendInstructionToTimeline(l, s, a); r = Math.max(r, c.duration + c.delay) }), r } visitReference(n, e) { e.updateOptions(n.options, !0), Qt(this, n.animation, e), e.previousNode = n } visitSequence(n, e) { const i = e.subContextCount; let o = e; const r = n.options; if (r && (r.params || r.delay) && (o = e.createSubContext(r), o.transformIntoNewTimeline(), null != r.delay)) { 6 == o.previousNode.type && (o.currentTimeline.snapshotCurrentStyles(), o.previousNode = Kd); const s = fi(r.delay); o.delayNextStep(s) } n.steps.length && (n.steps.forEach(s => Qt(this, s, o)), o.currentTimeline.applyStylesToKeyframe(), o.subContextCount > i && o.transformIntoNewTimeline()), e.previousNode = n } visitGroup(n, e) { const i = []; let o = e.currentTimeline.currentTime; const r = n.options && n.options.delay ? fi(n.options.delay) : 0; n.steps.forEach(s => { const a = e.createSubContext(n.options); r && a.delayNextStep(r), Qt(this, s, a), o = Math.max(o, a.currentTimeline.currentTime), i.push(a.currentTimeline) }), i.forEach(s => e.currentTimeline.mergeTimelineCollectedStyles(s)), e.transformIntoNewTimeline(o), e.previousNode = n } _visitTiming(n, e) { if (n.dynamic) { const i = n.strValue; return Gd(e.params ? Xa(i, e.params, e.errors) : i, e.errors) } return { duration: n.duration, delay: n.delay, easing: n.easing } } visitAnimate(n, e) { const i = e.currentAnimateTimings = this._visitTiming(n.timings, e), o = e.currentTimeline; i.delay && (e.incrementTime(i.delay), o.snapshotCurrentStyles()); const r = n.style; 5 == r.type ? this.visitKeyframes(r, e) : (e.incrementTime(i.duration), this.visitStyle(r, e), o.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = n } visitStyle(n, e) { const i = e.currentTimeline, o = e.currentAnimateTimings; !o && i.hasCurrentStyleProperties() && i.forwardFrame(); const r = o && o.easing || n.easing; n.isEmptyStep ? i.applyEmptyStep(r) : i.setStyles(n.styles, r, e.errors, e.options), e.previousNode = n } visitKeyframes(n, e) { const i = e.currentAnimateTimings, o = e.currentTimeline.duration, r = i.duration, a = e.createSubContext().currentTimeline; a.easing = i.easing, n.styles.forEach(l => { a.forwardTime((l.offset || 0) * r), a.setStyles(l.styles, l.easing, e.errors, e.options), a.applyStylesToKeyframe() }), e.currentTimeline.mergeTimelineCollectedStyles(a), e.transformIntoNewTimeline(o + r), e.previousNode = n } visitQuery(n, e) { const i = e.currentTimeline.currentTime, o = n.options || {}, r = o.delay ? fi(o.delay) : 0; r && (6 === e.previousNode.type || 0 == i && e.currentTimeline.hasCurrentStyleProperties()) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = Kd); let s = i; const a = e.invokeQuery(n.selector, n.originalSelector, n.limit, n.includeSelf, !!o.optional, e.errors); e.currentQueryTotal = a.length; let l = null; a.forEach((c, d) => { e.currentQueryIndex = d; const u = e.createSubContext(n.options, c); r && u.delayNextStep(r), c === e.element && (l = u.currentTimeline), Qt(this, n.animation, u), u.currentTimeline.applyStylesToKeyframe(), s = Math.max(s, u.currentTimeline.currentTime) }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(s), l && (e.currentTimeline.mergeTimelineCollectedStyles(l), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = n } visitStagger(n, e) { const i = e.parentContext, o = e.currentTimeline, r = n.timings, s = Math.abs(r.duration), a = s * (e.currentQueryTotal - 1); let l = s * e.currentQueryIndex; switch (r.duration < 0 ? "reverse" : r.easing) { case "reverse": l = a - l; break; case "full": l = i.currentStaggerTime }const d = e.currentTimeline; l && d.delayNextStep(l); const u = d.currentTime; Qt(this, n.animation, e), e.previousNode = n, i.currentStaggerTime = o.currentTime - u + (o.startTime - i.currentTimeline.startTime) } } const Kd = {}; class ug { constructor(n, e, i, o, r, s, a, l) { this._driver = n, this.element = e, this.subInstructions = i, this._enterClassName = o, this._leaveClassName = r, this.errors = s, this.timelines = a, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = Kd, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = l || new Qd(this._driver, e, 0), a.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(n, e) { if (!n) return; const i = n; let o = this.options; null != i.duration && (o.duration = fi(i.duration)), null != i.delay && (o.delay = fi(i.delay)); const r = i.params; if (r) { let s = o.params; s || (s = this.options.params = {}), Object.keys(r).forEach(a => { (!e || !s.hasOwnProperty(a)) && (s[a] = Xa(r[a], s, this.errors)) }) } } _copyOptions() { const n = {}; if (this.options) { const e = this.options.params; if (e) { const i = n.params = {}; Object.keys(e).forEach(o => { i[o] = e[o] }) } } return n } createSubContext(n = null, e, i) { const o = e || this.element, r = new ug(this._driver, o, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(o, i || 0)); return r.previousNode = this.previousNode, r.currentAnimateTimings = this.currentAnimateTimings, r.options = this._copyOptions(), r.updateOptions(n), r.currentQueryIndex = this.currentQueryIndex, r.currentQueryTotal = this.currentQueryTotal, r.parentContext = this, this.subContextCount++, r } transformIntoNewTimeline(n) { return this.previousNode = Kd, this.currentTimeline = this.currentTimeline.fork(this.element, n), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(n, e, i) { const o = { duration: e ?? n.duration, delay: this.currentTimeline.currentTime + (i ?? 0) + n.delay, easing: "" }, r = new tG(this._driver, n.element, n.keyframes, n.preStyleProps, n.postStyleProps, o, n.stretchStartingKeyframe); return this.timelines.push(r), o } incrementTime(n) { this.currentTimeline.forwardTime(this.currentTimeline.duration + n) } delayNextStep(n) { n > 0 && this.currentTimeline.delayNextStep(n) } invokeQuery(n, e, i, o, r, s) { let a = []; if (o && a.push(this.element), n.length > 0) { n = (n = n.replace(K8, "." + this._enterClassName)).replace(J8, "." + this._leaveClassName); let c = this._driver.query(this.element, n, 1 != i); 0 !== i && (c = i < 0 ? c.slice(c.length + i, c.length) : c.slice(0, i)), a.push(...c) } return !r && 0 == a.length && s.push(function c8(t) { return new b(3014, !1) }()), a } } class Qd { constructor(n, e, i, o) { this._driver = n, this.element = e, this.startTime = i, this._elementTimelineStylesLookup = o, this.duration = 0, this.easing = null, this._previousKeyframe = new Map, this._currentKeyframe = new Map, this._keyframes = new Map, this._styleSummary = new Map, this._localTimelineStyles = new Map, this._pendingStyles = new Map, this._backFill = new Map, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.hasCurrentStyleProperties(); default: return !0 } } hasCurrentStyleProperties() { return this._currentKeyframe.size > 0 } get currentTime() { return this.startTime + this.duration } delayNextStep(n) { const e = 1 === this._keyframes.size && this._pendingStyles.size; this.duration || e ? (this.forwardTime(this.currentTime + n), e && this.snapshotCurrentStyles()) : this.startTime += n } fork(n, e) { return this.applyStylesToKeyframe(), new Qd(this._driver, n, e || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = new Map, this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(n) { this.applyStylesToKeyframe(), this.duration = n, this._loadKeyframe() } _updateStyle(n, e) { this._localTimelineStyles.set(n, e), this._globalTimelineStyles.set(n, e), this._styleSummary.set(n, { time: this.currentTime, value: e }) } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(n) { n && this._previousKeyframe.set("easing", n); for (let [e, i] of this._globalTimelineStyles) this._backFill.set(e, i || hi), this._currentKeyframe.set(e, hi); this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(n, e, i, o) { e && this._previousKeyframe.set("easing", e); const r = o && o.params || {}, s = function nG(t, n) { const e = new Map; let i; return t.forEach(o => { if ("*" === o) { i = i || n.keys(); for (let r of i) e.set(r, hi) } else ji(o, e) }), e }(n, this._globalTimelineStyles); for (let [a, l] of s) { const c = Xa(l, r, i); this._pendingStyles.set(a, c), this._localTimelineStyles.has(a) || this._backFill.set(a, this._globalTimelineStyles.get(a) ?? hi), this._updateStyle(a, c) } } applyStylesToKeyframe() { 0 != this._pendingStyles.size && (this._pendingStyles.forEach((n, e) => { this._currentKeyframe.set(e, n) }), this._pendingStyles.clear(), this._localTimelineStyles.forEach((n, e) => { this._currentKeyframe.has(e) || this._currentKeyframe.set(e, n) })) } snapshotCurrentStyles() { for (let [n, e] of this._localTimelineStyles) this._pendingStyles.set(n, e), this._updateStyle(n, e) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const n = []; for (let e in this._currentKeyframe) n.push(e); return n } mergeTimelineCollectedStyles(n) { n._styleSummary.forEach((e, i) => { const o = this._styleSummary.get(i); (!o || e.time > o.time) && this._updateStyle(i, e.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const n = new Set, e = new Set, i = 1 === this._keyframes.size && 0 === this.duration; let o = []; this._keyframes.forEach((a, l) => { const c = ji(a, new Map, this._backFill); c.forEach((d, u) => { "!" === d ? n.add(u) : d === hi && e.add(u) }), i || c.set("offset", l / this.duration), o.push(c) }); const r = n.size ? qd(n.values()) : [], s = e.size ? qd(e.values()) : []; if (i) { const a = o[0], l = new Map(a); a.set("offset", 0), l.set("offset", 1), o = [a, l] } return cg(this.element, o, r, s, this.duration, this.startTime, this.easing, !1) } } class tG extends Qd { constructor(n, e, i, o, r, s, a = !1) { super(n, e, s.delay), this.keyframes = i, this.preStyleProps = o, this.postStyleProps = r, this._stretchStartingKeyframe = a, this.timings = { duration: s.duration, delay: s.delay, easing: s.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let n = this.keyframes, { delay: e, duration: i, easing: o } = this.timings; if (this._stretchStartingKeyframe && e) { const r = [], s = i + e, a = e / s, l = ji(n[0]); l.set("offset", 0), r.push(l); const c = ji(n[0]); c.set("offset", qM(a)), r.push(c); const d = n.length - 1; for (let u = 1; u <= d; u++) { let h = ji(n[u]); const f = h.get("offset"); h.set("offset", qM((e + f * i) / s)), r.push(h) } i = s, e = 0, o = "", n = r } return cg(this.element, n, this.preStyleProps, this.postStyleProps, i, e, o, !0) } } function qM(t, n = 3) { const e = Math.pow(10, n - 1); return Math.round(t * e) / e } class hg { } const iG = new Set(["width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "left", "top", "bottom", "right", "fontSize", "outlineWidth", "outlineOffset", "paddingTop", "paddingLeft", "paddingBottom", "paddingRight", "marginTop", "marginLeft", "marginBottom", "marginRight", "borderRadius", "borderWidth", "borderTopWidth", "borderLeftWidth", "borderRightWidth", "borderBottomWidth", "textIndent", "perspective"]); class oG extends hg { normalizePropertyName(n, e) { return sg(n) } normalizeStyleValue(n, e, i, o) { let r = ""; const s = i.toString().trim(); if (iG.has(e) && 0 !== i && "0" !== i) if ("number" == typeof i) r = "px"; else { const a = i.match(/^[+-]?[\d\.]+([a-z]*)$/); a && 0 == a[1].length && o.push(function Q5(t, n) { return new b(3005, !1) }()) } return s + r } } function WM(t, n, e, i, o, r, s, a, l, c, d, u, h) { return { type: 0, element: t, triggerName: n, isRemovalTransition: o, fromState: e, fromStyles: r, toState: i, toStyles: s, timelines: a, queriedElements: l, preStyleProps: c, postStyleProps: d, totalTime: u, errors: h } } const fg = {}; class YM { constructor(n, e, i) { this._triggerName = n, this.ast = e, this._stateStyles = i } match(n, e, i, o) { return function rG(t, n, e, i, o) { return t.some(r => r(n, e, i, o)) }(this.ast.matchers, n, e, i, o) } buildStyles(n, e, i) { let o = this._stateStyles.get("*"); return void 0 !== n && (o = this._stateStyles.get(n?.toString()) || o), o ? o.buildStyles(e, i) : new Map } build(n, e, i, o, r, s, a, l, c, d) { const u = [], h = this.ast.options && this.ast.options.params || fg, p = this.buildStyles(i, a && a.params || fg, u), m = l && l.params || fg, _ = this.buildStyles(o, m, u), C = new Set, v = new Map, M = new Map, O = "void" === o, $ = { params: sG(m, h), delay: this.ast.options?.delay }, ve = d ? [] : dg(n, e, this.ast.animation, r, s, p, _, $, c, u); let Me = 0; if (ve.forEach(Jt => { Me = Math.max(Jt.duration + Jt.delay, Me) }), u.length) return WM(e, this._triggerName, i, o, O, p, _, [], [], v, M, Me, u); ve.forEach(Jt => { const In = Jt.element, nu = Kt(v, In, new Set); Jt.preStyleProps.forEach(So => nu.add(So)); const Qa = Kt(M, In, new Set); Jt.postStyleProps.forEach(So => Qa.add(So)), In !== e && C.add(In) }); const ct = qd(C.values()); return WM(e, this._triggerName, i, o, O, p, _, ve, ct, v, M, Me) } } function sG(t, n) { const e = Ya(n); for (const i in t) t.hasOwnProperty(i) && null != t[i] && (e[i] = t[i]); return e } class aG { constructor(n, e, i) { this.styles = n, this.defaultParams = e, this.normalizer = i } buildStyles(n, e) { const i = new Map, o = Ya(this.defaultParams); return Object.keys(n).forEach(r => { const s = n[r]; null !== s && (o[r] = s) }), this.styles.styles.forEach(r => { "string" != typeof r && r.forEach((s, a) => { s && (s = Xa(s, o, e)); const l = this.normalizer.normalizePropertyName(a, e); s = this.normalizer.normalizeStyleValue(a, l, s, e), i.set(a, s) }) }), i } } class cG { constructor(n, e, i) { this.name = n, this.ast = e, this._normalizer = i, this.transitionFactories = [], this.states = new Map, e.states.forEach(o => { this.states.set(o.name, new aG(o.style, o.options && o.options.params || {}, i)) }), ZM(this.states, "true", "1"), ZM(this.states, "false", "0"), e.transitions.forEach(o => { this.transitionFactories.push(new YM(n, o, this.states)) }), this.fallbackTransition = function dG(t, n, e) { return new YM(t, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(s, a) => !0], options: null, queryCount: 0, depCount: 0 }, n) }(n, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(n, e, i, o) { return this.transitionFactories.find(s => s.match(n, e, i, o)) || null } matchStyles(n, e, i) { return this.fallbackTransition.buildStyles(n, e, i) } } function ZM(t, n, e) { t.has(n) ? t.has(e) || t.set(e, t.get(n)) : t.has(e) && t.set(n, t.get(e)) } const uG = new Xd; class hG { constructor(n, e, i) { this.bodyNode = n, this._driver = e, this._normalizer = i, this._animations = new Map, this._playersById = new Map, this.players = [] } register(n, e) { const i = [], r = ag(this._driver, e, i, []); if (i.length) throw function g8(t) { return new b(3503, !1) }(); this._animations.set(n, r) } _buildPlayer(n, e, i) { const o = n.element, r = RM(this._normalizer, n.keyframes, e, i); return this._driver.animate(o, r, n.duration, n.delay, n.easing, [], !0) } create(n, e, i = {}) { const o = [], r = this._animations.get(n); let s; const a = new Map; if (r ? (s = dg(this._driver, e, r, ng, Ud, new Map, new Map, i, uG, o), s.forEach(d => { const u = Kt(a, d.element, new Map); d.postStyleProps.forEach(h => u.set(h, null)) })) : (o.push(function _8() { return new b(3300, !1) }()), s = []), o.length) throw function v8(t) { return new b(3504, !1) }(); a.forEach((d, u) => { d.forEach((h, f) => { d.set(f, this._driver.computeStyle(u, f, hi)) }) }); const c = Bi(s.map(d => { const u = a.get(d.element); return this._buildPlayer(d, new Map, u) })); return this._playersById.set(n, c), c.onDestroy(() => this.destroy(n)), this.players.push(c), c } destroy(n) { const e = this._getPlayer(n); e.destroy(), this._playersById.delete(n); const i = this.players.indexOf(e); i >= 0 && this.players.splice(i, 1) } _getPlayer(n) { const e = this._playersById.get(n); if (!e) throw function b8(t) { return new b(3301, !1) }(); return e } listen(n, e, i, o) { const r = Jm(e, "", "", ""); return Km(this._getPlayer(n), i, r, o), () => { } } command(n, e, i, o) { if ("register" == i) return void this.register(n, o[0]); if ("create" == i) return void this.create(n, e, o[0] || {}); const r = this._getPlayer(n); switch (i) { case "play": r.play(); break; case "pause": r.pause(); break; case "reset": r.reset(); break; case "restart": r.restart(); break; case "finish": r.finish(); break; case "init": r.init(); break; case "setPosition": r.setPosition(parseFloat(o[0])); break; case "destroy": this.destroy(n) } } } const XM = "ng-animate-queued", pg = "ng-animate-disabled", _G = [], KM = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, vG = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }, Mn = "__ng_removed"; class mg { get params() { return this.options.params } constructor(n, e = "") { this.namespaceId = e; const i = n && n.hasOwnProperty("value"); if (this.value = function xG(t) { return t ?? null }(i ? n.value : n), i) { const r = Ya(n); delete r.value, this.options = r } else this.options = {}; this.options.params || (this.options.params = {}) } absorbOptions(n) { const e = n.params; if (e) { const i = this.options.params; Object.keys(e).forEach(o => { null == i[o] && (i[o] = e[o]) }) } } } const Ka = "void", gg = new mg(Ka); class bG { constructor(n, e, i) { this.id = n, this.hostElement = e, this._engine = i, this.players = [], this._triggers = new Map, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + n, gn(e, this._hostClassName) } listen(n, e, i, o) { if (!this._triggers.has(e)) throw function y8(t, n) { return new b(3302, !1) }(); if (null == i || 0 == i.length) throw function w8(t) { return new b(3303, !1) }(); if (!function CG(t) { return "start" == t || "done" == t }(i)) throw function x8(t, n) { return new b(3400, !1) }(); const r = Kt(this._elementListeners, n, []), s = { name: e, phase: i, callback: o }; r.push(s); const a = Kt(this._engine.statesByElement, n, new Map); return a.has(e) || (gn(n, zd), gn(n, zd + "-" + e), a.set(e, gg)), () => { this._engine.afterFlush(() => { const l = r.indexOf(s); l >= 0 && r.splice(l, 1), this._triggers.has(e) || a.delete(e) }) } } register(n, e) { return !this._triggers.has(n) && (this._triggers.set(n, e), !0) } _getTrigger(n) { const e = this._triggers.get(n); if (!e) throw function C8(t) { return new b(3401, !1) }(); return e } trigger(n, e, i, o = !0) { const r = this._getTrigger(e), s = new _g(this.id, e, n); let a = this._engine.statesByElement.get(n); a || (gn(n, zd), gn(n, zd + "-" + e), this._engine.statesByElement.set(n, a = new Map)); let l = a.get(e); const c = new mg(i, this.id); if (!(i && i.hasOwnProperty("value")) && l && c.absorbOptions(l.options), a.set(e, c), l || (l = gg), c.value !== Ka && l.value === c.value) { if (!function SG(t, n) { const e = Object.keys(t), i = Object.keys(n); if (e.length != i.length) return !1; for (let o = 0; o < e.length; o++) { const r = e[o]; if (!n.hasOwnProperty(r) || t[r] !== n[r]) return !1 } return !0 }(l.params, c.params)) { const m = [], _ = r.matchStyles(l.value, l.params, m), C = r.matchStyles(c.value, c.params, m); m.length ? this._engine.reportError(m) : this._engine.afterFlush(() => { Do(n, _), Wn(n, C) }) } return } const h = Kt(this._engine.playersByElement, n, []); h.forEach(m => { m.namespaceId == this.id && m.triggerName == e && m.queued && m.destroy() }); let f = r.matchTransition(l.value, c.value, n, c.params), p = !1; if (!f) { if (!o) return; f = r.fallbackTransition, p = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: n, triggerName: e, transition: f, fromState: l, toState: c, player: s, isFallbackTransition: p }), p || (gn(n, XM), s.onStart(() => { es(n, XM) })), s.onDone(() => { let m = this.players.indexOf(s); m >= 0 && this.players.splice(m, 1); const _ = this._engine.playersByElement.get(n); if (_) { let C = _.indexOf(s); C >= 0 && _.splice(C, 1) } }), this.players.push(s), h.push(s), s } deregister(n) { this._triggers.delete(n), this._engine.statesByElement.forEach(e => e.delete(n)), this._elementListeners.forEach((e, i) => { this._elementListeners.set(i, e.filter(o => o.name != n)) }) } clearElementCache(n) { this._engine.statesByElement.delete(n), this._elementListeners.delete(n); const e = this._engine.playersByElement.get(n); e && (e.forEach(i => i.destroy()), this._engine.playersByElement.delete(n)) } _signalRemovalForInnerTriggers(n, e) { const i = this._engine.driver.query(n, $d, !0); i.forEach(o => { if (o[Mn]) return; const r = this._engine.fetchNamespacesByElement(o); r.size ? r.forEach(s => s.triggerLeaveAnimation(o, e, !1, !0)) : this.clearElementCache(o) }), this._engine.afterFlushAnimationsDone(() => i.forEach(o => this.clearElementCache(o))) } triggerLeaveAnimation(n, e, i, o) { const r = this._engine.statesByElement.get(n), s = new Map; if (r) { const a = []; if (r.forEach((l, c) => { if (s.set(c, l.value), this._triggers.has(c)) { const d = this.trigger(n, c, Ka, o); d && a.push(d) } }), a.length) return this._engine.markElementAsRemoved(this.id, n, !0, e, s), i && Bi(a).onDone(() => this._engine.processLeaveNode(n)), !0 } return !1 } prepareLeaveAnimationListeners(n) { const e = this._elementListeners.get(n), i = this._engine.statesByElement.get(n); if (e && i) { const o = new Set; e.forEach(r => { const s = r.name; if (o.has(s)) return; o.add(s); const l = this._triggers.get(s).fallbackTransition, c = i.get(s) || gg, d = new mg(Ka), u = new _g(this.id, s, n); this._engine.totalQueuedPlayers++, this._queue.push({ element: n, triggerName: s, transition: l, fromState: c, toState: d, player: u, isFallbackTransition: !0 }) }) } } removeNode(n, e) { const i = this._engine; if (n.childElementCount && this._signalRemovalForInnerTriggers(n, e), this.triggerLeaveAnimation(n, e, !0)) return; let o = !1; if (i.totalAnimations) { const r = i.players.length ? i.playersByQueriedElement.get(n) : []; if (r && r.length) o = !0; else { let s = n; for (; s = s.parentNode;)if (i.statesByElement.get(s)) { o = !0; break } } } if (this.prepareLeaveAnimationListeners(n), o) i.markElementAsRemoved(this.id, n, !1, e); else { const r = n[Mn]; (!r || r === KM) && (i.afterFlush(() => this.clearElementCache(n)), i.destroyInnerAnimations(n), i._onRemovalComplete(n, e)) } } insertNode(n, e) { gn(n, this._hostClassName) } drainQueuedTransitions(n) { const e = []; return this._queue.forEach(i => { const o = i.player; if (o.destroyed) return; const r = i.element, s = this._elementListeners.get(r); s && s.forEach(a => { if (a.name == i.triggerName) { const l = Jm(r, i.triggerName, i.fromState.value, i.toState.value); l._data = n, Km(i.player, a.phase, l, a.callback) } }), o.markedForDestroy ? this._engine.afterFlush(() => { o.destroy() }) : e.push(i) }), this._queue = [], e.sort((i, o) => { const r = i.transition.ast.depCount, s = o.transition.ast.depCount; return 0 == r || 0 == s ? r - s : this._engine.driver.containsElement(i.element, o.element) ? 1 : -1 }) } destroy(n) { this.players.forEach(e => e.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, n) } } class yG { _onRemovalComplete(n, e) { this.onRemovalComplete(n, e) } constructor(n, e, i) { this.bodyNode = n, this.driver = e, this._normalizer = i, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (o, r) => { } } get queuedPlayers() { const n = []; return this._namespaceList.forEach(e => { e.players.forEach(i => { i.queued && n.push(i) }) }), n } createNamespace(n, e) { const i = new bG(n, e, this); return this.bodyNode && this.driver.containsElement(this.bodyNode, e) ? this._balanceNamespaceList(i, e) : (this.newHostElements.set(e, i), this.collectEnterElement(e)), this._namespaceLookup[n] = i } _balanceNamespaceList(n, e) { const i = this._namespaceList, o = this.namespacesByHostElement; if (i.length - 1 >= 0) { let s = !1, a = this.driver.getParentElement(e); for (; a;) { const l = o.get(a); if (l) { const c = i.indexOf(l); i.splice(c + 1, 0, n), s = !0; break } a = this.driver.getParentElement(a) } s || i.unshift(n) } else i.push(n); return o.set(e, n), n } register(n, e) { let i = this._namespaceLookup[n]; return i || (i = this.createNamespace(n, e)), i } registerTrigger(n, e, i) { let o = this._namespaceLookup[n]; o && o.register(e, i) && this.totalAnimations++ } destroy(n, e) { n && (this.afterFlush(() => { }), this.afterFlushAnimationsDone(() => { const i = this._fetchNamespace(n); this.namespacesByHostElement.delete(i.hostElement); const o = this._namespaceList.indexOf(i); o >= 0 && this._namespaceList.splice(o, 1), i.destroy(e), delete this._namespaceLookup[n] })) } _fetchNamespace(n) { return this._namespaceLookup[n] } fetchNamespacesByElement(n) { const e = new Set, i = this.statesByElement.get(n); if (i) for (let o of i.values()) if (o.namespaceId) { const r = this._fetchNamespace(o.namespaceId); r && e.add(r) } return e } trigger(n, e, i, o) { if (Jd(e)) { const r = this._fetchNamespace(n); if (r) return r.trigger(e, i, o), !0 } return !1 } insertNode(n, e, i, o) { if (!Jd(e)) return; const r = e[Mn]; if (r && r.setForRemoval) { r.setForRemoval = !1, r.setForMove = !0; const s = this.collectedLeaveElements.indexOf(e); s >= 0 && this.collectedLeaveElements.splice(s, 1) } if (n) { const s = this._fetchNamespace(n); s && s.insertNode(e, i) } o && this.collectEnterElement(e) } collectEnterElement(n) { this.collectedEnterElements.push(n) } markElementAsDisabled(n, e) { e ? this.disabledNodes.has(n) || (this.disabledNodes.add(n), gn(n, pg)) : this.disabledNodes.has(n) && (this.disabledNodes.delete(n), es(n, pg)) } removeNode(n, e, i) { if (Jd(e)) { const o = n ? this._fetchNamespace(n) : null; o ? o.removeNode(e, i) : this.markElementAsRemoved(n, e, !1, i); const r = this.namespacesByHostElement.get(e); r && r.id !== n && r.removeNode(e, i) } else this._onRemovalComplete(e, i) } markElementAsRemoved(n, e, i, o, r) { this.collectedLeaveElements.push(e), e[Mn] = { namespaceId: n, setForRemoval: o, hasAnimation: i, removedBeforeQueried: !1, previousTriggersValues: r } } listen(n, e, i, o, r) { return Jd(e) ? this._fetchNamespace(n).listen(e, i, o, r) : () => { } } _buildInstruction(n, e, i, o, r) { return n.transition.build(this.driver, n.element, n.fromState.value, n.toState.value, i, o, n.fromState.options, n.toState.options, e, r) } destroyInnerAnimations(n) { let e = this.driver.query(n, $d, !0); e.forEach(i => this.destroyActiveAnimationsForElement(i)), 0 != this.playersByQueriedElement.size && (e = this.driver.query(n, ig, !0), e.forEach(i => this.finishActiveQueriedAnimationOnElement(i))) } destroyActiveAnimationsForElement(n) { const e = this.playersByElement.get(n); e && e.forEach(i => { i.queued ? i.markedForDestroy = !0 : i.destroy() }) } finishActiveQueriedAnimationOnElement(n) { const e = this.playersByQueriedElement.get(n); e && e.forEach(i => i.finish()) } whenRenderingDone() { return new Promise(n => { if (this.players.length) return Bi(this.players).onDone(() => n()); n() }) } processLeaveNode(n) { const e = n[Mn]; if (e && e.setForRemoval) { if (n[Mn] = KM, e.namespaceId) { this.destroyInnerAnimations(n); const i = this._fetchNamespace(e.namespaceId); i && i.clearElementCache(n) } this._onRemovalComplete(n, e.setForRemoval) } n.classList?.contains(pg) && this.markElementAsDisabled(n, !1), this.driver.query(n, ".ng-animate-disabled", !0).forEach(i => { this.markElementAsDisabled(i, !1) }) } flush(n = -1) { let e = []; if (this.newHostElements.size && (this.newHostElements.forEach((i, o) => this._balanceNamespaceList(i, o)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let i = 0; i < this.collectedEnterElements.length; i++)gn(this.collectedEnterElements[i], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const i = []; try { e = this._flushAnimations(i, n) } finally { for (let o = 0; o < i.length; o++)i[o]() } } else for (let i = 0; i < this.collectedLeaveElements.length; i++)this.processLeaveNode(this.collectedLeaveElements[i]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(i => i()), this._flushFns = [], this._whenQuietFns.length) { const i = this._whenQuietFns; this._whenQuietFns = [], e.length ? Bi(e).onDone(() => { i.forEach(o => o()) }) : i.forEach(o => o()) } } reportError(n) { throw function D8(t) { return new b(3402, !1) }() } _flushAnimations(n, e) { const i = new Xd, o = [], r = new Map, s = [], a = new Map, l = new Map, c = new Map, d = new Set; this.disabledNodes.forEach(F => { d.add(F); const L = this.driver.query(F, ".ng-animate-queued", !0); for (let V = 0; V < L.length; V++)d.add(L[V]) }); const u = this.bodyNode, h = Array.from(this.statesByElement.keys()), f = eI(h, this.collectedEnterElements), p = new Map; let m = 0; f.forEach((F, L) => { const V = ng + m++; p.set(L, V), F.forEach(le => gn(le, V)) }); const _ = [], C = new Set, v = new Set; for (let F = 0; F < this.collectedLeaveElements.length; F++) { const L = this.collectedLeaveElements[F], V = L[Mn]; V && V.setForRemoval && (_.push(L), C.add(L), V.hasAnimation ? this.driver.query(L, ".ng-star-inserted", !0).forEach(le => C.add(le)) : v.add(L)) } const M = new Map, O = eI(h, Array.from(C)); O.forEach((F, L) => { const V = Ud + m++; M.set(L, V), F.forEach(le => gn(le, V)) }), n.push(() => { f.forEach((F, L) => { const V = p.get(L); F.forEach(le => es(le, V)) }), O.forEach((F, L) => { const V = M.get(L); F.forEach(le => es(le, V)) }), _.forEach(F => { this.processLeaveNode(F) }) }); const $ = [], ve = []; for (let F = this._namespaceList.length - 1; F >= 0; F--)this._namespaceList[F].drainQueuedTransitions(e).forEach(V => { const le = V.player, et = V.element; if ($.push(le), this.collectedEnterElements.length) { const _t = et[Mn]; if (_t && _t.setForMove) { if (_t.previousTriggersValues && _t.previousTriggersValues.has(V.triggerName)) { const Mo = _t.previousTriggersValues.get(V.triggerName), _n = this.statesByElement.get(V.element); if (_n && _n.has(V.triggerName)) { const iu = _n.get(V.triggerName); iu.value = Mo, _n.set(V.triggerName, iu) } } return void le.destroy() } } const Yn = !u || !this.driver.containsElement(u, et), en = M.get(et), Hi = p.get(et), ke = this._buildInstruction(V, i, Hi, en, Yn); if (ke.errors && ke.errors.length) return void ve.push(ke); if (Yn) return le.onStart(() => Do(et, ke.fromStyles)), le.onDestroy(() => Wn(et, ke.toStyles)), void o.push(le); if (V.isFallbackTransition) return le.onStart(() => Do(et, ke.fromStyles)), le.onDestroy(() => Wn(et, ke.toStyles)), void o.push(le); const uI = []; ke.timelines.forEach(_t => { _t.stretchStartingKeyframe = !0, this.disabledNodes.has(_t.element) || uI.push(_t) }), ke.timelines = uI, i.append(et, ke.timelines), s.push({ instruction: ke, player: le, element: et }), ke.queriedElements.forEach(_t => Kt(a, _t, []).push(le)), ke.preStyleProps.forEach((_t, Mo) => { if (_t.size) { let _n = l.get(Mo); _n || l.set(Mo, _n = new Set), _t.forEach((iu, yg) => _n.add(yg)) } }), ke.postStyleProps.forEach((_t, Mo) => { let _n = c.get(Mo); _n || c.set(Mo, _n = new Set), _t.forEach((iu, yg) => _n.add(yg)) }) }); if (ve.length) { const F = []; ve.forEach(L => { F.push(function E8(t, n) { return new b(3505, !1) }()) }), $.forEach(L => L.destroy()), this.reportError(F) } const Me = new Map, ct = new Map; s.forEach(F => { const L = F.element; i.has(L) && (ct.set(L, L), this._beforeAnimationBuild(F.player.namespaceId, F.instruction, Me)) }), o.forEach(F => { const L = F.element; this._getPreviousPlayers(L, !1, F.namespaceId, F.triggerName, null).forEach(le => { Kt(Me, L, []).push(le), le.destroy() }) }); const Jt = _.filter(F => nI(F, l, c)), In = new Map; JM(In, this.driver, v, c, hi).forEach(F => { nI(F, l, c) && Jt.push(F) }); const Qa = new Map; f.forEach((F, L) => { JM(Qa, this.driver, new Set(F), l, "!") }), Jt.forEach(F => { const L = In.get(F), V = Qa.get(F); In.set(F, new Map([...L?.entries() ?? [], ...V?.entries() ?? []])) }); const So = [], cI = [], dI = {}; s.forEach(F => { const { element: L, player: V, instruction: le } = F; if (i.has(L)) { if (d.has(L)) return V.onDestroy(() => Wn(L, le.toStyles)), V.disabled = !0, V.overrideTotalTime(le.totalTime), void o.push(V); let et = dI; if (ct.size > 1) { let en = L; const Hi = []; for (; en = en.parentNode;) { const ke = ct.get(en); if (ke) { et = ke; break } Hi.push(en) } Hi.forEach(ke => ct.set(ke, et)) } const Yn = this._buildAnimation(V.namespaceId, le, Me, r, Qa, In); if (V.setRealPlayer(Yn), et === dI) So.push(V); else { const en = this.playersByElement.get(et); en && en.length && (V.parentPlayer = Bi(en)), o.push(V) } } else Do(L, le.fromStyles), V.onDestroy(() => Wn(L, le.toStyles)), cI.push(V), d.has(L) && o.push(V) }), cI.forEach(F => { const L = r.get(F.element); if (L && L.length) { const V = Bi(L); F.setRealPlayer(V) } }), o.forEach(F => { F.parentPlayer ? F.syncPlayerEvents(F.parentPlayer) : F.destroy() }); for (let F = 0; F < _.length; F++) { const L = _[F], V = L[Mn]; if (es(L, Ud), V && V.hasAnimation) continue; let le = []; if (a.size) { let Yn = a.get(L); Yn && Yn.length && le.push(...Yn); let en = this.driver.query(L, ig, !0); for (let Hi = 0; Hi < en.length; Hi++) { let ke = a.get(en[Hi]); ke && ke.length && le.push(...ke) } } const et = le.filter(Yn => !Yn.destroyed); et.length ? DG(this, L, et) : this.processLeaveNode(L) } return _.length = 0, So.forEach(F => { this.players.push(F), F.onDone(() => { F.destroy(); const L = this.players.indexOf(F); this.players.splice(L, 1) }), F.play() }), So } afterFlush(n) { this._flushFns.push(n) } afterFlushAnimationsDone(n) { this._whenQuietFns.push(n) } _getPreviousPlayers(n, e, i, o, r) { let s = []; if (e) { const a = this.playersByQueriedElement.get(n); a && (s = a) } else { const a = this.playersByElement.get(n); if (a) { const l = !r || r == Ka; a.forEach(c => { c.queued || !l && c.triggerName != o || s.push(c) }) } } return (i || o) && (s = s.filter(a => !(i && i != a.namespaceId || o && o != a.triggerName))), s } _beforeAnimationBuild(n, e, i) { const r = e.element, s = e.isRemovalTransition ? void 0 : n, a = e.isRemovalTransition ? void 0 : e.triggerName; for (const l of e.timelines) { const c = l.element, d = c !== r, u = Kt(i, c, []); this._getPreviousPlayers(c, d, s, a, e.toState).forEach(f => { const p = f.getRealPlayer(); p.beforeDestroy && p.beforeDestroy(), f.destroy(), u.push(f) }) } Do(r, e.fromStyles) } _buildAnimation(n, e, i, o, r, s) { const a = e.triggerName, l = e.element, c = [], d = new Set, u = new Set, h = e.timelines.map(p => { const m = p.element; d.add(m); const _ = m[Mn]; if (_ && _.removedBeforeQueried) return new Ga(p.duration, p.delay); const C = m !== l, v = function EG(t) { const n = []; return tI(t, n), n }((i.get(m) || _G).map(Me => Me.getRealPlayer())).filter(Me => !!Me.element && Me.element === m), M = r.get(m), O = s.get(m), $ = RM(this._normalizer, p.keyframes, M, O), ve = this._buildPlayer(p, $, v); if (p.subTimeline && o && u.add(m), C) { const Me = new _g(n, a, m); Me.setRealPlayer(ve), c.push(Me) } return ve }); c.forEach(p => { Kt(this.playersByQueriedElement, p.element, []).push(p), p.onDone(() => function wG(t, n, e) { let i = t.get(n); if (i) { if (i.length) { const o = i.indexOf(e); i.splice(o, 1) } 0 == i.length && t.delete(n) } return i }(this.playersByQueriedElement, p.element, p)) }), d.forEach(p => gn(p, VM)); const f = Bi(h); return f.onDestroy(() => { d.forEach(p => es(p, VM)), Wn(l, e.toStyles) }), u.forEach(p => { Kt(o, p, []).push(f) }), f } _buildPlayer(n, e, i) { return e.length > 0 ? this.driver.animate(n.element, e, n.duration, n.delay, n.easing, i) : new Ga(n.duration, n.delay) } } class _g { constructor(n, e, i) { this.namespaceId = n, this.triggerName = e, this.element = i, this._player = new Ga, this._containsRealPlayer = !1, this._queuedCallbacks = new Map, this.destroyed = !1, this.parentPlayer = null, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(n) { this._containsRealPlayer || (this._player = n, this._queuedCallbacks.forEach((e, i) => { e.forEach(o => Km(n, i, void 0, o)) }), this._queuedCallbacks.clear(), this._containsRealPlayer = !0, this.overrideTotalTime(n.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(n) { this.totalTime = n } syncPlayerEvents(n) { const e = this._player; e.triggerCallback && n.onStart(() => e.triggerCallback("start")), n.onDone(() => this.finish()), n.onDestroy(() => this.destroy()) } _queueEvent(n, e) { Kt(this._queuedCallbacks, n, []).push(e) } onDone(n) { this.queued && this._queueEvent("done", n), this._player.onDone(n) } onStart(n) { this.queued && this._queueEvent("start", n), this._player.onStart(n) } onDestroy(n) { this.queued && this._queueEvent("destroy", n), this._player.onDestroy(n) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(n) { this.queued || this._player.setPosition(n) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(n) { const e = this._player; e.triggerCallback && e.triggerCallback(n) } } function Jd(t) { return t && 1 === t.nodeType } function QM(t, n) { const e = t.style.display; return t.style.display = n ?? "none", e } function JM(t, n, e, i, o) { const r = []; e.forEach(l => r.push(QM(l))); const s = []; i.forEach((l, c) => { const d = new Map; l.forEach(u => { const h = n.computeStyle(c, u, o); d.set(u, h), (!h || 0 == h.length) && (c[Mn] = vG, s.push(c)) }), t.set(c, d) }); let a = 0; return e.forEach(l => QM(l, r[a++])), s } function eI(t, n) { const e = new Map; if (t.forEach(a => e.set(a, [])), 0 == n.length) return e; const o = new Set(n), r = new Map; function s(a) { if (!a) return 1; let l = r.get(a); if (l) return l; const c = a.parentNode; return l = e.has(c) ? c : o.has(c) ? 1 : s(c), r.set(a, l), l } return n.forEach(a => { const l = s(a); 1 !== l && e.get(l).push(a) }), e } function gn(t, n) { t.classList?.add(n) } function es(t, n) { t.classList?.remove(n) } function DG(t, n, e) { Bi(e).onDone(() => t.processLeaveNode(n)) } function tI(t, n) { for (let e = 0; e < t.length; e++) { const i = t[e]; i instanceof $S ? tI(i.players, n) : n.push(i) } } function nI(t, n, e) { const i = e.get(t); if (!i) return !1; let o = n.get(t); return o ? i.forEach(r => o.add(r)) : n.set(t, i), e.delete(t), !0 } class eu { constructor(n, e, i) { this.bodyNode = n, this._driver = e, this._normalizer = i, this._triggerCache = {}, this.onRemovalComplete = (o, r) => { }, this._transitionEngine = new yG(n, e, i), this._timelineEngine = new hG(n, e, i), this._transitionEngine.onRemovalComplete = (o, r) => this.onRemovalComplete(o, r) } registerTrigger(n, e, i, o, r) { const s = n + "-" + o; let a = this._triggerCache[s]; if (!a) { const l = [], d = ag(this._driver, r, l, []); if (l.length) throw function p8(t, n) { return new b(3404, !1) }(); a = function lG(t, n, e) { return new cG(t, n, e) }(o, d, this._normalizer), this._triggerCache[s] = a } this._transitionEngine.registerTrigger(e, o, a) } register(n, e) { this._transitionEngine.register(n, e) } destroy(n, e) { this._transitionEngine.destroy(n, e) } onInsert(n, e, i, o) { this._transitionEngine.insertNode(n, e, i, o) } onRemove(n, e, i) { this._transitionEngine.removeNode(n, e, i) } disableAnimations(n, e) { this._transitionEngine.markElementAsDisabled(n, e) } process(n, e, i, o) { if ("@" == i.charAt(0)) { const [r, s] = OM(i); this._timelineEngine.command(r, e, s, o) } else this._transitionEngine.trigger(n, e, i, o) } listen(n, e, i, o, r) { if ("@" == i.charAt(0)) { const [s, a] = OM(i); return this._timelineEngine.listen(s, e, a, r) } return this._transitionEngine.listen(n, e, i, o, r) } flush(n = -1) { this._transitionEngine.flush(n) } get players() { return [...this._transitionEngine.players, ...this._timelineEngine.players] } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } afterFlushAnimationsDone(n) { this._transitionEngine.afterFlushAnimationsDone(n) } } let IG = (() => { class t { static #e = this.initialStylesByElement = new WeakMap; constructor(e, i, o) { this._element = e, this._startStyles = i, this._endStyles = o, this._state = 0; let r = t.initialStylesByElement.get(e); r || t.initialStylesByElement.set(e, r = new Map), this._initialStyles = r } start() { this._state < 1 && (this._startStyles && Wn(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (Wn(this._element, this._initialStyles), this._endStyles && (Wn(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (t.initialStylesByElement.delete(this._element), this._startStyles && (Do(this._element, this._startStyles), this._endStyles = null), this._endStyles && (Do(this._element, this._endStyles), this._endStyles = null), Wn(this._element, this._initialStyles), this._state = 3) } } return t })(); function vg(t) { let n = null; return t.forEach((e, i) => { (function AG(t) { return "display" === t || "position" === t })(i) && (n = n || new Map, n.set(i, e)) }), n } class iI { constructor(n, e, i, o) { this.element = n, this.keyframes = e, this.options = i, this._specialStyles = o, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this._originalOnDoneFns = [], this._originalOnStartFns = [], this.time = 0, this.parentPlayer = null, this.currentSnapshot = new Map, this._duration = i.duration, this._delay = i.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(n => n()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const n = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, n, this.options), this._finalKeyframe = n.length ? n[n.length - 1] : new Map; const e = () => this._onFinish(); this.domPlayer.addEventListener("finish", e), this.onDestroy(() => { this.domPlayer.removeEventListener("finish", e) }) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _convertKeyframesToObject(n) { const e = []; return n.forEach(i => { e.push(Object.fromEntries(i)) }), e } _triggerWebAnimation(n, e, i) { return n.animate(this._convertKeyframesToObject(e), i) } onStart(n) { this._originalOnStartFns.push(n), this._onStartFns.push(n) } onDone(n) { this._originalOnDoneFns.push(n), this._onDoneFns.push(n) } onDestroy(n) { this._onDestroyFns.push(n) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(n => n()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(n => n()), this._onDestroyFns = []) } setPosition(n) { void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = n * this.time } getPosition() { return +(this.domPlayer.currentTime ?? 0) / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const n = new Map; this.hasStarted() && this._finalKeyframe.forEach((i, o) => { "offset" !== o && n.set(o, this._finished ? i : UM(this.element, o)) }), this.currentSnapshot = n } triggerCallback(n) { const e = "start" === n ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } } class TG { validateStyleProperty(n) { return !0 } validateAnimatableStyleProperty(n) { return !0 } matchesElement(n, e) { return !1 } containsElement(n, e) { return FM(n, e) } getParentElement(n) { return eg(n) } query(n, e, i) { return PM(n, e, i) } computeStyle(n, e, i) { return window.getComputedStyle(n)[e] } animate(n, e, i, o, r, s = []) { const l = { duration: i, delay: o, fill: 0 == o ? "both" : "forwards" }; r && (l.easing = r); const c = new Map, d = s.filter(f => f instanceof iI); (function L8(t, n) { return 0 === t || 0 === n })(i, o) && d.forEach(f => { f.currentSnapshot.forEach((p, m) => c.set(m, p)) }); let u = function F8(t) { return t.length ? t[0] instanceof Map ? t : t.map(n => BM(n)) : [] }(e).map(f => ji(f)); u = function V8(t, n, e) { if (e.size && n.length) { let i = n[0], o = []; if (e.forEach((r, s) => { i.has(s) || o.push(s), i.set(s, r) }), o.length) for (let r = 1; r < n.length; r++) { let s = n[r]; o.forEach(a => s.set(a, UM(t, a))) } } return n }(n, u, c); const h = function MG(t, n) { let e = null, i = null; return Array.isArray(n) && n.length ? (e = vg(n[0]), n.length > 1 && (i = vg(n[n.length - 1]))) : n instanceof Map && (e = vg(n)), e || i ? new IG(t, e, i) : null }(n, u); return new iI(n, u, l, h) } } let RG = (() => { class t extends US { constructor(e, i) { super(), this._nextAnimationId = 0, this._renderer = e.createRenderer(i.body, { id: "0", encapsulation: nn.None, styles: [], data: { animation: [] } }) } build(e) { const i = this._nextAnimationId.toString(); this._nextAnimationId++; const o = Array.isArray(e) ? zS(e) : e; return oI(this._renderer, null, i, "register", [o]), new OG(i, this._renderer) } static #e = this.\u0275fac = function (i) { return new (i || t)(w(Ls), w(te)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })(); class OG extends b3 { constructor(n, e) { super(), this._id = n, this._renderer = e } create(n, e) { return new kG(this._id, n, e || {}, this._renderer) } } class kG { constructor(n, e, i, o) { this.id = n, this.element = e, this._renderer = o, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", i) } _listen(n, e) { return this._renderer.listen(this.element, `@@${this.id}:${n}`, e) } _command(n, ...e) { return oI(this._renderer, this.element, this.id, n, e) } onDone(n) { this._listen("done", n) } onStart(n) { this._listen("start", n) } onDestroy(n) { this._listen("destroy", n) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset"), this._started = !1 } setPosition(n) { this._command("setPosition", n) } getPosition() { return this._renderer.engine.players[+this.id]?.getPosition() ?? 0 } } function oI(t, n, e, i, o) { return t.setProperty(n, `@@${e}:${i}`, o) } const rI = "@.disabled"; let FG = (() => { class t { constructor(e, i, o) { this.delegate = e, this.engine = i, this._zone = o, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, i.onRemovalComplete = (r, s) => { const a = s?.parentNode(r); a && s.removeChild(a, r) } } createRenderer(e, i) { const r = this.delegate.createRenderer(e, i); if (!(e && i && i.data && i.data.animation)) { let d = this._rendererCache.get(r); return d || (d = new sI("", r, this.engine, () => this._rendererCache.delete(r)), this._rendererCache.set(r, d)), d } const s = i.id, a = i.id + "-" + this._currentId; this._currentId++, this.engine.register(a, e); const l = d => { Array.isArray(d) ? d.forEach(l) : this.engine.registerTrigger(s, a, e, d.name, d) }; return i.data.animation.forEach(l), new PG(this, a, r, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { queueMicrotask(() => { this._microtaskId++ }) } scheduleListenerCallback(e, i, o) { e >= 0 && e < this._microtaskId ? this._zone.run(() => i(o)) : (0 == this._animationCallbacksBuffer.length && queueMicrotask(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(r => { const [s, a] = r; s(a) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([i, o])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } static #e = this.\u0275fac = function (i) { return new (i || t)(w(Ls), w(eu), w(z)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })(); class sI { constructor(n, e, i, o) { this.namespaceId = n, this.delegate = e, this.engine = i, this._onDestroy = o } get data() { return this.delegate.data } destroyNode(n) { this.delegate.destroyNode?.(n) } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.engine.afterFlushAnimationsDone(() => { queueMicrotask(() => { this.delegate.destroy() }) }), this._onDestroy?.() } createElement(n, e) { return this.delegate.createElement(n, e) } createComment(n) { return this.delegate.createComment(n) } createText(n) { return this.delegate.createText(n) } appendChild(n, e) { this.delegate.appendChild(n, e), this.engine.onInsert(this.namespaceId, e, n, !1) } insertBefore(n, e, i, o = !0) { this.delegate.insertBefore(n, e, i), this.engine.onInsert(this.namespaceId, e, n, o) } removeChild(n, e, i) { this.engine.onRemove(this.namespaceId, e, this.delegate) } selectRootElement(n, e) { return this.delegate.selectRootElement(n, e) } parentNode(n) { return this.delegate.parentNode(n) } nextSibling(n) { return this.delegate.nextSibling(n) } setAttribute(n, e, i, o) { this.delegate.setAttribute(n, e, i, o) } removeAttribute(n, e, i) { this.delegate.removeAttribute(n, e, i) } addClass(n, e) { this.delegate.addClass(n, e) } removeClass(n, e) { this.delegate.removeClass(n, e) } setStyle(n, e, i, o) { this.delegate.setStyle(n, e, i, o) } removeStyle(n, e, i) { this.delegate.removeStyle(n, e, i) } setProperty(n, e, i) { "@" == e.charAt(0) && e == rI ? this.disableAnimations(n, !!i) : this.delegate.setProperty(n, e, i) } setValue(n, e) { this.delegate.setValue(n, e) } listen(n, e, i) { return this.delegate.listen(n, e, i) } disableAnimations(n, e) { this.engine.disableAnimations(n, e) } } class PG extends sI { constructor(n, e, i, o, r) { super(e, i, o, r), this.factory = n, this.namespaceId = e } setProperty(n, e, i) { "@" == e.charAt(0) ? "." == e.charAt(1) && e == rI ? this.disableAnimations(n, i = void 0 === i || !!i) : this.engine.process(this.namespaceId, n, e.slice(1), i) : this.delegate.setProperty(n, e, i) } listen(n, e, i) { if ("@" == e.charAt(0)) { const o = function NG(t) { switch (t) { case "body": return document.body; case "document": return document; case "window": return window; default: return t } }(n); let r = e.slice(1), s = ""; return "@" != r.charAt(0) && ([r, s] = function LG(t) { const n = t.indexOf("."); return [t.substring(0, n), t.slice(n + 1)] }(r)), this.engine.listen(this.namespaceId, o, r, s, a => { this.factory.scheduleListenerCallback(a._data || -1, i, a) }) } return this.delegate.listen(n, e, i) } } const aI = [{ provide: US, useClass: RG }, { provide: hg, useFactory: function BG() { return new oG } }, { provide: eu, useClass: (() => { class t extends eu { constructor(e, i, o, r) { super(e.body, i, o) } ngOnDestroy() { this.flush() } static #e = this.\u0275fac = function (i) { return new (i || t)(w(te), w(tg), w(hg), w(Si)) }; static #t = this.\u0275prov = I({ token: t, factory: t.\u0275fac }) } return t })() }, { provide: Ls, useFactory: function jG(t, n, e) { return new FG(t, n, e) }, deps: [Rp, eu, z] }], bg = [{ provide: tg, useFactory: () => new TG }, { provide: eo, useValue: "BrowserAnimations" }, ...aI], lI = [{ provide: tg, useClass: NM }, { provide: eo, useValue: "NoopAnimations" }, ...aI]; let HG = (() => { class t { static withConfig(e) { return { ngModule: t, providers: e.disableAnimations ? lI : bg } } static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ providers: bg, imports: [yC] }) } return t })(); const GG = { provide: new E("mat-tooltip-scroll-strategy"), deps: [Wa], useFactory: function $G(t) { return () => t.scrollStrategies.reposition({ scrollThrottle: 20 }) } }; let WG = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ providers: [GG], imports: [Oj, Ar, EM, qe, qe, Hd] }) } return t })(), XG = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t }); static #n = this.\u0275inj = ae({ imports: [qe, Yp, qe] }) } return t })(), KG = (() => { class t { static #e = this.\u0275fac = function (i) { return new (i || t) }; static #t = this.\u0275mod = de({ type: t, bootstrap: [q5] }); static #n = this.\u0275inj = ae({ imports: [yC, N4, HG, aH, h3, Kz, s4, J$, WG, XG, I4, U5] }) } return t })(); EB().bootstrapModule(KG).catch(t => console.error(t)) } }, ne => { ne(ne.s = 603) }]);